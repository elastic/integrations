#!/bin/bash

source .buildkite/scripts/common.sh

set -euo pipefail

export BASE_DIR=$(pwd)
export GO_VERSION=$(cat .go-version)
export startTimeInMillis="$(date +%s%3N)"

export REPO_NAME=$(repo_name "${BUILDKITE_REPO}")
export TMP_FOLDER_TEMPLATE_BASE="tmp.${REPO_NAME}"
export TMP_FOLDER_TEMPLATE="${TMP_FOLDER_TEMPLATE_BASE}.XXXXXXXXX"

JENKINS_API_TOKEN_PATH=kv/ci-shared/platform-ingest/jenkins_api_tokens
SIGNING_PACKAGES_GCS_CREDENTIALS_PATH=kv/ci-shared/platform-ingest/signing_packages_gcs_artifacts_credentials
PACKAGE_UPLOADER_GCS_CREDENTIALS_PATH=kv/ci-shared/platform-ingest/package_storage_uploader

EC_TOKEN_PATH=kv/ci-shared/platform-ingest/platform-ingest-ec-qa
EC_DATA_PATH=secret/ci/elastic-integrations/ec_data

if [ -n "${ELASTIC_PACKAGE_LINKS_FILE_PATH+x}" ]; then
    # first upload pipeline does not have the environment variables defined in the YAML
    export ELASTIC_PACKAGE_LINKS_FILE_PATH=${BASE_DIR}/${ELASTIC_PACKAGE_LINKS_FILE_PATH}
fi

# TODO: add schedule-daily too ?
if [ ${BUILDKITE_PIPELINE_SLUG} == "integrations" ]; then
    if [ ${BUILDKITE_STEP_KEY} == "publish-packages" ]; then
        export JENKINS_USERNAME_SECRET=$(retry 5 vault kv get -field username ${JENKINS_API_TOKEN_PATH})
        export JENKINS_HOST_SECRET=$(retry 5 vault kv get -field internal_ci_host ${JENKINS_API_TOKEN_PATH})
        export JENKINS_TOKEN=$(retry 5 vault kv get -field internal_ci ${JENKINS_API_TOKEN_PATH})

        # signing job
        export SIGNING_PACKAGES_GCS_CREDENTIALS_SECRET=$(retry 5 vault kv get -field value ${SIGNING_PACKAGES_GCS_CREDENTIALS_PATH})

        # publishing job
        export PACKAGE_UPLOADER_GCS_CREDENTIALS_SECRET=$(retry 5 vault kv get -field value ${PACKAGE_UPLOADER_GCS_CREDENTIALS_PATH})
    fi
fi

# TODO: add schedule-daily too
if [ ${BUILDKITE_PIPELINE_SLUG} == "integrations" ]; then
    if [[ ${BUILDKITE_STEP_KEY} =~ test-integrations-serverless-(obs|security) ]]; then
        export ELASTIC_PACKAGE_AWS_SECRET_KEY=$(retry 5 vault kv get -field secret_key ${AWS_SERVICE_ACCOUNT_SECRET_PATH})
        export ELASTIC_PACKAGE_AWS_ACCESS_KEY=$(retry 5 vault kv get -field access_key ${AWS_SERVICE_ACCOUNT_SECRET_PATH})

        # Environment variables required by the service deployer
        export AWS_SECRET_ACCESS_KEY=${ELASTIC_PACKAGE_AWS_SECRET_KEY}
        export AWS_ACCESS_KEY_ID=${ELASTIC_PACKAGE_AWS_ACCESS_KEY}

        export EC_API_KEY_SECRET=$(retry 5 vault kv get -field apiKey ${EC_TOKEN_PATH})
        export EC_HOST_SECRET=$(retry 5 vault kv get -field url ${EC_TOKEN_PATH})
        export EC_REGION_SECRET=$(retry 5 vault read -field region_qa ${EC_DATA_PATH})
    fi
fi

if [ ${BUILDKITE_PIPELINE_SLUG} == "integrations-serverless" ]; then
    if [[ ${BUILDKITE_STEP_KEY} =~ run-integrations-serverless-(obs|security) ]]; then
        export ELASTIC_PACKAGE_AWS_SECRET_KEY=$(retry 5 vault kv get -field secret_key ${AWS_SERVICE_ACCOUNT_SECRET_PATH})
        export ELASTIC_PACKAGE_AWS_ACCESS_KEY=$(retry 5 vault kv get -field access_key ${AWS_SERVICE_ACCOUNT_SECRET_PATH})

        # Environment variables required by the service deployer
        export AWS_SECRET_ACCESS_KEY=${ELASTIC_PACKAGE_AWS_SECRET_KEY}
        export AWS_ACCESS_KEY_ID=${ELASTIC_PACKAGE_AWS_ACCESS_KEY}

        export EC_API_KEY_SECRET=$(retry 5 vault kv get -field apiKey ${EC_TOKEN_PATH})
        export EC_HOST_SECRET=$(retry 5 vault kv get -field url ${EC_TOKEN_PATH})
        export EC_REGION_SECRET=$(retry 5 vault read -field region_qa ${EC_DATA_PATH})
    fi
fi
