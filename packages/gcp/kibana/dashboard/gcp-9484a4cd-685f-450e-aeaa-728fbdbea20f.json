{
  "id": "gcp-9484a4cd-685f-450e-aeaa-728fbdbea20f",
  "type": "dashboard",
  "namespaces": [
    "default"
  ],
  "updated_at": "2022-09-14T09:47:20.533Z",
  "version": "WzcxOSwxXQ==",
  "attributes": {
    "description": "Overview of the VPC flow log data from Google Cloud.",
    "hits": 0,
    "kibanaSavedObjectMeta": {
      "searchSourceJSON": {
        "filter": [
          {
            "$state": {
              "store": "appState"
            },
            "meta": {
              "alias": null,
              "disabled": false,
              "indexRefName": "kibanaSavedObjectMeta.searchSourceJSON.filter[0].meta.index",
              "key": "data_stream.dataset",
              "negate": false,
              "params": {
                "query": "gcp.vpcflow"
              },
              "type": "phrase"
            },
            "query": {
              "match_phrase": {
                "data_stream.dataset": "gcp.vpcflow"
              }
            }
          }
        ],
        "query": {
          "language": "kuery",
          "query": ""
        }
      }
    },
    "optionsJSON": {
      "hidePanelTitles": false,
      "syncColors": false,
      "useMargins": true
    },
    "panelsJSON": [
      {
        "version": "7.17.0",
        "type": "visualization",
        "gridData": {
          "h": 5,
          "i": "a6977559-b547-4175-a1aa-f59715042492",
          "w": 40,
          "x": 0,
          "y": 0
        },
        "panelIndex": "a6977559-b547-4175-a1aa-f59715042492",
        "embeddableConfig": {
          "enhancements": {},
          "hidePanelTitles": true,
          "savedVis": {
            "data": {
              "aggs": [],
              "searchSource": {
                "filter": [],
                "query": {
                  "language": "kuery",
                  "query": ""
                }
              }
            },
            "description": "",
            "id": "",
            "params": {
              "fontSize": 12,
              "markdown": "# Google VPC Flow dashboard",
              "openLinksInNewTab": false
            },
            "title": "",
            "type": "markdown",
            "uiState": {}
          }
        }
      },
      {
        "version": "7.17.0",
        "type": "lens",
        "gridData": {
          "h": 11,
          "i": "fd65090b-d291-4771-865d-c5fa77a1b2a2",
          "w": 8,
          "x": 40,
          "y": 5
        },
        "panelIndex": "fd65090b-d291-4771-865d-c5fa77a1b2a2",
        "embeddableConfig": {
          "attributes": {
            "references": [
              {
                "id": "logs-*",
                "name": "indexpattern-datasource-current-indexpattern",
                "type": "index-pattern"
              },
              {
                "id": "logs-*",
                "name": "indexpattern-datasource-layer-9622b1fb-f543-4d05-b868-366fa865f9e7",
                "type": "index-pattern"
              }
            ],
            "state": {
              "datasourceStates": {
                "indexpattern": {
                  "layers": {
                    "9622b1fb-f543-4d05-b868-366fa865f9e7": {
                      "columnOrder": [
                        "93e747d6-f202-45f4-9813-129bb91a9306",
                        "a5152707-6084-46e1-a5a1-b3eb150a1a05"
                      ],
                      "columns": {
                        "93e747d6-f202-45f4-9813-129bb91a9306": {
                          "dataType": "string",
                          "isBucketed": true,
                          "label": "Top values of gcp.vpcflow.reporter",
                          "operationType": "terms",
                          "params": {
                            "missingBucket": false,
                            "orderBy": {
                              "columnId": "a5152707-6084-46e1-a5a1-b3eb150a1a05",
                              "type": "column"
                            },
                            "orderDirection": "desc",
                            "otherBucket": true,
                            "size": 5
                          },
                          "scale": "ordinal",
                          "sourceField": "gcp.vpcflow.reporter"
                        },
                        "a5152707-6084-46e1-a5a1-b3eb150a1a05": {
                          "dataType": "number",
                          "isBucketed": false,
                          "label": "Sum of network.bytes",
                          "operationType": "sum",
                          "scale": "ratio",
                          "sourceField": "network.bytes"
                        }
                      },
                      "incompleteColumns": {}
                    }
                  }
                }
              },
              "filters": [],
              "query": {
                "language": "kuery",
                "query": ""
              },
              "visualization": {
                "layers": [
                  {
                    "categoryDisplay": "default",
                    "groups": [
                      "93e747d6-f202-45f4-9813-129bb91a9306"
                    ],
                    "layerId": "9622b1fb-f543-4d05-b868-366fa865f9e7",
                    "layerType": "data",
                    "legendDisplay": "default",
                    "metric": "a5152707-6084-46e1-a5a1-b3eb150a1a05",
                    "nestedLegend": false,
                    "numberDisplay": "value"
                  }
                ],
                "shape": "donut"
              }
            },
            "title": "",
            "type": "lens",
            "visualizationType": "lnsPie"
          },
          "enhancements": {},
          "hidePanelTitles": false
        },
        "title": "Bytes per reporter"
      },
      {
        "version": "7.17.0",
        "type": "lens",
        "gridData": {
          "h": 11,
          "i": "4489b109-a7f8-4a9d-b85f-0fe613368eda",
          "w": 8,
          "x": 0,
          "y": 5
        },
        "panelIndex": "4489b109-a7f8-4a9d-b85f-0fe613368eda",
        "embeddableConfig": {
          "attributes": {
            "references": [
              {
                "id": "logs-*",
                "name": "indexpattern-datasource-current-indexpattern",
                "type": "index-pattern"
              },
              {
                "id": "logs-*",
                "name": "indexpattern-datasource-layer-9622b1fb-f543-4d05-b868-366fa865f9e7",
                "type": "index-pattern"
              }
            ],
            "state": {
              "datasourceStates": {
                "indexpattern": {
                  "layers": {
                    "9622b1fb-f543-4d05-b868-366fa865f9e7": {
                      "columnOrder": [
                        "93e747d6-f202-45f4-9813-129bb91a9306",
                        "a5152707-6084-46e1-a5a1-b3eb150a1a05"
                      ],
                      "columns": {
                        "93e747d6-f202-45f4-9813-129bb91a9306": {
                          "dataType": "string",
                          "isBucketed": true,
                          "label": "Top values of cloud.project.id",
                          "operationType": "terms",
                          "params": {
                            "missingBucket": false,
                            "orderBy": {
                              "columnId": "a5152707-6084-46e1-a5a1-b3eb150a1a05",
                              "type": "column"
                            },
                            "orderDirection": "desc",
                            "otherBucket": true,
                            "size": 5
                          },
                          "scale": "ordinal",
                          "sourceField": "cloud.project.id"
                        },
                        "a5152707-6084-46e1-a5a1-b3eb150a1a05": {
                          "dataType": "number",
                          "isBucketed": false,
                          "label": "Sum of network.bytes",
                          "operationType": "sum",
                          "scale": "ratio",
                          "sourceField": "network.bytes"
                        }
                      },
                      "incompleteColumns": {}
                    }
                  }
                }
              },
              "filters": [],
              "query": {
                "language": "kuery",
                "query": ""
              },
              "visualization": {
                "layers": [
                  {
                    "categoryDisplay": "default",
                    "groups": [
                      "93e747d6-f202-45f4-9813-129bb91a9306"
                    ],
                    "layerId": "9622b1fb-f543-4d05-b868-366fa865f9e7",
                    "layerType": "data",
                    "legendDisplay": "default",
                    "metric": "a5152707-6084-46e1-a5a1-b3eb150a1a05",
                    "nestedLegend": false,
                    "numberDisplay": "value"
                  }
                ],
                "shape": "donut"
              }
            },
            "title": "",
            "type": "lens",
            "visualizationType": "lnsPie"
          },
          "enhancements": {},
          "hidePanelTitles": false
        },
        "title": "Bytes per project"
      },
      {
        "version": "7.17.0",
        "type": "lens",
        "gridData": {
          "h": 11,
          "i": "061ff6b2-a70a-42dc-87fd-45d185b277ac",
          "w": 8,
          "x": 8,
          "y": 5
        },
        "panelIndex": "061ff6b2-a70a-42dc-87fd-45d185b277ac",
        "embeddableConfig": {
          "attributes": {
            "references": [
              {
                "id": "logs-*",
                "name": "indexpattern-datasource-current-indexpattern",
                "type": "index-pattern"
              },
              {
                "id": "logs-*",
                "name": "indexpattern-datasource-layer-9622b1fb-f543-4d05-b868-366fa865f9e7",
                "type": "index-pattern"
              }
            ],
            "state": {
              "datasourceStates": {
                "indexpattern": {
                  "layers": {
                    "9622b1fb-f543-4d05-b868-366fa865f9e7": {
                      "columnOrder": [
                        "93e747d6-f202-45f4-9813-129bb91a9306",
                        "a5152707-6084-46e1-a5a1-b3eb150a1a05"
                      ],
                      "columns": {
                        "93e747d6-f202-45f4-9813-129bb91a9306": {
                          "dataType": "string",
                          "isBucketed": true,
                          "label": "Top values of network.name",
                          "operationType": "terms",
                          "params": {
                            "missingBucket": false,
                            "orderBy": {
                              "columnId": "a5152707-6084-46e1-a5a1-b3eb150a1a05",
                              "type": "column"
                            },
                            "orderDirection": "desc",
                            "otherBucket": true,
                            "size": 5
                          },
                          "scale": "ordinal",
                          "sourceField": "network.name"
                        },
                        "a5152707-6084-46e1-a5a1-b3eb150a1a05": {
                          "dataType": "number",
                          "isBucketed": false,
                          "label": "Sum of network.bytes",
                          "operationType": "sum",
                          "scale": "ratio",
                          "sourceField": "network.bytes"
                        }
                      },
                      "incompleteColumns": {}
                    }
                  }
                }
              },
              "filters": [],
              "query": {
                "language": "kuery",
                "query": ""
              },
              "visualization": {
                "layers": [
                  {
                    "categoryDisplay": "default",
                    "groups": [
                      "93e747d6-f202-45f4-9813-129bb91a9306"
                    ],
                    "layerId": "9622b1fb-f543-4d05-b868-366fa865f9e7",
                    "layerType": "data",
                    "legendDisplay": "default",
                    "metric": "a5152707-6084-46e1-a5a1-b3eb150a1a05",
                    "nestedLegend": false,
                    "numberDisplay": "value"
                  }
                ],
                "shape": "donut"
              }
            },
            "title": "",
            "type": "lens",
            "visualizationType": "lnsPie"
          },
          "enhancements": {},
          "hidePanelTitles": false
        },
        "title": "Bytes per sub-network"
      },
      {
        "version": "7.17.0",
        "type": "lens",
        "gridData": {
          "h": 11,
          "i": "42eee1cd-e816-4f6e-a700-401e8ff1a2f5",
          "w": 8,
          "x": 16,
          "y": 5
        },
        "panelIndex": "42eee1cd-e816-4f6e-a700-401e8ff1a2f5",
        "embeddableConfig": {
          "attributes": {
            "references": [
              {
                "id": "logs-*",
                "name": "indexpattern-datasource-current-indexpattern",
                "type": "index-pattern"
              },
              {
                "id": "logs-*",
                "name": "indexpattern-datasource-layer-9622b1fb-f543-4d05-b868-366fa865f9e7",
                "type": "index-pattern"
              }
            ],
            "state": {
              "datasourceStates": {
                "indexpattern": {
                  "layers": {
                    "9622b1fb-f543-4d05-b868-366fa865f9e7": {
                      "columnOrder": [
                        "93e747d6-f202-45f4-9813-129bb91a9306",
                        "a5152707-6084-46e1-a5a1-b3eb150a1a05"
                      ],
                      "columns": {
                        "93e747d6-f202-45f4-9813-129bb91a9306": {
                          "dataType": "string",
                          "isBucketed": true,
                          "label": "Top values of cloud.region",
                          "operationType": "terms",
                          "params": {
                            "missingBucket": false,
                            "orderBy": {
                              "columnId": "a5152707-6084-46e1-a5a1-b3eb150a1a05",
                              "type": "column"
                            },
                            "orderDirection": "desc",
                            "otherBucket": true,
                            "size": 5
                          },
                          "scale": "ordinal",
                          "sourceField": "cloud.region"
                        },
                        "a5152707-6084-46e1-a5a1-b3eb150a1a05": {
                          "dataType": "number",
                          "isBucketed": false,
                          "label": "Sum of network.bytes",
                          "operationType": "sum",
                          "scale": "ratio",
                          "sourceField": "network.bytes"
                        }
                      },
                      "incompleteColumns": {}
                    }
                  }
                }
              },
              "filters": [],
              "query": {
                "language": "kuery",
                "query": ""
              },
              "visualization": {
                "layers": [
                  {
                    "categoryDisplay": "default",
                    "groups": [
                      "93e747d6-f202-45f4-9813-129bb91a9306"
                    ],
                    "layerId": "9622b1fb-f543-4d05-b868-366fa865f9e7",
                    "layerType": "data",
                    "legendDisplay": "default",
                    "metric": "a5152707-6084-46e1-a5a1-b3eb150a1a05",
                    "nestedLegend": false,
                    "numberDisplay": "value"
                  }
                ],
                "shape": "donut"
              }
            },
            "title": "",
            "type": "lens",
            "visualizationType": "lnsPie"
          },
          "enhancements": {},
          "hidePanelTitles": false
        },
        "title": "Bytes per region / zone"
      },
      {
        "version": "7.17.0",
        "type": "lens",
        "gridData": {
          "h": 11,
          "i": "9714edf3-3894-4567-b8ec-99b863f4fa74",
          "w": 8,
          "x": 24,
          "y": 5
        },
        "panelIndex": "9714edf3-3894-4567-b8ec-99b863f4fa74",
        "embeddableConfig": {
          "attributes": {
            "references": [
              {
                "id": "logs-*",
                "name": "indexpattern-datasource-current-indexpattern",
                "type": "index-pattern"
              },
              {
                "id": "logs-*",
                "name": "indexpattern-datasource-layer-9622b1fb-f543-4d05-b868-366fa865f9e7",
                "type": "index-pattern"
              }
            ],
            "state": {
              "datasourceStates": {
                "indexpattern": {
                  "layers": {
                    "9622b1fb-f543-4d05-b868-366fa865f9e7": {
                      "columnOrder": [
                        "93e747d6-f202-45f4-9813-129bb91a9306",
                        "a0ef9781-cada-4dac-a5c6-50b6d36aaace",
                        "a5152707-6084-46e1-a5a1-b3eb150a1a05"
                      ],
                      "columns": {
                        "93e747d6-f202-45f4-9813-129bb91a9306": {
                          "dataType": "string",
                          "isBucketed": true,
                          "label": "Top values of source.geo.continent_name",
                          "operationType": "terms",
                          "params": {
                            "missingBucket": false,
                            "orderBy": {
                              "columnId": "a5152707-6084-46e1-a5a1-b3eb150a1a05",
                              "type": "column"
                            },
                            "orderDirection": "desc",
                            "otherBucket": true,
                            "size": 5
                          },
                          "scale": "ordinal",
                          "sourceField": "source.geo.continent_name"
                        },
                        "a0ef9781-cada-4dac-a5c6-50b6d36aaace": {
                          "dataType": "string",
                          "isBucketed": true,
                          "label": "Top values of destination.geo.continent_name",
                          "operationType": "terms",
                          "params": {
                            "missingBucket": false,
                            "orderBy": {
                              "columnId": "a5152707-6084-46e1-a5a1-b3eb150a1a05",
                              "type": "column"
                            },
                            "orderDirection": "desc",
                            "otherBucket": true,
                            "size": 5
                          },
                          "scale": "ordinal",
                          "sourceField": "destination.geo.continent_name"
                        },
                        "a5152707-6084-46e1-a5a1-b3eb150a1a05": {
                          "dataType": "number",
                          "isBucketed": false,
                          "label": "Sum of network.bytes",
                          "operationType": "sum",
                          "scale": "ratio",
                          "sourceField": "network.bytes"
                        }
                      },
                      "incompleteColumns": {}
                    }
                  }
                }
              },
              "filters": [],
              "query": {
                "language": "kuery",
                "query": "event.dataset : \"gcp.vpcflow\" "
              },
              "visualization": {
                "layers": [
                  {
                    "categoryDisplay": "default",
                    "groups": [
                      "93e747d6-f202-45f4-9813-129bb91a9306",
                      "a0ef9781-cada-4dac-a5c6-50b6d36aaace"
                    ],
                    "layerId": "9622b1fb-f543-4d05-b868-366fa865f9e7",
                    "layerType": "data",
                    "legendDisplay": "default",
                    "metric": "a5152707-6084-46e1-a5a1-b3eb150a1a05",
                    "nestedLegend": false,
                    "numberDisplay": "value"
                  }
                ],
                "shape": "donut"
              }
            },
            "title": "",
            "type": "lens",
            "visualizationType": "lnsPie"
          },
          "enhancements": {},
          "hidePanelTitles": false
        },
        "title": "Bytes Source vs. Destination"
      },
      {
        "version": "7.17.0",
        "type": "lens",
        "gridData": {
          "h": 11,
          "i": "efe8857e-d137-4c24-ad83-dd7ddbea8c9e",
          "w": 8,
          "x": 32,
          "y": 5
        },
        "panelIndex": "efe8857e-d137-4c24-ad83-dd7ddbea8c9e",
        "embeddableConfig": {
          "attributes": {
            "references": [
              {
                "id": "logs-*",
                "name": "indexpattern-datasource-current-indexpattern",
                "type": "index-pattern"
              },
              {
                "id": "logs-*",
                "name": "indexpattern-datasource-layer-9622b1fb-f543-4d05-b868-366fa865f9e7",
                "type": "index-pattern"
              }
            ],
            "state": {
              "datasourceStates": {
                "indexpattern": {
                  "layers": {
                    "9622b1fb-f543-4d05-b868-366fa865f9e7": {
                      "columnOrder": [
                        "93e747d6-f202-45f4-9813-129bb91a9306",
                        "a5152707-6084-46e1-a5a1-b3eb150a1a05"
                      ],
                      "columns": {
                        "93e747d6-f202-45f4-9813-129bb91a9306": {
                          "dataType": "string",
                          "isBucketed": true,
                          "label": "Top values of network.direction",
                          "operationType": "terms",
                          "params": {
                            "missingBucket": false,
                            "orderBy": {
                              "columnId": "a5152707-6084-46e1-a5a1-b3eb150a1a05",
                              "type": "column"
                            },
                            "orderDirection": "desc",
                            "otherBucket": true,
                            "size": 5
                          },
                          "scale": "ordinal",
                          "sourceField": "network.direction"
                        },
                        "a5152707-6084-46e1-a5a1-b3eb150a1a05": {
                          "dataType": "number",
                          "isBucketed": false,
                          "label": "Sum of network.bytes",
                          "operationType": "sum",
                          "scale": "ratio",
                          "sourceField": "network.bytes"
                        }
                      },
                      "incompleteColumns": {}
                    }
                  }
                }
              },
              "filters": [],
              "query": {
                "language": "kuery",
                "query": ""
              },
              "visualization": {
                "layers": [
                  {
                    "categoryDisplay": "default",
                    "groups": [
                      "93e747d6-f202-45f4-9813-129bb91a9306"
                    ],
                    "layerId": "9622b1fb-f543-4d05-b868-366fa865f9e7",
                    "layerType": "data",
                    "legendDisplay": "default",
                    "metric": "a5152707-6084-46e1-a5a1-b3eb150a1a05",
                    "nestedLegend": false,
                    "numberDisplay": "value"
                  }
                ],
                "shape": "donut"
              }
            },
            "title": "",
            "type": "lens",
            "visualizationType": "lnsPie"
          },
          "enhancements": {},
          "hidePanelTitles": false
        },
        "title": "Bytes per direction"
      },
      {
        "version": "7.17.0",
        "type": "lens",
        "gridData": {
          "h": 7,
          "i": "289e8233-5d54-49c7-9b3a-30bab73711bb",
          "w": 24,
          "x": 24,
          "y": 46
        },
        "panelIndex": "289e8233-5d54-49c7-9b3a-30bab73711bb",
        "embeddableConfig": {
          "attributes": {
            "references": [
              {
                "id": "logs-*",
                "name": "indexpattern-datasource-current-indexpattern",
                "type": "index-pattern"
              },
              {
                "id": "logs-*",
                "name": "indexpattern-datasource-layer-102a3f02-3222-48bb-8c57-b29990ae1d97",
                "type": "index-pattern"
              }
            ],
            "state": {
              "datasourceStates": {
                "indexpattern": {
                  "layers": {
                    "102a3f02-3222-48bb-8c57-b29990ae1d97": {
                      "columnOrder": [
                        "d25096dc-6121-497e-b444-42e92618a871",
                        "5cb970e1-fff0-4b8c-8c74-7dc834bd2942",
                        "0647e623-e5b9-4b20-afdf-eba0badc2297"
                      ],
                      "columns": {
                        "0647e623-e5b9-4b20-afdf-eba0badc2297": {
                          "dataType": "number",
                          "isBucketed": false,
                          "label": "Sum of network.bytes",
                          "operationType": "sum",
                          "scale": "ratio",
                          "sourceField": "network.bytes"
                        },
                        "5cb970e1-fff0-4b8c-8c74-7dc834bd2942": {
                          "dataType": "date",
                          "isBucketed": true,
                          "label": "@timestamp",
                          "operationType": "date_histogram",
                          "params": {
                            "interval": "auto"
                          },
                          "scale": "interval",
                          "sourceField": "@timestamp"
                        },
                        "d25096dc-6121-497e-b444-42e92618a871": {
                          "dataType": "string",
                          "isBucketed": true,
                          "label": "Top values of source.domain",
                          "operationType": "terms",
                          "params": {
                            "missingBucket": false,
                            "orderBy": {
                              "columnId": "0647e623-e5b9-4b20-afdf-eba0badc2297",
                              "type": "column"
                            },
                            "orderDirection": "desc",
                            "otherBucket": true,
                            "size": 5
                          },
                          "scale": "ordinal",
                          "sourceField": "source.domain"
                        }
                      },
                      "incompleteColumns": {}
                    }
                  }
                }
              },
              "filters": [],
              "query": {
                "language": "kuery",
                "query": ""
              },
              "visualization": {
                "axisTitlesVisibilitySettings": {
                  "x": true,
                  "yLeft": true,
                  "yRight": true
                },
                "fittingFunction": "None",
                "gridlinesVisibilitySettings": {
                  "x": true,
                  "yLeft": true,
                  "yRight": true
                },
                "labelsOrientation": {
                  "x": 0,
                  "yLeft": 0,
                  "yRight": 0
                },
                "layers": [
                  {
                    "accessors": [
                      "0647e623-e5b9-4b20-afdf-eba0badc2297"
                    ],
                    "layerId": "102a3f02-3222-48bb-8c57-b29990ae1d97",
                    "layerType": "data",
                    "position": "top",
                    "seriesType": "bar_stacked",
                    "showGridlines": false,
                    "splitAccessor": "d25096dc-6121-497e-b444-42e92618a871",
                    "xAccessor": "5cb970e1-fff0-4b8c-8c74-7dc834bd2942"
                  }
                ],
                "legend": {
                  "isVisible": true,
                  "position": "right"
                },
                "preferredSeriesType": "bar_stacked",
                "tickLabelsVisibilitySettings": {
                  "x": true,
                  "yLeft": true,
                  "yRight": true
                },
                "valueLabels": "hide",
                "yLeftExtent": {
                  "mode": "full"
                },
                "yRightExtent": {
                  "mode": "full"
                }
              }
            },
            "title": "",
            "type": "lens",
            "visualizationType": "lnsXY"
          },
          "enhancements": {},
          "hidePanelTitles": false
        },
        "title": "Sum of bytes per source"
      },
      {
        "version": "7.17.0",
        "type": "lens",
        "gridData": {
          "h": 8,
          "i": "9d413864-ae26-4e79-a93d-df49fbad4913",
          "w": 24,
          "x": 24,
          "y": 53
        },
        "panelIndex": "9d413864-ae26-4e79-a93d-df49fbad4913",
        "embeddableConfig": {
          "attributes": {
            "references": [
              {
                "id": "logs-*",
                "name": "indexpattern-datasource-current-indexpattern",
                "type": "index-pattern"
              },
              {
                "id": "logs-*",
                "name": "indexpattern-datasource-layer-102a3f02-3222-48bb-8c57-b29990ae1d97",
                "type": "index-pattern"
              }
            ],
            "state": {
              "datasourceStates": {
                "indexpattern": {
                  "layers": {
                    "102a3f02-3222-48bb-8c57-b29990ae1d97": {
                      "columnOrder": [
                        "d25096dc-6121-497e-b444-42e92618a871",
                        "5cb970e1-fff0-4b8c-8c74-7dc834bd2942",
                        "0647e623-e5b9-4b20-afdf-eba0badc2297"
                      ],
                      "columns": {
                        "0647e623-e5b9-4b20-afdf-eba0badc2297": {
                          "dataType": "number",
                          "isBucketed": false,
                          "label": "Sum of network.bytes",
                          "operationType": "sum",
                          "scale": "ratio",
                          "sourceField": "network.bytes"
                        },
                        "5cb970e1-fff0-4b8c-8c74-7dc834bd2942": {
                          "dataType": "date",
                          "isBucketed": true,
                          "label": "@timestamp",
                          "operationType": "date_histogram",
                          "params": {
                            "interval": "auto"
                          },
                          "scale": "interval",
                          "sourceField": "@timestamp"
                        },
                        "d25096dc-6121-497e-b444-42e92618a871": {
                          "dataType": "string",
                          "isBucketed": true,
                          "label": "Top values of destination.domain",
                          "operationType": "terms",
                          "params": {
                            "missingBucket": false,
                            "orderBy": {
                              "columnId": "0647e623-e5b9-4b20-afdf-eba0badc2297",
                              "type": "column"
                            },
                            "orderDirection": "desc",
                            "otherBucket": true,
                            "size": 5
                          },
                          "scale": "ordinal",
                          "sourceField": "destination.domain"
                        }
                      },
                      "incompleteColumns": {}
                    }
                  }
                }
              },
              "filters": [],
              "query": {
                "language": "kuery",
                "query": ""
              },
              "visualization": {
                "axisTitlesVisibilitySettings": {
                  "x": true,
                  "yLeft": true,
                  "yRight": true
                },
                "fittingFunction": "None",
                "gridlinesVisibilitySettings": {
                  "x": true,
                  "yLeft": true,
                  "yRight": true
                },
                "labelsOrientation": {
                  "x": 0,
                  "yLeft": 0,
                  "yRight": 0
                },
                "layers": [
                  {
                    "accessors": [
                      "0647e623-e5b9-4b20-afdf-eba0badc2297"
                    ],
                    "layerId": "102a3f02-3222-48bb-8c57-b29990ae1d97",
                    "layerType": "data",
                    "position": "top",
                    "seriesType": "bar_stacked",
                    "showGridlines": false,
                    "splitAccessor": "d25096dc-6121-497e-b444-42e92618a871",
                    "xAccessor": "5cb970e1-fff0-4b8c-8c74-7dc834bd2942"
                  }
                ],
                "legend": {
                  "isVisible": true,
                  "position": "right"
                },
                "preferredSeriesType": "bar_stacked",
                "tickLabelsVisibilitySettings": {
                  "x": true,
                  "yLeft": true,
                  "yRight": true
                },
                "valueLabels": "hide",
                "yLeftExtent": {
                  "mode": "full"
                },
                "yRightExtent": {
                  "mode": "full"
                }
              }
            },
            "title": "",
            "type": "lens",
            "visualizationType": "lnsXY"
          },
          "enhancements": {},
          "hidePanelTitles": false
        },
        "title": "Sum of bytes per destination"
      },
      {
        "version": "7.17.0",
        "type": "lens",
        "gridData": {
          "h": 15,
          "i": "fcaf1c3c-64a6-47ce-90a2-8226e788c062",
          "w": 24,
          "x": 24,
          "y": 61
        },
        "panelIndex": "fcaf1c3c-64a6-47ce-90a2-8226e788c062",
        "embeddableConfig": {
          "attributes": {
            "references": [
              {
                "id": "logs-*",
                "name": "indexpattern-datasource-current-indexpattern",
                "type": "index-pattern"
              },
              {
                "id": "logs-*",
                "name": "indexpattern-datasource-layer-8929ffe2-4cf7-40b7-8e2c-1ee52bdd8d97",
                "type": "index-pattern"
              }
            ],
            "state": {
              "datasourceStates": {
                "indexpattern": {
                  "layers": {
                    "8929ffe2-4cf7-40b7-8e2c-1ee52bdd8d97": {
                      "columnOrder": [
                        "06178db9-8ae7-4706-b479-29aea6be4d75",
                        "313bb272-53cc-4d90-890e-d0952e9fd07f",
                        "bbc2b648-d5e5-4ee1-baed-be4d1497e963"
                      ],
                      "columns": {
                        "06178db9-8ae7-4706-b479-29aea6be4d75": {
                          "customLabel": true,
                          "dataType": "string",
                          "isBucketed": true,
                          "label": "Source AS Org",
                          "operationType": "terms",
                          "params": {
                            "missingBucket": true,
                            "orderBy": {
                              "columnId": "bbc2b648-d5e5-4ee1-baed-be4d1497e963",
                              "type": "column"
                            },
                            "orderDirection": "desc",
                            "otherBucket": true,
                            "size": 10
                          },
                          "scale": "ordinal",
                          "sourceField": "source.as.organization.name"
                        },
                        "313bb272-53cc-4d90-890e-d0952e9fd07f": {
                          "customLabel": true,
                          "dataType": "string",
                          "isBucketed": true,
                          "label": "Destination AS Org",
                          "operationType": "terms",
                          "params": {
                            "missingBucket": true,
                            "orderBy": {
                              "columnId": "bbc2b648-d5e5-4ee1-baed-be4d1497e963",
                              "type": "column"
                            },
                            "orderDirection": "desc",
                            "otherBucket": true,
                            "size": 10
                          },
                          "scale": "ordinal",
                          "sourceField": "destination.as.organization.name"
                        },
                        "bbc2b648-d5e5-4ee1-baed-be4d1497e963": {
                          "customLabel": true,
                          "dataType": "number",
                          "isBucketed": false,
                          "label": "Total bytes",
                          "operationType": "sum",
                          "params": {
                            "format": {
                              "id": "bytes",
                              "params": {
                                "decimals": 2
                              }
                            }
                          },
                          "scale": "ratio",
                          "sourceField": "network.bytes"
                        }
                      },
                      "incompleteColumns": {}
                    }
                  }
                }
              },
              "filters": [],
              "query": {
                "language": "kuery",
                "query": ""
              },
              "visualization": {
                "gridConfig": {
                  "isCellLabelVisible": false,
                  "isXAxisLabelVisible": true,
                  "isYAxisLabelVisible": true,
                  "type": "lens_heatmap_grid"
                },
                "layerId": "8929ffe2-4cf7-40b7-8e2c-1ee52bdd8d97",
                "layerType": "data",
                "legend": {
                  "isVisible": false,
                  "maxLines": 2,
                  "position": "right",
                  "shouldTruncate": false,
                  "type": "lens_heatmap_legendConfig"
                },
                "palette": {
                  "accessor": "bbc2b648-d5e5-4ee1-baed-be4d1497e963",
                  "name": "negative",
                  "params": {
                    "name": "negative",
                    "rangeMax": 80,
                    "rangeMin": 0,
                    "reverse": false,
                    "stops": [
                      {
                        "color": "#fbddd6",
                        "stop": 0
                      },
                      {
                        "color": "#f3bbaf",
                        "stop": 20
                      },
                      {
                        "color": "#e99a89",
                        "stop": 40
                      },
                      {
                        "color": "#db7965",
                        "stop": 60
                      },
                      {
                        "color": "#cc5642",
                        "stop": 80
                      }
                    ]
                  },
                  "type": "palette"
                },
                "shape": "heatmap",
                "valueAccessor": "bbc2b648-d5e5-4ee1-baed-be4d1497e963",
                "xAccessor": "313bb272-53cc-4d90-890e-d0952e9fd07f",
                "yAccessor": "06178db9-8ae7-4706-b479-29aea6be4d75"
              }
            },
            "title": "",
            "type": "lens",
            "visualizationType": "lnsHeatmap"
          },
          "enhancements": {},
          "hidePanelTitles": false
        },
        "title": "Sum of bytes between source and destination"
      },
      {
        "version": "7.17.0",
        "type": "visualization",
        "gridData": {
          "h": 15,
          "i": "eedf536b-4b23-4689-957b-482f4d7a3332",
          "w": 24,
          "x": 0,
          "y": 61
        },
        "panelIndex": "eedf536b-4b23-4689-957b-482f4d7a3332",
        "embeddableConfig": {
          "enhancements": {},
          "hidePanelTitles": false,
          "savedVis": {
            "data": {
              "aggs": [],
              "searchSource": {
                "filter": [
                  {
                    "$state": {
                      "store": "appState"
                    },
                    "meta": {
                      "alias": null,
                      "disabled": false,
                      "index": "logs-*",
                      "key": "data_stream.dataset",
                      "negate": false,
                      "params": {
                        "query": "gcp.vpcflow"
                      },
                      "type": "phrase"
                    },
                    "query": {
                      "match_phrase": {
                        "data_stream.dataset": "gcp.vpcflow"
                      }
                    }
                  }
                ],
                "query": {
                  "language": "kuery",
                  "query": ""
                }
              }
            },
            "description": "",
            "params": {
              "spec": "{\r\n  $schema: https://vega.github.io/schema/vega/v3.0.json\r\n  data: [\r\n    {\r\n      // query ES based on the currently selected time range and filter string\r\n      name: rawData\r\n      url: {\r\n        %context%: true\r\n        %timefield%: @timestamp\r\n        index: logs*\r\n        body: {\r\n          size: 0\r\n          aggs: {\r\n            table: {\r\n              composite: {\r\n                size: 10000\r\n                sources: [\r\n                  {\r\n                    stk1: {\r\n                      terms: {field: \"source.as.organization.name\"}\r\n                    }\r\n                  }\r\n                  {\r\n                    stk2: {\r\n                      terms: {field: \"destination.as.organization.name\"}\r\n                    }\r\n                  }\r\n                ]\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // From the result, take just the data we are interested in\r\n      format: {property: \"aggregations.table.buckets\"}\r\n      // Convert key.stk1 -> stk1 for simpler access below\r\n      transform: [\r\n        {type: \"formula\", expr: \"datum.key.stk1\", as: \"stk1\"}\r\n        {type: \"formula\", expr: \"datum.key.stk2\", as: \"stk2\"}\r\n        {type: \"formula\", expr: \"datum.doc_count\", as: \"size\"}\r\n      ]\r\n    }\r\n    {\r\n      name: nodes\r\n      source: rawData\r\n      transform: [\r\n        // when a country is selected, filter out unrelated data\r\n        {\r\n          type: filter\r\n          expr: !groupSelector || groupSelector.stk1 == datum.stk1 || groupSelector.stk2 == datum.stk2\r\n        }\r\n        // Set new key for later lookups - identifies each node\r\n        {type: \"formula\", expr: \"datum.stk1+datum.stk2\", as: \"key\"}\r\n        // instead of each table row, create two new rows,\r\n        // one for the source (stack=stk1) and one for destination node (stack=stk2).\r\n        // The country code stored in stk1 and stk2 fields is placed into grpId field.\r\n        {\r\n          type: fold\r\n          fields: [\"stk1\", \"stk2\"]\r\n          as: [\"stack\", \"grpId\"]\r\n        }\r\n        // Create a sortkey, different for stk1 and stk2 stacks.\r\n        // Space separator ensures proper sort order in some corner cases.\r\n        {\r\n          type: formula\r\n          expr: datum.stack == 'stk1' ? datum.stk1+' '+datum.stk2 : datum.stk2+' '+datum.stk1\r\n          as: sortField\r\n        }\r\n        // Calculate y0 and y1 positions for stacking nodes one on top of the other,\r\n        // independently for each stack, and ensuring they are in the proper order,\r\n        // alphabetical from the top (reversed on the y axis)\r\n        {\r\n          type: stack\r\n          groupby: [\"stack\"]\r\n          sort: {field: \"sortField\", order: \"descending\"}\r\n          field: size\r\n        }\r\n        // calculate vertical center point for each node, used to draw edges\r\n        {type: \"formula\", expr: \"(datum.y0+datum.y1)/2\", as: \"yc\"}\r\n      ]\r\n    }\r\n    {\r\n      name: groups\r\n      source: nodes\r\n      transform: [\r\n        // combine all nodes into country groups, summing up the doc counts\r\n        {\r\n          type: aggregate\r\n          groupby: [\"stack\", \"grpId\"]\r\n          fields: [\"size\"]\r\n          ops: [\"sum\"]\r\n          as: [\"total\"]\r\n        }\r\n        // re-calculate the stacking y0,y1 values\r\n        {\r\n          type: stack\r\n          groupby: [\"stack\"]\r\n          sort: {field: \"grpId\", order: \"descending\"}\r\n          field: total\r\n        }\r\n        // project y0 and y1 values to screen coordinates\r\n        // doing it once here instead of doing it several times in marks\r\n        {type: \"formula\", expr: \"scale('y', datum.y0)\", as: \"scaledY0\"}\r\n        {type: \"formula\", expr: \"scale('y', datum.y1)\", as: \"scaledY1\"}\r\n        // boolean flag if the label should be on the right of the stack\r\n        {type: \"formula\", expr: \"datum.stack == 'stk1'\", as: \"rightLabel\"}\r\n        // Calculate traffic percentage for this country using \"y\" scale\r\n        // domain upper bound, which represents the total traffic\r\n        {\r\n          type: formula\r\n          expr: datum.total/domain('y')[1]\r\n          as: percentage\r\n        }\r\n      ]\r\n    }\r\n    {\r\n      // This is a temp lookup table with all the 'stk2' stack nodes\r\n      name: destinationNodes\r\n      source: nodes\r\n      transform: [\r\n        {type: \"filter\", expr: \"datum.stack == 'stk2'\"}\r\n      ]\r\n    }\r\n    {\r\n      name: edges\r\n      source: nodes\r\n      transform: [\r\n        // we only want nodes from the left stack\r\n        {type: \"filter\", expr: \"datum.stack == 'stk1'\"}\r\n        // find corresponding node from the right stack, keep it as \"target\"\r\n        {\r\n          type: lookup\r\n          from: destinationNodes\r\n          key: key\r\n          fields: [\"key\"]\r\n          as: [\"target\"]\r\n        }\r\n        // calculate SVG link path between stk1 and stk2 stacks for the node pair\r\n        {\r\n          type: linkpath\r\n          orient: horizontal\r\n          shape: diagonal\r\n          sourceY: {expr: \"scale('y', datum.yc)\"}\r\n          sourceX: {expr: \"scale('x', 'stk1') + bandwidth('x')\"}\r\n          targetY: {expr: \"scale('y', datum.target.yc)\"}\r\n          targetX: {expr: \"scale('x', 'stk2')\"}\r\n        }\r\n        // A little trick to calculate the thickness of the line.\r\n        // The value needs to be the same as the hight of the node, but scaling\r\n        // size to screen's height gives inversed value because screen's Y\r\n        // coordinate goes from the top to the bottom, whereas the graph's Y=0\r\n        // is at the bottom. So subtracting scaled doc count from screen height\r\n        // (which is the \"lower\" bound of the \"y\" scale) gives us the right value\r\n        {\r\n          type: formula\r\n          expr: range('y')[0]-scale('y', datum.size)\r\n          as: strokeWidth\r\n        }\r\n        // Tooltip needs individual link's percentage of all traffic\r\n        {\r\n          type: formula\r\n          expr: datum.size/domain('y')[1]\r\n          as: percentage\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n  scales: [\r\n    {\r\n      // calculates horizontal stack positioning\r\n      name: x\r\n      type: band\r\n      range: width\r\n      domain: [\"stk1\", \"stk2\"]\r\n      paddingOuter: 0.05\r\n      paddingInner: 0.95\r\n    }\r\n    {\r\n      // this scale goes up as high as the highest y1 value of all nodes\r\n      name: y\r\n      type: linear\r\n      range: height\r\n      domain: {data: \"nodes\", field: \"y1\"}\r\n    }\r\n    {\r\n      // use rawData to ensure the colors stay the same when clicking.\r\n      name: color\r\n      type: ordinal\r\n      range: category\r\n      domain: {data: \"rawData\", fields: [\"stk1\", \"stk2\"]}\r\n    }\r\n    {\r\n      // this scale is used to map internal ids (stk1, stk2) to stack names\r\n      name: stackNames\r\n      type: ordinal\r\n      range: [\"Source\", \"Destination\"]\r\n      domain: [\"stk1\", \"stk2\"]\r\n    }\r\n  ]\r\n  axes: [\r\n    {\r\n      // x axis should use custom label formatting to print proper stack names\r\n      orient: bottom\r\n      scale: x\r\n      encode: {\r\n        labels: {\r\n          update: {\r\n            text: {scale: \"stackNames\", field: \"value\"}\r\n          }\r\n        }\r\n      }\r\n    }\r\n    {orient: \"left\", scale: \"y\"}\r\n  ]\r\n  marks: [\r\n    {\r\n      // draw the connecting line between stacks\r\n      type: path\r\n      name: edgeMark\r\n      from: {data: \"edges\"}\r\n      // this prevents some autosizing issues with large strokeWidth for paths\r\n      clip: true\r\n      encode: {\r\n        update: {\r\n          // By default use color of the left node, except when showing traffic\r\n          // from just one country, in which case use destination color.\r\n          stroke: [\r\n            {\r\n              test: groupSelector && groupSelector.stack=='stk1'\r\n              scale: color\r\n              field: stk2\r\n            }\r\n            {scale: \"color\", field: \"stk1\"}\r\n          ]\r\n          strokeWidth: {field: \"strokeWidth\"}\r\n          path: {field: \"path\"}\r\n          // when showing all traffic, and hovering over a country,\r\n          // highlight the traffic from that country.\r\n          strokeOpacity: {\r\n            signal: !groupSelector && (groupHover.stk1 == datum.stk1 || groupHover.stk2 == datum.stk2) ? 0.9 : 0.3\r\n          }\r\n          // Ensure that the hover-selected edges show on top\r\n          zindex: {\r\n            signal: !groupSelector && (groupHover.stk1 == datum.stk1 || groupHover.stk2 == datum.stk2) ? 1 : 0\r\n          }\r\n          // format tooltip string\r\n          tooltip: {\r\n            signal: datum.stk1 + ' &#x2192; ' + datum.stk2 + '    ' + format(datum.size, ',.0f') + '   (' + format(datum.percentage, '.1%') + ')'\r\n          }\r\n        }\r\n        // Simple mouseover highlighting of a single line\r\n        hover: {\r\n          strokeOpacity: {value: 1}\r\n        }\r\n      }\r\n    }\r\n    {\r\n      // draw stack groups (countries)\r\n      type: rect\r\n      name: groupMark\r\n      from: {data: \"groups\"}\r\n      encode: {\r\n        enter: {\r\n          fill: {scale: \"color\", field: \"grpId\"}\r\n          width: {scale: \"x\", band: 1}\r\n        }\r\n        update: {\r\n          x: {scale: \"x\", field: \"stack\"}\r\n          y: {field: \"scaledY0\"}\r\n          y2: {field: \"scaledY1\"}\r\n          fillOpacity: {value: 0.6}\r\n          tooltip: {\r\n            signal: datum.grpId + '   ' + format(datum.total, ',.0f') + '   (' + format(datum.percentage, '.1%') + ')'\r\n          }\r\n        }\r\n        hover: {\r\n          fillOpacity: {value: 1}\r\n        }\r\n      }\r\n    }\r\n    {\r\n      // draw country code labels on the inner side of the stack\r\n      type: text\r\n      from: {data: \"groups\"}\r\n      // don't process events for the labels - otherwise line mouseover is unclean\r\n      interactive: false\r\n      encode: {\r\n        update: {\r\n          // depending on which stack it is, position x with some padding\r\n          x: {\r\n            signal: scale('x', datum.stack) + (datum.rightLabel ? bandwidth('x') + 8 : -8)\r\n          }\r\n          // middle of the group\r\n          yc: {signal: \"(datum.scaledY0 + datum.scaledY1)/2\"}\r\n          align: {signal: \"datum.rightLabel ? 'left' : 'right'\"}\r\n          baseline: {value: \"middle\"}\r\n          fontWeight: {value: \"bold\"}\r\n          // only show text label if the group's height is large enough\r\n          text: {signal: \"abs(datum.scaledY0-datum.scaledY1) > 13 ? datum.grpId : ''\"}\r\n        }\r\n      }\r\n    }\r\n    {\r\n      // Create a \"show all\" button. Shown only when a country is selected.\r\n      type: group\r\n      data: [\r\n        // We need to make the button show only when groupSelector signal is true.\r\n        // Each mark is drawn as many times as there are elements in the backing data.\r\n        // Which means that if values list is empty, it will not be drawn.\r\n        // Here I create a data source with one empty object, and filter that list\r\n        // based on the signal value. This can only be done in a group.\r\n        {\r\n          name: dataForShowAll\r\n          values: [{}]\r\n          transform: [{type: \"filter\", expr: \"groupSelector\"}]\r\n        }\r\n      ]\r\n      // Set button size and positioning\r\n      encode: {\r\n        enter: {\r\n          xc: {signal: \"width/2\"}\r\n          y: {value: 30}\r\n          width: {value: 80}\r\n          height: {value: 30}\r\n        }\r\n      }\r\n      marks: [\r\n        {\r\n          // This group is shown as a button with rounded corners.\r\n          type: group\r\n          // mark name allows signal capturing\r\n          name: groupReset\r\n          // Only shows button if dataForShowAll has values.\r\n          from: {data: \"dataForShowAll\"}\r\n          encode: {\r\n            enter: {\r\n              cornerRadius: {value: 6}\r\n              fill: {value: \"#f5f5f5\"}\r\n              stroke: {value: \"#c1c1c1\"}\r\n              strokeWidth: {value: 2}\r\n              // use parent group's size\r\n              height: {\r\n                field: {group: \"height\"}\r\n              }\r\n              width: {\r\n                field: {group: \"width\"}\r\n              }\r\n            }\r\n            update: {\r\n              // groups are transparent by default\r\n              opacity: {value: 1}\r\n            }\r\n            hover: {\r\n              opacity: {value: 0.7}\r\n            }\r\n          }\r\n          marks: [\r\n            {\r\n              type: text\r\n              // if true, it will prevent clicking on the button when over text.\r\n              interactive: false\r\n              encode: {\r\n                enter: {\r\n                  // center text in the paren group\r\n                  xc: {\r\n                    field: {group: \"width\"}\r\n                    mult: 0.5\r\n                  }\r\n                  yc: {\r\n                    field: {group: \"height\"}\r\n                    mult: 0.5\r\n                    offset: 2\r\n                  }\r\n                  align: {value: \"center\"}\r\n                  baseline: {value: \"middle\"}\r\n                  fontWeight: {value: \"bold\"}\r\n                  text: {value: \"Show All\"}\r\n                }\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n  signals: [\r\n    {\r\n      // used to highlight traffic to/from the same country\r\n      name: groupHover\r\n      value: {}\r\n      on: [\r\n        {\r\n          events: @groupMark:mouseover\r\n          update: \"{stk1:datum.stack=='stk1' && datum.grpId, stk2:datum.stack=='stk2' && datum.grpId}\"\r\n        }\r\n        {events: \"mouseout\", update: \"{}\"}\r\n      ]\r\n    }\r\n    // used to filter only the data related to the selected country\r\n    {\r\n      name: groupSelector\r\n      value: false\r\n      on: [\r\n        {\r\n          // Clicking groupMark sets this signal to the filter values\r\n          events: @groupMark:click!\r\n          update: \"{stack:datum.stack, stk1:datum.stack=='stk1' && datum.grpId, stk2:datum.stack=='stk2' && datum.grpId}\"\r\n        }\r\n        {\r\n          // Clicking \"show all\" button, or double-clicking anywhere resets it\r\n          events: [\r\n            {type: \"click\", markname: \"groupReset\"}\r\n            {type: \"dblclick\"}\r\n          ]\r\n          update: \"false\"\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n}"
            },
            "title": "[GCP] Sankey Source to Destination subnetwork",
            "type": "vega",
            "uiState": {}
          }
        },
        "title": "Sankey Source to Destination autonomous system (AS) org name"
      },
      {
        "version": "7.17.0",
        "type": "visualization",
        "gridData": {
          "h": 15,
          "i": "69f30a2e-79ff-4615-a83f-0aaf9b466ba7",
          "w": 24,
          "x": 0,
          "y": 46
        },
        "panelIndex": "69f30a2e-79ff-4615-a83f-0aaf9b466ba7",
        "embeddableConfig": {
          "enhancements": {},
          "hidePanelTitles": false,
          "savedVis": {
            "data": {
              "aggs": [],
              "searchSource": {
                "filter": [
                  {
                    "$state": {
                      "store": "appState"
                    },
                    "meta": {
                      "alias": null,
                      "disabled": false,
                      "index": "logs-*",
                      "key": "data_stream.dataset",
                      "negate": false,
                      "params": {
                        "query": "gcp.vpcflow"
                      },
                      "type": "phrase"
                    },
                    "query": {
                      "match_phrase": {
                        "data_stream.dataset": "gcp.vpcflow"
                      }
                    }
                  }
                ],
                "query": {
                  "language": "kuery",
                  "query": ""
                }
              }
            },
            "description": "",
            "params": {
              "spec": "{\r\n  $schema: https://vega.github.io/schema/vega/v3.0.json\r\n  data: [\r\n    {\r\n      // query ES based on the currently selected time range and filter string\r\n      name: rawData\r\n      url: {\r\n        %context%: true\r\n        %timefield%: @timestamp\r\n        index: logs*\r\n        body: {\r\n          size: 0\r\n          aggs: {\r\n            table: {\r\n              composite: {\r\n                size: 10000\r\n                sources: [\r\n                  {\r\n                    stk1: {\r\n                      terms: {field: \"source.domain\"}\r\n                    }\r\n                  }\r\n                  {\r\n                    stk2: {\r\n                      terms: {field: \"destination.domain\"}\r\n                    }\r\n                  }\r\n                ]\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // From the result, take just the data we are interested in\r\n      format: {property: \"aggregations.table.buckets\"}\r\n      // Convert key.stk1 -> stk1 for simpler access below\r\n      transform: [\r\n        {type: \"formula\", expr: \"datum.key.stk1\", as: \"stk1\"}\r\n        {type: \"formula\", expr: \"datum.key.stk2\", as: \"stk2\"}\r\n        {type: \"formula\", expr: \"datum.doc_count\", as: \"size\"}\r\n      ]\r\n    }\r\n    {\r\n      name: nodes\r\n      source: rawData\r\n      transform: [\r\n        // when a country is selected, filter out unrelated data\r\n        {\r\n          type: filter\r\n          expr: !groupSelector || groupSelector.stk1 == datum.stk1 || groupSelector.stk2 == datum.stk2\r\n        }\r\n        // Set new key for later lookups - identifies each node\r\n        {type: \"formula\", expr: \"datum.stk1+datum.stk2\", as: \"key\"}\r\n        // instead of each table row, create two new rows,\r\n        // one for the source (stack=stk1) and one for destination node (stack=stk2).\r\n        // The country code stored in stk1 and stk2 fields is placed into grpId field.\r\n        {\r\n          type: fold\r\n          fields: [\"stk1\", \"stk2\"]\r\n          as: [\"stack\", \"grpId\"]\r\n        }\r\n        // Create a sortkey, different for stk1 and stk2 stacks.\r\n        // Space separator ensures proper sort order in some corner cases.\r\n        {\r\n          type: formula\r\n          expr: datum.stack == 'stk1' ? datum.stk1+' '+datum.stk2 : datum.stk2+' '+datum.stk1\r\n          as: sortField\r\n        }\r\n        // Calculate y0 and y1 positions for stacking nodes one on top of the other,\r\n        // independently for each stack, and ensuring they are in the proper order,\r\n        // alphabetical from the top (reversed on the y axis)\r\n        {\r\n          type: stack\r\n          groupby: [\"stack\"]\r\n          sort: {field: \"sortField\", order: \"descending\"}\r\n          field: size\r\n        }\r\n        // calculate vertical center point for each node, used to draw edges\r\n        {type: \"formula\", expr: \"(datum.y0+datum.y1)/2\", as: \"yc\"}\r\n      ]\r\n    }\r\n    {\r\n      name: groups\r\n      source: nodes\r\n      transform: [\r\n        // combine all nodes into country groups, summing up the doc counts\r\n        {\r\n          type: aggregate\r\n          groupby: [\"stack\", \"grpId\"]\r\n          fields: [\"size\"]\r\n          ops: [\"sum\"]\r\n          as: [\"total\"]\r\n        }\r\n        // re-calculate the stacking y0,y1 values\r\n        {\r\n          type: stack\r\n          groupby: [\"stack\"]\r\n          sort: {field: \"grpId\", order: \"descending\"}\r\n          field: total\r\n        }\r\n        // project y0 and y1 values to screen coordinates\r\n        // doing it once here instead of doing it several times in marks\r\n        {type: \"formula\", expr: \"scale('y', datum.y0)\", as: \"scaledY0\"}\r\n        {type: \"formula\", expr: \"scale('y', datum.y1)\", as: \"scaledY1\"}\r\n        // boolean flag if the label should be on the right of the stack\r\n        {type: \"formula\", expr: \"datum.stack == 'stk1'\", as: \"rightLabel\"}\r\n        // Calculate traffic percentage for this country using \"y\" scale\r\n        // domain upper bound, which represents the total traffic\r\n        {\r\n          type: formula\r\n          expr: datum.total/domain('y')[1]\r\n          as: percentage\r\n        }\r\n      ]\r\n    }\r\n    {\r\n      // This is a temp lookup table with all the 'stk2' stack nodes\r\n      name: destinationNodes\r\n      source: nodes\r\n      transform: [\r\n        {type: \"filter\", expr: \"datum.stack == 'stk2'\"}\r\n      ]\r\n    }\r\n    {\r\n      name: edges\r\n      source: nodes\r\n      transform: [\r\n        // we only want nodes from the left stack\r\n        {type: \"filter\", expr: \"datum.stack == 'stk1'\"}\r\n        // find corresponding node from the right stack, keep it as \"target\"\r\n        {\r\n          type: lookup\r\n          from: destinationNodes\r\n          key: key\r\n          fields: [\"key\"]\r\n          as: [\"target\"]\r\n        }\r\n        // calculate SVG link path between stk1 and stk2 stacks for the node pair\r\n        {\r\n          type: linkpath\r\n          orient: horizontal\r\n          shape: diagonal\r\n          sourceY: {expr: \"scale('y', datum.yc)\"}\r\n          sourceX: {expr: \"scale('x', 'stk1') + bandwidth('x')\"}\r\n          targetY: {expr: \"scale('y', datum.target.yc)\"}\r\n          targetX: {expr: \"scale('x', 'stk2')\"}\r\n        }\r\n        // A little trick to calculate the thickness of the line.\r\n        // The value needs to be the same as the hight of the node, but scaling\r\n        // size to screen's height gives inversed value because screen's Y\r\n        // coordinate goes from the top to the bottom, whereas the graph's Y=0\r\n        // is at the bottom. So subtracting scaled doc count from screen height\r\n        // (which is the \"lower\" bound of the \"y\" scale) gives us the right value\r\n        {\r\n          type: formula\r\n          expr: range('y')[0]-scale('y', datum.size)\r\n          as: strokeWidth\r\n        }\r\n        // Tooltip needs individual link's percentage of all traffic\r\n        {\r\n          type: formula\r\n          expr: datum.size/domain('y')[1]\r\n          as: percentage\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n  scales: [\r\n    {\r\n      // calculates horizontal stack positioning\r\n      name: x\r\n      type: band\r\n      range: width\r\n      domain: [\"stk1\", \"stk2\"]\r\n      paddingOuter: 0.05\r\n      paddingInner: 0.95\r\n    }\r\n    {\r\n      // this scale goes up as high as the highest y1 value of all nodes\r\n      name: y\r\n      type: linear\r\n      range: height\r\n      domain: {data: \"nodes\", field: \"y1\"}\r\n    }\r\n    {\r\n      // use rawData to ensure the colors stay the same when clicking.\r\n      name: color\r\n      type: ordinal\r\n      range: category\r\n      domain: {data: \"rawData\", fields: [\"stk1\", \"stk2\"]}\r\n    }\r\n    {\r\n      // this scale is used to map internal ids (stk1, stk2) to stack names\r\n      name: stackNames\r\n      type: ordinal\r\n      range: [\"Source\", \"Destination\"]\r\n      domain: [\"stk1\", \"stk2\"]\r\n    }\r\n  ]\r\n  axes: [\r\n    {\r\n      // x axis should use custom label formatting to print proper stack names\r\n      orient: bottom\r\n      scale: x\r\n      encode: {\r\n        labels: {\r\n          update: {\r\n            text: {scale: \"stackNames\", field: \"value\"}\r\n          }\r\n        }\r\n      }\r\n    }\r\n    {orient: \"left\", scale: \"y\"}\r\n  ]\r\n  marks: [\r\n    {\r\n      // draw the connecting line between stacks\r\n      type: path\r\n      name: edgeMark\r\n      from: {data: \"edges\"}\r\n      // this prevents some autosizing issues with large strokeWidth for paths\r\n      clip: true\r\n      encode: {\r\n        update: {\r\n          // By default use color of the left node, except when showing traffic\r\n          // from just one country, in which case use destination color.\r\n          stroke: [\r\n            {\r\n              test: groupSelector && groupSelector.stack=='stk1'\r\n              scale: color\r\n              field: stk2\r\n            }\r\n            {scale: \"color\", field: \"stk1\"}\r\n          ]\r\n          strokeWidth: {field: \"strokeWidth\"}\r\n          path: {field: \"path\"}\r\n          // when showing all traffic, and hovering over a country,\r\n          // highlight the traffic from that country.\r\n          strokeOpacity: {\r\n            signal: !groupSelector && (groupHover.stk1 == datum.stk1 || groupHover.stk2 == datum.stk2) ? 0.9 : 0.3\r\n          }\r\n          // Ensure that the hover-selected edges show on top\r\n          zindex: {\r\n            signal: !groupSelector && (groupHover.stk1 == datum.stk1 || groupHover.stk2 == datum.stk2) ? 1 : 0\r\n          }\r\n          // format tooltip string\r\n          tooltip: {\r\n            signal: datum.stk1 + ' &#x2192; ' + datum.stk2 + '    ' + format(datum.size, ',.0f') + '   (' + format(datum.percentage, '.1%') + ')'\r\n          }\r\n        }\r\n        // Simple mouseover highlighting of a single line\r\n        hover: {\r\n          strokeOpacity: {value: 1}\r\n        }\r\n      }\r\n    }\r\n    {\r\n      // draw stack groups (countries)\r\n      type: rect\r\n      name: groupMark\r\n      from: {data: \"groups\"}\r\n      encode: {\r\n        enter: {\r\n          fill: {scale: \"color\", field: \"grpId\"}\r\n          width: {scale: \"x\", band: 1}\r\n        }\r\n        update: {\r\n          x: {scale: \"x\", field: \"stack\"}\r\n          y: {field: \"scaledY0\"}\r\n          y2: {field: \"scaledY1\"}\r\n          fillOpacity: {value: 0.6}\r\n          tooltip: {\r\n            signal: datum.grpId + '   ' + format(datum.total, ',.0f') + '   (' + format(datum.percentage, '.1%') + ')'\r\n          }\r\n        }\r\n        hover: {\r\n          fillOpacity: {value: 1}\r\n        }\r\n      }\r\n    }\r\n    {\r\n      // draw country code labels on the inner side of the stack\r\n      type: text\r\n      from: {data: \"groups\"}\r\n      // don't process events for the labels - otherwise line mouseover is unclean\r\n      interactive: false\r\n      encode: {\r\n        update: {\r\n          // depending on which stack it is, position x with some padding\r\n          x: {\r\n            signal: scale('x', datum.stack) + (datum.rightLabel ? bandwidth('x') + 8 : -8)\r\n          }\r\n          // middle of the group\r\n          yc: {signal: \"(datum.scaledY0 + datum.scaledY1)/2\"}\r\n          align: {signal: \"datum.rightLabel ? 'left' : 'right'\"}\r\n          baseline: {value: \"middle\"}\r\n          fontWeight: {value: \"bold\"}\r\n          // only show text label if the group's height is large enough\r\n          text: {signal: \"abs(datum.scaledY0-datum.scaledY1) > 13 ? datum.grpId : ''\"}\r\n        }\r\n      }\r\n    }\r\n    {\r\n      // Create a \"show all\" button. Shown only when a country is selected.\r\n      type: group\r\n      data: [\r\n        // We need to make the button show only when groupSelector signal is true.\r\n        // Each mark is drawn as many times as there are elements in the backing data.\r\n        // Which means that if values list is empty, it will not be drawn.\r\n        // Here I create a data source with one empty object, and filter that list\r\n        // based on the signal value. This can only be done in a group.\r\n        {\r\n          name: dataForShowAll\r\n          values: [{}]\r\n          transform: [{type: \"filter\", expr: \"groupSelector\"}]\r\n        }\r\n      ]\r\n      // Set button size and positioning\r\n      encode: {\r\n        enter: {\r\n          xc: {signal: \"width/2\"}\r\n          y: {value: 30}\r\n          width: {value: 80}\r\n          height: {value: 30}\r\n        }\r\n      }\r\n      marks: [\r\n        {\r\n          // This group is shown as a button with rounded corners.\r\n          type: group\r\n          // mark name allows signal capturing\r\n          name: groupReset\r\n          // Only shows button if dataForShowAll has values.\r\n          from: {data: \"dataForShowAll\"}\r\n          encode: {\r\n            enter: {\r\n              cornerRadius: {value: 6}\r\n              fill: {value: \"#f5f5f5\"}\r\n              stroke: {value: \"#c1c1c1\"}\r\n              strokeWidth: {value: 2}\r\n              // use parent group's size\r\n              height: {\r\n                field: {group: \"height\"}\r\n              }\r\n              width: {\r\n                field: {group: \"width\"}\r\n              }\r\n            }\r\n            update: {\r\n              // groups are transparent by default\r\n              opacity: {value: 1}\r\n            }\r\n            hover: {\r\n              opacity: {value: 0.7}\r\n            }\r\n          }\r\n          marks: [\r\n            {\r\n              type: text\r\n              // if true, it will prevent clicking on the button when over text.\r\n              interactive: false\r\n              encode: {\r\n                enter: {\r\n                  // center text in the paren group\r\n                  xc: {\r\n                    field: {group: \"width\"}\r\n                    mult: 0.5\r\n                  }\r\n                  yc: {\r\n                    field: {group: \"height\"}\r\n                    mult: 0.5\r\n                    offset: 2\r\n                  }\r\n                  align: {value: \"center\"}\r\n                  baseline: {value: \"middle\"}\r\n                  fontWeight: {value: \"bold\"}\r\n                  text: {value: \"Show All\"}\r\n                }\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n  signals: [\r\n    {\r\n      // used to highlight traffic to/from the same country\r\n      name: groupHover\r\n      value: {}\r\n      on: [\r\n        {\r\n          events: @groupMark:mouseover\r\n          update: \"{stk1:datum.stack=='stk1' && datum.grpId, stk2:datum.stack=='stk2' && datum.grpId}\"\r\n        }\r\n        {events: \"mouseout\", update: \"{}\"}\r\n      ]\r\n    }\r\n    // used to filter only the data related to the selected country\r\n    {\r\n      name: groupSelector\r\n      value: false\r\n      on: [\r\n        {\r\n          // Clicking groupMark sets this signal to the filter values\r\n          events: @groupMark:click!\r\n          update: \"{stack:datum.stack, stk1:datum.stack=='stk1' && datum.grpId, stk2:datum.stack=='stk2' && datum.grpId}\"\r\n        }\r\n        {\r\n          // Clicking \"show all\" button, or double-clicking anywhere resets it\r\n          events: [\r\n            {type: \"click\", markname: \"groupReset\"}\r\n            {type: \"dblclick\"}\r\n          ]\r\n          update: \"false\"\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n}"
            },
            "title": "[GCP] Sankey Source to Destination domain",
            "type": "vega",
            "uiState": {}
          }
        },
        "title": "Sankey Source to Destination domain"
      },
      {
        "version": "7.17.0",
        "type": "visualization",
        "gridData": {
          "h": 15,
          "i": "0f9ac1ed-f75b-4788-a9fe-9277d5e0551a",
          "w": 24,
          "x": 0,
          "y": 31
        },
        "panelIndex": "0f9ac1ed-f75b-4788-a9fe-9277d5e0551a",
        "embeddableConfig": {
          "enhancements": {},
          "hidePanelTitles": false,
          "savedVis": {
            "data": {
              "aggs": [],
              "searchSource": {
                "filter": [
                  {
                    "$state": {
                      "store": "appState"
                    },
                    "meta": {
                      "alias": null,
                      "disabled": true,
                      "index": "logs-*",
                      "key": "data_stream.dataset",
                      "negate": false,
                      "params": {
                        "query": "gcp.vpcflow"
                      },
                      "type": "phrase"
                    },
                    "query": {
                      "match_phrase": {
                        "data_stream.dataset": "gcp.vpcflow"
                      }
                    }
                  }
                ],
                "query": {
                  "language": "kuery",
                  "query": ""
                }
              }
            },
            "description": "",
            "params": {
              "spec": "{\r\n  $schema: https://vega.github.io/schema/vega/v3.0.json\r\n  data: [\r\n    {\r\n      // query ES based on the currently selected time range and filter string\r\n      name: rawData\r\n      url: {\r\n        %context%: true\r\n        %timefield%: @timestamp\r\n        index: logs*\r\n        body: {\r\n          size: 0\r\n          aggs: {\r\n            table: {\r\n              composite: {\r\n                size: 10000\r\n                sources: [\r\n                  {\r\n                    stk1: {\r\n                      terms: {field: \"gcp.source.vpc.subnetwork_name\"}\r\n                    }\r\n                  }\r\n                  {\r\n                    stk2: {\r\n                      terms: {field: \"gcp.destination.vpc.subnetwork_name\"}\r\n                    }\r\n                  }\r\n                ]\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // From the result, take just the data we are interested in\r\n      format: {property: \"aggregations.table.buckets\"}\r\n      // Convert key.stk1 -> stk1 for simpler access below\r\n      transform: [\r\n        {type: \"formula\", expr: \"datum.key.stk1\", as: \"stk1\"}\r\n        {type: \"formula\", expr: \"datum.key.stk2\", as: \"stk2\"}\r\n        {type: \"formula\", expr: \"datum.doc_count\", as: \"size\"}\r\n      ]\r\n    }\r\n    {\r\n      name: nodes\r\n      source: rawData\r\n      transform: [\r\n        // when a country is selected, filter out unrelated data\r\n        {\r\n          type: filter\r\n          expr: !groupSelector || groupSelector.stk1 == datum.stk1 || groupSelector.stk2 == datum.stk2\r\n        }\r\n        // Set new key for later lookups - identifies each node\r\n        {type: \"formula\", expr: \"datum.stk1+datum.stk2\", as: \"key\"}\r\n        // instead of each table row, create two new rows,\r\n        // one for the source (stack=stk1) and one for destination node (stack=stk2).\r\n        // The country code stored in stk1 and stk2 fields is placed into grpId field.\r\n        {\r\n          type: fold\r\n          fields: [\"stk1\", \"stk2\"]\r\n          as: [\"stack\", \"grpId\"]\r\n        }\r\n        // Create a sortkey, different for stk1 and stk2 stacks.\r\n        // Space separator ensures proper sort order in some corner cases.\r\n        {\r\n          type: formula\r\n          expr: datum.stack == 'stk1' ? datum.stk1+' '+datum.stk2 : datum.stk2+' '+datum.stk1\r\n          as: sortField\r\n        }\r\n        // Calculate y0 and y1 positions for stacking nodes one on top of the other,\r\n        // independently for each stack, and ensuring they are in the proper order,\r\n        // alphabetical from the top (reversed on the y axis)\r\n        {\r\n          type: stack\r\n          groupby: [\"stack\"]\r\n          sort: {field: \"sortField\", order: \"descending\"}\r\n          field: size\r\n        }\r\n        // calculate vertical center point for each node, used to draw edges\r\n        {type: \"formula\", expr: \"(datum.y0+datum.y1)/2\", as: \"yc\"}\r\n      ]\r\n    }\r\n    {\r\n      name: groups\r\n      source: nodes\r\n      transform: [\r\n        // combine all nodes into country groups, summing up the doc counts\r\n        {\r\n          type: aggregate\r\n          groupby: [\"stack\", \"grpId\"]\r\n          fields: [\"size\"]\r\n          ops: [\"sum\"]\r\n          as: [\"total\"]\r\n        }\r\n        // re-calculate the stacking y0,y1 values\r\n        {\r\n          type: stack\r\n          groupby: [\"stack\"]\r\n          sort: {field: \"grpId\", order: \"descending\"}\r\n          field: total\r\n        }\r\n        // project y0 and y1 values to screen coordinates\r\n        // doing it once here instead of doing it several times in marks\r\n        {type: \"formula\", expr: \"scale('y', datum.y0)\", as: \"scaledY0\"}\r\n        {type: \"formula\", expr: \"scale('y', datum.y1)\", as: \"scaledY1\"}\r\n        // boolean flag if the label should be on the right of the stack\r\n        {type: \"formula\", expr: \"datum.stack == 'stk1'\", as: \"rightLabel\"}\r\n        // Calculate traffic percentage for this country using \"y\" scale\r\n        // domain upper bound, which represents the total traffic\r\n        {\r\n          type: formula\r\n          expr: datum.total/domain('y')[1]\r\n          as: percentage\r\n        }\r\n      ]\r\n    }\r\n    {\r\n      // This is a temp lookup table with all the 'stk2' stack nodes\r\n      name: destinationNodes\r\n      source: nodes\r\n      transform: [\r\n        {type: \"filter\", expr: \"datum.stack == 'stk2'\"}\r\n      ]\r\n    }\r\n    {\r\n      name: edges\r\n      source: nodes\r\n      transform: [\r\n        // we only want nodes from the left stack\r\n        {type: \"filter\", expr: \"datum.stack == 'stk1'\"}\r\n        // find corresponding node from the right stack, keep it as \"target\"\r\n        {\r\n          type: lookup\r\n          from: destinationNodes\r\n          key: key\r\n          fields: [\"key\"]\r\n          as: [\"target\"]\r\n        }\r\n        // calculate SVG link path between stk1 and stk2 stacks for the node pair\r\n        {\r\n          type: linkpath\r\n          orient: horizontal\r\n          shape: diagonal\r\n          sourceY: {expr: \"scale('y', datum.yc)\"}\r\n          sourceX: {expr: \"scale('x', 'stk1') + bandwidth('x')\"}\r\n          targetY: {expr: \"scale('y', datum.target.yc)\"}\r\n          targetX: {expr: \"scale('x', 'stk2')\"}\r\n        }\r\n        // A little trick to calculate the thickness of the line.\r\n        // The value needs to be the same as the hight of the node, but scaling\r\n        // size to screen's height gives inversed value because screen's Y\r\n        // coordinate goes from the top to the bottom, whereas the graph's Y=0\r\n        // is at the bottom. So subtracting scaled doc count from screen height\r\n        // (which is the \"lower\" bound of the \"y\" scale) gives us the right value\r\n        {\r\n          type: formula\r\n          expr: range('y')[0]-scale('y', datum.size)\r\n          as: strokeWidth\r\n        }\r\n        // Tooltip needs individual link's percentage of all traffic\r\n        {\r\n          type: formula\r\n          expr: datum.size/domain('y')[1]\r\n          as: percentage\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n  scales: [\r\n    {\r\n      // calculates horizontal stack positioning\r\n      name: x\r\n      type: band\r\n      range: width\r\n      domain: [\"stk1\", \"stk2\"]\r\n      paddingOuter: 0.05\r\n      paddingInner: 0.95\r\n    }\r\n    {\r\n      // this scale goes up as high as the highest y1 value of all nodes\r\n      name: y\r\n      type: linear\r\n      range: height\r\n      domain: {data: \"nodes\", field: \"y1\"}\r\n    }\r\n    {\r\n      // use rawData to ensure the colors stay the same when clicking.\r\n      name: color\r\n      type: ordinal\r\n      range: category\r\n      domain: {data: \"rawData\", fields: [\"stk1\", \"stk2\"]}\r\n    }\r\n    {\r\n      // this scale is used to map internal ids (stk1, stk2) to stack names\r\n      name: stackNames\r\n      type: ordinal\r\n      range: [\"Source\", \"Destination\"]\r\n      domain: [\"stk1\", \"stk2\"]\r\n    }\r\n  ]\r\n  axes: [\r\n    {\r\n      // x axis should use custom label formatting to print proper stack names\r\n      orient: bottom\r\n      scale: x\r\n      encode: {\r\n        labels: {\r\n          update: {\r\n            text: {scale: \"stackNames\", field: \"value\"}\r\n          }\r\n        }\r\n      }\r\n    }\r\n    {orient: \"left\", scale: \"y\"}\r\n  ]\r\n  marks: [\r\n    {\r\n      // draw the connecting line between stacks\r\n      type: path\r\n      name: edgeMark\r\n      from: {data: \"edges\"}\r\n      // this prevents some autosizing issues with large strokeWidth for paths\r\n      clip: true\r\n      encode: {\r\n        update: {\r\n          // By default use color of the left node, except when showing traffic\r\n          // from just one country, in which case use destination color.\r\n          stroke: [\r\n            {\r\n              test: groupSelector && groupSelector.stack=='stk1'\r\n              scale: color\r\n              field: stk2\r\n            }\r\n            {scale: \"color\", field: \"stk1\"}\r\n          ]\r\n          strokeWidth: {field: \"strokeWidth\"}\r\n          path: {field: \"path\"}\r\n          // when showing all traffic, and hovering over a country,\r\n          // highlight the traffic from that country.\r\n          strokeOpacity: {\r\n            signal: !groupSelector && (groupHover.stk1 == datum.stk1 || groupHover.stk2 == datum.stk2) ? 0.9 : 0.3\r\n          }\r\n          // Ensure that the hover-selected edges show on top\r\n          zindex: {\r\n            signal: !groupSelector && (groupHover.stk1 == datum.stk1 || groupHover.stk2 == datum.stk2) ? 1 : 0\r\n          }\r\n          // format tooltip string\r\n          tooltip: {\r\n            signal: datum.stk1 + ' &#x2192; ' + datum.stk2 + '    ' + format(datum.size, ',.0f') + '   (' + format(datum.percentage, '.1%') + ')'\r\n          }\r\n        }\r\n        // Simple mouseover highlighting of a single line\r\n        hover: {\r\n          strokeOpacity: {value: 1}\r\n        }\r\n      }\r\n    }\r\n    {\r\n      // draw stack groups (countries)\r\n      type: rect\r\n      name: groupMark\r\n      from: {data: \"groups\"}\r\n      encode: {\r\n        enter: {\r\n          fill: {scale: \"color\", field: \"grpId\"}\r\n          width: {scale: \"x\", band: 1}\r\n        }\r\n        update: {\r\n          x: {scale: \"x\", field: \"stack\"}\r\n          y: {field: \"scaledY0\"}\r\n          y2: {field: \"scaledY1\"}\r\n          fillOpacity: {value: 0.6}\r\n          tooltip: {\r\n            signal: datum.grpId + '   ' + format(datum.total, ',.0f') + '   (' + format(datum.percentage, '.1%') + ')'\r\n          }\r\n        }\r\n        hover: {\r\n          fillOpacity: {value: 1}\r\n        }\r\n      }\r\n    }\r\n    {\r\n      // draw country code labels on the inner side of the stack\r\n      type: text\r\n      from: {data: \"groups\"}\r\n      // don't process events for the labels - otherwise line mouseover is unclean\r\n      interactive: false\r\n      encode: {\r\n        update: {\r\n          // depending on which stack it is, position x with some padding\r\n          x: {\r\n            signal: scale('x', datum.stack) + (datum.rightLabel ? bandwidth('x') + 8 : -8)\r\n          }\r\n          // middle of the group\r\n          yc: {signal: \"(datum.scaledY0 + datum.scaledY1)/2\"}\r\n          align: {signal: \"datum.rightLabel ? 'left' : 'right'\"}\r\n          baseline: {value: \"middle\"}\r\n          fontWeight: {value: \"bold\"}\r\n          // only show text label if the group's height is large enough\r\n          text: {signal: \"abs(datum.scaledY0-datum.scaledY1) > 13 ? datum.grpId : ''\"}\r\n        }\r\n      }\r\n    }\r\n    {\r\n      // Create a \"show all\" button. Shown only when a country is selected.\r\n      type: group\r\n      data: [\r\n        // We need to make the button show only when groupSelector signal is true.\r\n        // Each mark is drawn as many times as there are elements in the backing data.\r\n        // Which means that if values list is empty, it will not be drawn.\r\n        // Here I create a data source with one empty object, and filter that list\r\n        // based on the signal value. This can only be done in a group.\r\n        {\r\n          name: dataForShowAll\r\n          values: [{}]\r\n          transform: [{type: \"filter\", expr: \"groupSelector\"}]\r\n        }\r\n      ]\r\n      // Set button size and positioning\r\n      encode: {\r\n        enter: {\r\n          xc: {signal: \"width/2\"}\r\n          y: {value: 30}\r\n          width: {value: 80}\r\n          height: {value: 30}\r\n        }\r\n      }\r\n      marks: [\r\n        {\r\n          // This group is shown as a button with rounded corners.\r\n          type: group\r\n          // mark name allows signal capturing\r\n          name: groupReset\r\n          // Only shows button if dataForShowAll has values.\r\n          from: {data: \"dataForShowAll\"}\r\n          encode: {\r\n            enter: {\r\n              cornerRadius: {value: 6}\r\n              fill: {value: \"#f5f5f5\"}\r\n              stroke: {value: \"#c1c1c1\"}\r\n              strokeWidth: {value: 2}\r\n              // use parent group's size\r\n              height: {\r\n                field: {group: \"height\"}\r\n              }\r\n              width: {\r\n                field: {group: \"width\"}\r\n              }\r\n            }\r\n            update: {\r\n              // groups are transparent by default\r\n              opacity: {value: 1}\r\n            }\r\n            hover: {\r\n              opacity: {value: 0.7}\r\n            }\r\n          }\r\n          marks: [\r\n            {\r\n              type: text\r\n              // if true, it will prevent clicking on the button when over text.\r\n              interactive: false\r\n              encode: {\r\n                enter: {\r\n                  // center text in the paren group\r\n                  xc: {\r\n                    field: {group: \"width\"}\r\n                    mult: 0.5\r\n                  }\r\n                  yc: {\r\n                    field: {group: \"height\"}\r\n                    mult: 0.5\r\n                    offset: 2\r\n                  }\r\n                  align: {value: \"center\"}\r\n                  baseline: {value: \"middle\"}\r\n                  fontWeight: {value: \"bold\"}\r\n                  text: {value: \"Show All\"}\r\n                }\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n  signals: [\r\n    {\r\n      // used to highlight traffic to/from the same country\r\n      name: groupHover\r\n      value: {}\r\n      on: [\r\n        {\r\n          events: @groupMark:mouseover\r\n          update: \"{stk1:datum.stack=='stk1' && datum.grpId, stk2:datum.stack=='stk2' && datum.grpId}\"\r\n        }\r\n        {events: \"mouseout\", update: \"{}\"}\r\n      ]\r\n    }\r\n    // used to filter only the data related to the selected country\r\n    {\r\n      name: groupSelector\r\n      value: false\r\n      on: [\r\n        {\r\n          // Clicking groupMark sets this signal to the filter values\r\n          events: @groupMark:click!\r\n          update: \"{stack:datum.stack, stk1:datum.stack=='stk1' && datum.grpId, stk2:datum.stack=='stk2' && datum.grpId}\"\r\n        }\r\n        {\r\n          // Clicking \"show all\" button, or double-clicking anywhere resets it\r\n          events: [\r\n            {type: \"click\", markname: \"groupReset\"}\r\n            {type: \"dblclick\"}\r\n          ]\r\n          update: \"false\"\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n}"
            },
            "title": "[GCP] Sankey Source to Destination subnetwork",
            "type": "vega",
            "uiState": {}
          }
        },
        "title": "Sankey Source to Destination subnetwork"
      },
      {
        "version": "7.17.0",
        "type": "visualization",
        "gridData": {
          "h": 15,
          "i": "4a23ce96-6f3b-4ae0-bec2-dc1594cedef6",
          "w": 24,
          "x": 24,
          "y": 31
        },
        "panelIndex": "4a23ce96-6f3b-4ae0-bec2-dc1594cedef6",
        "embeddableConfig": {
          "enhancements": {},
          "hidePanelTitles": false,
          "savedVis": {
            "data": {
              "aggs": [],
              "searchSource": {
                "filter": [
                  {
                    "$state": {
                      "store": "appState"
                    },
                    "meta": {
                      "alias": null,
                      "disabled": false,
                      "index": "logs-*",
                      "key": "data_stream.dataset",
                      "negate": false,
                      "params": {
                        "query": "gcp.vpcflow"
                      },
                      "type": "phrase"
                    },
                    "query": {
                      "match_phrase": {
                        "data_stream.dataset": "gcp.vpcflow"
                      }
                    }
                  }
                ],
                "query": {
                  "language": "kuery",
                  "query": ""
                }
              }
            },
            "description": "",
            "params": {
              "spec": "{\r\n  $schema: https://vega.github.io/schema/vega/v3.0.json\r\n  data: [\r\n    {\r\n      // query ES based on the currently selected time range and filter string\r\n      name: rawData\r\n      url: {\r\n        %context%: true\r\n        %timefield%: @timestamp\r\n        index: logs*\r\n        body: {\r\n          size: 0\r\n          aggs: {\r\n            table: {\r\n              composite: {\r\n                size: 10000\r\n                sources: [\r\n                  {\r\n                    stk1: {\r\n                      terms: {field: \"gcp.source.vpc.vpc_name\"}\r\n                    }\r\n                  }\r\n                  {\r\n                    stk2: {\r\n                      terms: {field: \"gcp.destination.vpc.vpc_name\"}\r\n                    }\r\n                  }\r\n                ]\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // From the result, take just the data we are interested in\r\n      format: {property: \"aggregations.table.buckets\"}\r\n      // Convert key.stk1 -> stk1 for simpler access below\r\n      transform: [\r\n        {type: \"formula\", expr: \"datum.key.stk1\", as: \"stk1\"}\r\n        {type: \"formula\", expr: \"datum.key.stk2\", as: \"stk2\"}\r\n        {type: \"formula\", expr: \"datum.doc_count\", as: \"size\"}\r\n      ]\r\n    }\r\n    {\r\n      name: nodes\r\n      source: rawData\r\n      transform: [\r\n        // when a country is selected, filter out unrelated data\r\n        {\r\n          type: filter\r\n          expr: !groupSelector || groupSelector.stk1 == datum.stk1 || groupSelector.stk2 == datum.stk2\r\n        }\r\n        // Set new key for later lookups - identifies each node\r\n        {type: \"formula\", expr: \"datum.stk1+datum.stk2\", as: \"key\"}\r\n        // instead of each table row, create two new rows,\r\n        // one for the source (stack=stk1) and one for destination node (stack=stk2).\r\n        // The country code stored in stk1 and stk2 fields is placed into grpId field.\r\n        {\r\n          type: fold\r\n          fields: [\"stk1\", \"stk2\"]\r\n          as: [\"stack\", \"grpId\"]\r\n        }\r\n        // Create a sortkey, different for stk1 and stk2 stacks.\r\n        // Space separator ensures proper sort order in some corner cases.\r\n        {\r\n          type: formula\r\n          expr: datum.stack == 'stk1' ? datum.stk1+' '+datum.stk2 : datum.stk2+' '+datum.stk1\r\n          as: sortField\r\n        }\r\n        // Calculate y0 and y1 positions for stacking nodes one on top of the other,\r\n        // independently for each stack, and ensuring they are in the proper order,\r\n        // alphabetical from the top (reversed on the y axis)\r\n        {\r\n          type: stack\r\n          groupby: [\"stack\"]\r\n          sort: {field: \"sortField\", order: \"descending\"}\r\n          field: size\r\n        }\r\n        // calculate vertical center point for each node, used to draw edges\r\n        {type: \"formula\", expr: \"(datum.y0+datum.y1)/2\", as: \"yc\"}\r\n      ]\r\n    }\r\n    {\r\n      name: groups\r\n      source: nodes\r\n      transform: [\r\n        // combine all nodes into country groups, summing up the doc counts\r\n        {\r\n          type: aggregate\r\n          groupby: [\"stack\", \"grpId\"]\r\n          fields: [\"size\"]\r\n          ops: [\"sum\"]\r\n          as: [\"total\"]\r\n        }\r\n        // re-calculate the stacking y0,y1 values\r\n        {\r\n          type: stack\r\n          groupby: [\"stack\"]\r\n          sort: {field: \"grpId\", order: \"descending\"}\r\n          field: total\r\n        }\r\n        // project y0 and y1 values to screen coordinates\r\n        // doing it once here instead of doing it several times in marks\r\n        {type: \"formula\", expr: \"scale('y', datum.y0)\", as: \"scaledY0\"}\r\n        {type: \"formula\", expr: \"scale('y', datum.y1)\", as: \"scaledY1\"}\r\n        // boolean flag if the label should be on the right of the stack\r\n        {type: \"formula\", expr: \"datum.stack == 'stk1'\", as: \"rightLabel\"}\r\n        // Calculate traffic percentage for this country using \"y\" scale\r\n        // domain upper bound, which represents the total traffic\r\n        {\r\n          type: formula\r\n          expr: datum.total/domain('y')[1]\r\n          as: percentage\r\n        }\r\n      ]\r\n    }\r\n    {\r\n      // This is a temp lookup table with all the 'stk2' stack nodes\r\n      name: destinationNodes\r\n      source: nodes\r\n      transform: [\r\n        {type: \"filter\", expr: \"datum.stack == 'stk2'\"}\r\n      ]\r\n    }\r\n    {\r\n      name: edges\r\n      source: nodes\r\n      transform: [\r\n        // we only want nodes from the left stack\r\n        {type: \"filter\", expr: \"datum.stack == 'stk1'\"}\r\n        // find corresponding node from the right stack, keep it as \"target\"\r\n        {\r\n          type: lookup\r\n          from: destinationNodes\r\n          key: key\r\n          fields: [\"key\"]\r\n          as: [\"target\"]\r\n        }\r\n        // calculate SVG link path between stk1 and stk2 stacks for the node pair\r\n        {\r\n          type: linkpath\r\n          orient: horizontal\r\n          shape: diagonal\r\n          sourceY: {expr: \"scale('y', datum.yc)\"}\r\n          sourceX: {expr: \"scale('x', 'stk1') + bandwidth('x')\"}\r\n          targetY: {expr: \"scale('y', datum.target.yc)\"}\r\n          targetX: {expr: \"scale('x', 'stk2')\"}\r\n        }\r\n        // A little trick to calculate the thickness of the line.\r\n        // The value needs to be the same as the hight of the node, but scaling\r\n        // size to screen's height gives inversed value because screen's Y\r\n        // coordinate goes from the top to the bottom, whereas the graph's Y=0\r\n        // is at the bottom. So subtracting scaled doc count from screen height\r\n        // (which is the \"lower\" bound of the \"y\" scale) gives us the right value\r\n        {\r\n          type: formula\r\n          expr: range('y')[0]-scale('y', datum.size)\r\n          as: strokeWidth\r\n        }\r\n        // Tooltip needs individual link's percentage of all traffic\r\n        {\r\n          type: formula\r\n          expr: datum.size/domain('y')[1]\r\n          as: percentage\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n  scales: [\r\n    {\r\n      // calculates horizontal stack positioning\r\n      name: x\r\n      type: band\r\n      range: width\r\n      domain: [\"stk1\", \"stk2\"]\r\n      paddingOuter: 0.05\r\n      paddingInner: 0.95\r\n    }\r\n    {\r\n      // this scale goes up as high as the highest y1 value of all nodes\r\n      name: y\r\n      type: linear\r\n      range: height\r\n      domain: {data: \"nodes\", field: \"y1\"}\r\n    }\r\n    {\r\n      // use rawData to ensure the colors stay the same when clicking.\r\n      name: color\r\n      type: ordinal\r\n      range: category\r\n      domain: {data: \"rawData\", fields: [\"stk1\", \"stk2\"]}\r\n    }\r\n    {\r\n      // this scale is used to map internal ids (stk1, stk2) to stack names\r\n      name: stackNames\r\n      type: ordinal\r\n      range: [\"Source\", \"Destination\"]\r\n      domain: [\"stk1\", \"stk2\"]\r\n    }\r\n  ]\r\n  axes: [\r\n    {\r\n      // x axis should use custom label formatting to print proper stack names\r\n      orient: bottom\r\n      scale: x\r\n      encode: {\r\n        labels: {\r\n          update: {\r\n            text: {scale: \"stackNames\", field: \"value\"}\r\n          }\r\n        }\r\n      }\r\n    }\r\n    {orient: \"left\", scale: \"y\"}\r\n  ]\r\n  marks: [\r\n    {\r\n      // draw the connecting line between stacks\r\n      type: path\r\n      name: edgeMark\r\n      from: {data: \"edges\"}\r\n      // this prevents some autosizing issues with large strokeWidth for paths\r\n      clip: true\r\n      encode: {\r\n        update: {\r\n          // By default use color of the left node, except when showing traffic\r\n          // from just one country, in which case use destination color.\r\n          stroke: [\r\n            {\r\n              test: groupSelector && groupSelector.stack=='stk1'\r\n              scale: color\r\n              field: stk2\r\n            }\r\n            {scale: \"color\", field: \"stk1\"}\r\n          ]\r\n          strokeWidth: {field: \"strokeWidth\"}\r\n          path: {field: \"path\"}\r\n          // when showing all traffic, and hovering over a country,\r\n          // highlight the traffic from that country.\r\n          strokeOpacity: {\r\n            signal: !groupSelector && (groupHover.stk1 == datum.stk1 || groupHover.stk2 == datum.stk2) ? 0.9 : 0.3\r\n          }\r\n          // Ensure that the hover-selected edges show on top\r\n          zindex: {\r\n            signal: !groupSelector && (groupHover.stk1 == datum.stk1 || groupHover.stk2 == datum.stk2) ? 1 : 0\r\n          }\r\n          // format tooltip string\r\n          tooltip: {\r\n            signal: datum.stk1 + ' &#x2192; ' + datum.stk2 + '    ' + format(datum.size, ',.0f') + '   (' + format(datum.percentage, '.1%') + ')'\r\n          }\r\n        }\r\n        // Simple mouseover highlighting of a single line\r\n        hover: {\r\n          strokeOpacity: {value: 1}\r\n        }\r\n      }\r\n    }\r\n    {\r\n      // draw stack groups (countries)\r\n      type: rect\r\n      name: groupMark\r\n      from: {data: \"groups\"}\r\n      encode: {\r\n        enter: {\r\n          fill: {scale: \"color\", field: \"grpId\"}\r\n          width: {scale: \"x\", band: 1}\r\n        }\r\n        update: {\r\n          x: {scale: \"x\", field: \"stack\"}\r\n          y: {field: \"scaledY0\"}\r\n          y2: {field: \"scaledY1\"}\r\n          fillOpacity: {value: 0.6}\r\n          tooltip: {\r\n            signal: datum.grpId + '   ' + format(datum.total, ',.0f') + '   (' + format(datum.percentage, '.1%') + ')'\r\n          }\r\n        }\r\n        hover: {\r\n          fillOpacity: {value: 1}\r\n        }\r\n      }\r\n    }\r\n    {\r\n      // draw country code labels on the inner side of the stack\r\n      type: text\r\n      from: {data: \"groups\"}\r\n      // don't process events for the labels - otherwise line mouseover is unclean\r\n      interactive: false\r\n      encode: {\r\n        update: {\r\n          // depending on which stack it is, position x with some padding\r\n          x: {\r\n            signal: scale('x', datum.stack) + (datum.rightLabel ? bandwidth('x') + 8 : -8)\r\n          }\r\n          // middle of the group\r\n          yc: {signal: \"(datum.scaledY0 + datum.scaledY1)/2\"}\r\n          align: {signal: \"datum.rightLabel ? 'left' : 'right'\"}\r\n          baseline: {value: \"middle\"}\r\n          fontWeight: {value: \"bold\"}\r\n          // only show text label if the group's height is large enough\r\n          text: {signal: \"abs(datum.scaledY0-datum.scaledY1) > 13 ? datum.grpId : ''\"}\r\n        }\r\n      }\r\n    }\r\n    {\r\n      // Create a \"show all\" button. Shown only when a country is selected.\r\n      type: group\r\n      data: [\r\n        // We need to make the button show only when groupSelector signal is true.\r\n        // Each mark is drawn as many times as there are elements in the backing data.\r\n        // Which means that if values list is empty, it will not be drawn.\r\n        // Here I create a data source with one empty object, and filter that list\r\n        // based on the signal value. This can only be done in a group.\r\n        {\r\n          name: dataForShowAll\r\n          values: [{}]\r\n          transform: [{type: \"filter\", expr: \"groupSelector\"}]\r\n        }\r\n      ]\r\n      // Set button size and positioning\r\n      encode: {\r\n        enter: {\r\n          xc: {signal: \"width/2\"}\r\n          y: {value: 30}\r\n          width: {value: 80}\r\n          height: {value: 30}\r\n        }\r\n      }\r\n      marks: [\r\n        {\r\n          // This group is shown as a button with rounded corners.\r\n          type: group\r\n          // mark name allows signal capturing\r\n          name: groupReset\r\n          // Only shows button if dataForShowAll has values.\r\n          from: {data: \"dataForShowAll\"}\r\n          encode: {\r\n            enter: {\r\n              cornerRadius: {value: 6}\r\n              fill: {value: \"#f5f5f5\"}\r\n              stroke: {value: \"#c1c1c1\"}\r\n              strokeWidth: {value: 2}\r\n              // use parent group's size\r\n              height: {\r\n                field: {group: \"height\"}\r\n              }\r\n              width: {\r\n                field: {group: \"width\"}\r\n              }\r\n            }\r\n            update: {\r\n              // groups are transparent by default\r\n              opacity: {value: 1}\r\n            }\r\n            hover: {\r\n              opacity: {value: 0.7}\r\n            }\r\n          }\r\n          marks: [\r\n            {\r\n              type: text\r\n              // if true, it will prevent clicking on the button when over text.\r\n              interactive: false\r\n              encode: {\r\n                enter: {\r\n                  // center text in the paren group\r\n                  xc: {\r\n                    field: {group: \"width\"}\r\n                    mult: 0.5\r\n                  }\r\n                  yc: {\r\n                    field: {group: \"height\"}\r\n                    mult: 0.5\r\n                    offset: 2\r\n                  }\r\n                  align: {value: \"center\"}\r\n                  baseline: {value: \"middle\"}\r\n                  fontWeight: {value: \"bold\"}\r\n                  text: {value: \"Show All\"}\r\n                }\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n  signals: [\r\n    {\r\n      // used to highlight traffic to/from the same country\r\n      name: groupHover\r\n      value: {}\r\n      on: [\r\n        {\r\n          events: @groupMark:mouseover\r\n          update: \"{stk1:datum.stack=='stk1' && datum.grpId, stk2:datum.stack=='stk2' && datum.grpId}\"\r\n        }\r\n        {events: \"mouseout\", update: \"{}\"}\r\n      ]\r\n    }\r\n    // used to filter only the data related to the selected country\r\n    {\r\n      name: groupSelector\r\n      value: false\r\n      on: [\r\n        {\r\n          // Clicking groupMark sets this signal to the filter values\r\n          events: @groupMark:click!\r\n          update: \"{stack:datum.stack, stk1:datum.stack=='stk1' && datum.grpId, stk2:datum.stack=='stk2' && datum.grpId}\"\r\n        }\r\n        {\r\n          // Clicking \"show all\" button, or double-clicking anywhere resets it\r\n          events: [\r\n            {type: \"click\", markname: \"groupReset\"}\r\n            {type: \"dblclick\"}\r\n          ]\r\n          update: \"false\"\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n}"
            },
            "title": "[GCP] Sankey Source to Destination VPC",
            "type": "vega",
            "uiState": {}
          }
        },
        "title": "Sankey Source to Destination VPC"
      },
      {
        "version": "7.17.0",
        "type": "visualization",
        "gridData": {
          "h": 15,
          "i": "8700819e-d34e-4ac8-8b65-e053db64f7b8",
          "w": 24,
          "x": 0,
          "y": 16
        },
        "panelIndex": "8700819e-d34e-4ac8-8b65-e053db64f7b8",
        "embeddableConfig": {
          "enhancements": {},
          "hidePanelTitles": false,
          "savedVis": {
            "data": {
              "aggs": [],
              "searchSource": {
                "filter": [
                  {
                    "$state": {
                      "store": "appState"
                    },
                    "meta": {
                      "alias": null,
                      "disabled": false,
                      "index": "logs-*",
                      "key": "data_stream.dataset",
                      "negate": false,
                      "params": {
                        "query": "gcp.vpcflow"
                      },
                      "type": "phrase"
                    },
                    "query": {
                      "match_phrase": {
                        "data_stream.dataset": "gcp.vpcflow"
                      }
                    }
                  }
                ],
                "query": {
                  "language": "kuery",
                  "query": ""
                }
              }
            },
            "description": "",
            "params": {
              "spec": "{\r\n  $schema: https://vega.github.io/schema/vega/v3.0.json\r\n  data: [\r\n    {\r\n      // query ES based on the currently selected time range and filter string\r\n      name: rawData\r\n      url: {\r\n        %context%: true\r\n        %timefield%: @timestamp\r\n        index: logs*\r\n        body: {\r\n          size: 0\r\n          aggs: {\r\n            table: {\r\n              composite: {\r\n                size: 10000\r\n                sources: [\r\n                  {\r\n                    stk1: {\r\n                      terms: {field: \"source.geo.country_iso_code\"}\r\n                    }\r\n                  }\r\n                  {\r\n                    stk2: {\r\n                      terms: {field: \"destination.geo.country_iso_code\"}\r\n                    }\r\n                  }\r\n                ]\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // From the result, take just the data we are interested in\r\n      format: {property: \"aggregations.table.buckets\"}\r\n      // Convert key.stk1 -> stk1 for simpler access below\r\n      transform: [\r\n        {type: \"formula\", expr: \"datum.key.stk1\", as: \"stk1\"}\r\n        {type: \"formula\", expr: \"datum.key.stk2\", as: \"stk2\"}\r\n        {type: \"formula\", expr: \"datum.doc_count\", as: \"size\"}\r\n      ]\r\n    }\r\n    {\r\n      name: nodes\r\n      source: rawData\r\n      transform: [\r\n        // when a country is selected, filter out unrelated data\r\n        {\r\n          type: filter\r\n          expr: !groupSelector || groupSelector.stk1 == datum.stk1 || groupSelector.stk2 == datum.stk2\r\n        }\r\n        // Set new key for later lookups - identifies each node\r\n        {type: \"formula\", expr: \"datum.stk1+datum.stk2\", as: \"key\"}\r\n        // instead of each table row, create two new rows,\r\n        // one for the source (stack=stk1) and one for destination node (stack=stk2).\r\n        // The country code stored in stk1 and stk2 fields is placed into grpId field.\r\n        {\r\n          type: fold\r\n          fields: [\"stk1\", \"stk2\"]\r\n          as: [\"stack\", \"grpId\"]\r\n        }\r\n        // Create a sortkey, different for stk1 and stk2 stacks.\r\n        // Space separator ensures proper sort order in some corner cases.\r\n        {\r\n          type: formula\r\n          expr: datum.stack == 'stk1' ? datum.stk1+' '+datum.stk2 : datum.stk2+' '+datum.stk1\r\n          as: sortField\r\n        }\r\n        // Calculate y0 and y1 positions for stacking nodes one on top of the other,\r\n        // independently for each stack, and ensuring they are in the proper order,\r\n        // alphabetical from the top (reversed on the y axis)\r\n        {\r\n          type: stack\r\n          groupby: [\"stack\"]\r\n          sort: {field: \"sortField\", order: \"descending\"}\r\n          field: size\r\n        }\r\n        // calculate vertical center point for each node, used to draw edges\r\n        {type: \"formula\", expr: \"(datum.y0+datum.y1)/2\", as: \"yc\"}\r\n      ]\r\n    }\r\n    {\r\n      name: groups\r\n      source: nodes\r\n      transform: [\r\n        // combine all nodes into country groups, summing up the doc counts\r\n        {\r\n          type: aggregate\r\n          groupby: [\"stack\", \"grpId\"]\r\n          fields: [\"size\"]\r\n          ops: [\"sum\"]\r\n          as: [\"total\"]\r\n        }\r\n        // re-calculate the stacking y0,y1 values\r\n        {\r\n          type: stack\r\n          groupby: [\"stack\"]\r\n          sort: {field: \"grpId\", order: \"descending\"}\r\n          field: total\r\n        }\r\n        // project y0 and y1 values to screen coordinates\r\n        // doing it once here instead of doing it several times in marks\r\n        {type: \"formula\", expr: \"scale('y', datum.y0)\", as: \"scaledY0\"}\r\n        {type: \"formula\", expr: \"scale('y', datum.y1)\", as: \"scaledY1\"}\r\n        // boolean flag if the label should be on the right of the stack\r\n        {type: \"formula\", expr: \"datum.stack == 'stk1'\", as: \"rightLabel\"}\r\n        // Calculate traffic percentage for this country using \"y\" scale\r\n        // domain upper bound, which represents the total traffic\r\n        {\r\n          type: formula\r\n          expr: datum.total/domain('y')[1]\r\n          as: percentage\r\n        }\r\n      ]\r\n    }\r\n    {\r\n      // This is a temp lookup table with all the 'stk2' stack nodes\r\n      name: destinationNodes\r\n      source: nodes\r\n      transform: [\r\n        {type: \"filter\", expr: \"datum.stack == 'stk2'\"}\r\n      ]\r\n    }\r\n    {\r\n      name: edges\r\n      source: nodes\r\n      transform: [\r\n        // we only want nodes from the left stack\r\n        {type: \"filter\", expr: \"datum.stack == 'stk1'\"}\r\n        // find corresponding node from the right stack, keep it as \"target\"\r\n        {\r\n          type: lookup\r\n          from: destinationNodes\r\n          key: key\r\n          fields: [\"key\"]\r\n          as: [\"target\"]\r\n        }\r\n        // calculate SVG link path between stk1 and stk2 stacks for the node pair\r\n        {\r\n          type: linkpath\r\n          orient: horizontal\r\n          shape: diagonal\r\n          sourceY: {expr: \"scale('y', datum.yc)\"}\r\n          sourceX: {expr: \"scale('x', 'stk1') + bandwidth('x')\"}\r\n          targetY: {expr: \"scale('y', datum.target.yc)\"}\r\n          targetX: {expr: \"scale('x', 'stk2')\"}\r\n        }\r\n        // A little trick to calculate the thickness of the line.\r\n        // The value needs to be the same as the hight of the node, but scaling\r\n        // size to screen's height gives inversed value because screen's Y\r\n        // coordinate goes from the top to the bottom, whereas the graph's Y=0\r\n        // is at the bottom. So subtracting scaled doc count from screen height\r\n        // (which is the \"lower\" bound of the \"y\" scale) gives us the right value\r\n        {\r\n          type: formula\r\n          expr: range('y')[0]-scale('y', datum.size)\r\n          as: strokeWidth\r\n        }\r\n        // Tooltip needs individual link's percentage of all traffic\r\n        {\r\n          type: formula\r\n          expr: datum.size/domain('y')[1]\r\n          as: percentage\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n  scales: [\r\n    {\r\n      // calculates horizontal stack positioning\r\n      name: x\r\n      type: band\r\n      range: width\r\n      domain: [\"stk1\", \"stk2\"]\r\n      paddingOuter: 0.05\r\n      paddingInner: 0.95\r\n    }\r\n    {\r\n      // this scale goes up as high as the highest y1 value of all nodes\r\n      name: y\r\n      type: linear\r\n      range: height\r\n      domain: {data: \"nodes\", field: \"y1\"}\r\n    }\r\n    {\r\n      // use rawData to ensure the colors stay the same when clicking.\r\n      name: color\r\n      type: ordinal\r\n      range: category\r\n      domain: {data: \"rawData\", fields: [\"stk1\", \"stk2\"]}\r\n    }\r\n    {\r\n      // this scale is used to map internal ids (stk1, stk2) to stack names\r\n      name: stackNames\r\n      type: ordinal\r\n      range: [\"Source\", \"Destination\"]\r\n      domain: [\"stk1\", \"stk2\"]\r\n    }\r\n  ]\r\n  axes: [\r\n    {\r\n      // x axis should use custom label formatting to print proper stack names\r\n      orient: bottom\r\n      scale: x\r\n      encode: {\r\n        labels: {\r\n          update: {\r\n            text: {scale: \"stackNames\", field: \"value\"}\r\n          }\r\n        }\r\n      }\r\n    }\r\n    {orient: \"left\", scale: \"y\"}\r\n  ]\r\n  marks: [\r\n    {\r\n      // draw the connecting line between stacks\r\n      type: path\r\n      name: edgeMark\r\n      from: {data: \"edges\"}\r\n      // this prevents some autosizing issues with large strokeWidth for paths\r\n      clip: true\r\n      encode: {\r\n        update: {\r\n          // By default use color of the left node, except when showing traffic\r\n          // from just one country, in which case use destination color.\r\n          stroke: [\r\n            {\r\n              test: groupSelector && groupSelector.stack=='stk1'\r\n              scale: color\r\n              field: stk2\r\n            }\r\n            {scale: \"color\", field: \"stk1\"}\r\n          ]\r\n          strokeWidth: {field: \"strokeWidth\"}\r\n          path: {field: \"path\"}\r\n          // when showing all traffic, and hovering over a country,\r\n          // highlight the traffic from that country.\r\n          strokeOpacity: {\r\n            signal: !groupSelector && (groupHover.stk1 == datum.stk1 || groupHover.stk2 == datum.stk2) ? 0.9 : 0.3\r\n          }\r\n          // Ensure that the hover-selected edges show on top\r\n          zindex: {\r\n            signal: !groupSelector && (groupHover.stk1 == datum.stk1 || groupHover.stk2 == datum.stk2) ? 1 : 0\r\n          }\r\n          // format tooltip string\r\n          tooltip: {\r\n            signal: datum.stk1 + ' &#x2192; ' + datum.stk2 + '    ' + format(datum.size, ',.0f') + '   (' + format(datum.percentage, '.1%') + ')'\r\n          }\r\n        }\r\n        // Simple mouseover highlighting of a single line\r\n        hover: {\r\n          strokeOpacity: {value: 1}\r\n        }\r\n      }\r\n    }\r\n    {\r\n      // draw stack groups (countries)\r\n      type: rect\r\n      name: groupMark\r\n      from: {data: \"groups\"}\r\n      encode: {\r\n        enter: {\r\n          fill: {scale: \"color\", field: \"grpId\"}\r\n          width: {scale: \"x\", band: 1}\r\n        }\r\n        update: {\r\n          x: {scale: \"x\", field: \"stack\"}\r\n          y: {field: \"scaledY0\"}\r\n          y2: {field: \"scaledY1\"}\r\n          fillOpacity: {value: 0.6}\r\n          tooltip: {\r\n            signal: datum.grpId + '   ' + format(datum.total, ',.0f') + '   (' + format(datum.percentage, '.1%') + ')'\r\n          }\r\n        }\r\n        hover: {\r\n          fillOpacity: {value: 1}\r\n        }\r\n      }\r\n    }\r\n    {\r\n      // draw country code labels on the inner side of the stack\r\n      type: text\r\n      from: {data: \"groups\"}\r\n      // don't process events for the labels - otherwise line mouseover is unclean\r\n      interactive: false\r\n      encode: {\r\n        update: {\r\n          // depending on which stack it is, position x with some padding\r\n          x: {\r\n            signal: scale('x', datum.stack) + (datum.rightLabel ? bandwidth('x') + 8 : -8)\r\n          }\r\n          // middle of the group\r\n          yc: {signal: \"(datum.scaledY0 + datum.scaledY1)/2\"}\r\n          align: {signal: \"datum.rightLabel ? 'left' : 'right'\"}\r\n          baseline: {value: \"middle\"}\r\n          fontWeight: {value: \"bold\"}\r\n          // only show text label if the group's height is large enough\r\n          text: {signal: \"abs(datum.scaledY0-datum.scaledY1) > 13 ? datum.grpId : ''\"}\r\n        }\r\n      }\r\n    }\r\n    {\r\n      // Create a \"show all\" button. Shown only when a country is selected.\r\n      type: group\r\n      data: [\r\n        // We need to make the button show only when groupSelector signal is true.\r\n        // Each mark is drawn as many times as there are elements in the backing data.\r\n        // Which means that if values list is empty, it will not be drawn.\r\n        // Here I create a data source with one empty object, and filter that list\r\n        // based on the signal value. This can only be done in a group.\r\n        {\r\n          name: dataForShowAll\r\n          values: [{}]\r\n          transform: [{type: \"filter\", expr: \"groupSelector\"}]\r\n        }\r\n      ]\r\n      // Set button size and positioning\r\n      encode: {\r\n        enter: {\r\n          xc: {signal: \"width/2\"}\r\n          y: {value: 30}\r\n          width: {value: 80}\r\n          height: {value: 30}\r\n        }\r\n      }\r\n      marks: [\r\n        {\r\n          // This group is shown as a button with rounded corners.\r\n          type: group\r\n          // mark name allows signal capturing\r\n          name: groupReset\r\n          // Only shows button if dataForShowAll has values.\r\n          from: {data: \"dataForShowAll\"}\r\n          encode: {\r\n            enter: {\r\n              cornerRadius: {value: 6}\r\n              fill: {value: \"#f5f5f5\"}\r\n              stroke: {value: \"#c1c1c1\"}\r\n              strokeWidth: {value: 2}\r\n              // use parent group's size\r\n              height: {\r\n                field: {group: \"height\"}\r\n              }\r\n              width: {\r\n                field: {group: \"width\"}\r\n              }\r\n            }\r\n            update: {\r\n              // groups are transparent by default\r\n              opacity: {value: 1}\r\n            }\r\n            hover: {\r\n              opacity: {value: 0.7}\r\n            }\r\n          }\r\n          marks: [\r\n            {\r\n              type: text\r\n              // if true, it will prevent clicking on the button when over text.\r\n              interactive: false\r\n              encode: {\r\n                enter: {\r\n                  // center text in the paren group\r\n                  xc: {\r\n                    field: {group: \"width\"}\r\n                    mult: 0.5\r\n                  }\r\n                  yc: {\r\n                    field: {group: \"height\"}\r\n                    mult: 0.5\r\n                    offset: 2\r\n                  }\r\n                  align: {value: \"center\"}\r\n                  baseline: {value: \"middle\"}\r\n                  fontWeight: {value: \"bold\"}\r\n                  text: {value: \"Show All\"}\r\n                }\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n  signals: [\r\n    {\r\n      // used to highlight traffic to/from the same country\r\n      name: groupHover\r\n      value: {}\r\n      on: [\r\n        {\r\n          events: @groupMark:mouseover\r\n          update: \"{stk1:datum.stack=='stk1' && datum.grpId, stk2:datum.stack=='stk2' && datum.grpId}\"\r\n        }\r\n        {events: \"mouseout\", update: \"{}\"}\r\n      ]\r\n    }\r\n    // used to filter only the data related to the selected country\r\n    {\r\n      name: groupSelector\r\n      value: false\r\n      on: [\r\n        {\r\n          // Clicking groupMark sets this signal to the filter values\r\n          events: @groupMark:click!\r\n          update: \"{stack:datum.stack, stk1:datum.stack=='stk1' && datum.grpId, stk2:datum.stack=='stk2' && datum.grpId}\"\r\n        }\r\n        {\r\n          // Clicking \"show all\" button, or double-clicking anywhere resets it\r\n          events: [\r\n            {type: \"click\", markname: \"groupReset\"}\r\n            {type: \"dblclick\"}\r\n          ]\r\n          update: \"false\"\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n}"
            },
            "title": "[GCP] Sankey Source to Destination country",
            "type": "vega",
            "uiState": {}
          }
        },
        "title": "Sankey Source to Destination country"
      },
      {
        "version": "7.17.0",
        "type": "visualization",
        "gridData": {
          "h": 15,
          "i": "6d32c209-a24d-4bf4-8651-83a187ed7946",
          "w": 24,
          "x": 24,
          "y": 16
        },
        "panelIndex": "6d32c209-a24d-4bf4-8651-83a187ed7946",
        "embeddableConfig": {
          "enhancements": {},
          "hidePanelTitles": false,
          "savedVis": {
            "data": {
              "aggs": [],
              "searchSource": {
                "filter": [
                  {
                    "$state": {
                      "store": "appState"
                    },
                    "meta": {
                      "alias": null,
                      "disabled": true,
                      "index": "logs-*",
                      "key": "data_stream.dataset",
                      "negate": false,
                      "params": {
                        "query": "gcp.vpcflow"
                      },
                      "type": "phrase"
                    },
                    "query": {
                      "match_phrase": {
                        "data_stream.dataset": "gcp.vpcflow"
                      }
                    }
                  }
                ],
                "query": {
                  "language": "kuery",
                  "query": ""
                }
              }
            },
            "description": "",
            "params": {
              "spec": "{\r\n  $schema: https://vega.github.io/schema/vega/v3.0.json\r\n  data: [\r\n    {\r\n      // query ES based on the currently selected time range and filter string\r\n      name: rawData\r\n      url: {\r\n        %context%: true\r\n        %timefield%: @timestamp\r\n        index: logs*\r\n        body: {\r\n          size: 0\r\n          aggs: {\r\n            table: {\r\n              composite: {\r\n                size: 10000\r\n                sources: [\r\n                  {\r\n                    stk1: {\r\n                      terms: {field: \"gcp.source.vpc.project_id\"}\r\n                    }\r\n                  }\r\n                  {\r\n                    stk2: {\r\n                      terms: {field: \"gcp.destination.vpc.project_id\"}\r\n                    }\r\n                  }\r\n                ]\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // From the result, take just the data we are interested in\r\n      format: {property: \"aggregations.table.buckets\"}\r\n      // Convert key.stk1 -> stk1 for simpler access below\r\n      transform: [\r\n        {type: \"formula\", expr: \"datum.key.stk1\", as: \"stk1\"}\r\n        {type: \"formula\", expr: \"datum.key.stk2\", as: \"stk2\"}\r\n        {type: \"formula\", expr: \"datum.doc_count\", as: \"size\"}\r\n      ]\r\n    }\r\n    {\r\n      name: nodes\r\n      source: rawData\r\n      transform: [\r\n        // when a country is selected, filter out unrelated data\r\n        {\r\n          type: filter\r\n          expr: !groupSelector || groupSelector.stk1 == datum.stk1 || groupSelector.stk2 == datum.stk2\r\n        }\r\n        // Set new key for later lookups - identifies each node\r\n        {type: \"formula\", expr: \"datum.stk1+datum.stk2\", as: \"key\"}\r\n        // instead of each table row, create two new rows,\r\n        // one for the source (stack=stk1) and one for destination node (stack=stk2).\r\n        // The country code stored in stk1 and stk2 fields is placed into grpId field.\r\n        {\r\n          type: fold\r\n          fields: [\"stk1\", \"stk2\"]\r\n          as: [\"stack\", \"grpId\"]\r\n        }\r\n        // Create a sortkey, different for stk1 and stk2 stacks.\r\n        // Space separator ensures proper sort order in some corner cases.\r\n        {\r\n          type: formula\r\n          expr: datum.stack == 'stk1' ? datum.stk1+' '+datum.stk2 : datum.stk2+' '+datum.stk1\r\n          as: sortField\r\n        }\r\n        // Calculate y0 and y1 positions for stacking nodes one on top of the other,\r\n        // independently for each stack, and ensuring they are in the proper order,\r\n        // alphabetical from the top (reversed on the y axis)\r\n        {\r\n          type: stack\r\n          groupby: [\"stack\"]\r\n          sort: {field: \"sortField\", order: \"descending\"}\r\n          field: size\r\n        }\r\n        // calculate vertical center point for each node, used to draw edges\r\n        {type: \"formula\", expr: \"(datum.y0+datum.y1)/2\", as: \"yc\"}\r\n      ]\r\n    }\r\n    {\r\n      name: groups\r\n      source: nodes\r\n      transform: [\r\n        // combine all nodes into country groups, summing up the doc counts\r\n        {\r\n          type: aggregate\r\n          groupby: [\"stack\", \"grpId\"]\r\n          fields: [\"size\"]\r\n          ops: [\"sum\"]\r\n          as: [\"total\"]\r\n        }\r\n        // re-calculate the stacking y0,y1 values\r\n        {\r\n          type: stack\r\n          groupby: [\"stack\"]\r\n          sort: {field: \"grpId\", order: \"descending\"}\r\n          field: total\r\n        }\r\n        // project y0 and y1 values to screen coordinates\r\n        // doing it once here instead of doing it several times in marks\r\n        {type: \"formula\", expr: \"scale('y', datum.y0)\", as: \"scaledY0\"}\r\n        {type: \"formula\", expr: \"scale('y', datum.y1)\", as: \"scaledY1\"}\r\n        // boolean flag if the label should be on the right of the stack\r\n        {type: \"formula\", expr: \"datum.stack == 'stk1'\", as: \"rightLabel\"}\r\n        // Calculate traffic percentage for this country using \"y\" scale\r\n        // domain upper bound, which represents the total traffic\r\n        {\r\n          type: formula\r\n          expr: datum.total/domain('y')[1]\r\n          as: percentage\r\n        }\r\n      ]\r\n    }\r\n    {\r\n      // This is a temp lookup table with all the 'stk2' stack nodes\r\n      name: destinationNodes\r\n      source: nodes\r\n      transform: [\r\n        {type: \"filter\", expr: \"datum.stack == 'stk2'\"}\r\n      ]\r\n    }\r\n    {\r\n      name: edges\r\n      source: nodes\r\n      transform: [\r\n        // we only want nodes from the left stack\r\n        {type: \"filter\", expr: \"datum.stack == 'stk1'\"}\r\n        // find corresponding node from the right stack, keep it as \"target\"\r\n        {\r\n          type: lookup\r\n          from: destinationNodes\r\n          key: key\r\n          fields: [\"key\"]\r\n          as: [\"target\"]\r\n        }\r\n        // calculate SVG link path between stk1 and stk2 stacks for the node pair\r\n        {\r\n          type: linkpath\r\n          orient: horizontal\r\n          shape: diagonal\r\n          sourceY: {expr: \"scale('y', datum.yc)\"}\r\n          sourceX: {expr: \"scale('x', 'stk1') + bandwidth('x')\"}\r\n          targetY: {expr: \"scale('y', datum.target.yc)\"}\r\n          targetX: {expr: \"scale('x', 'stk2')\"}\r\n        }\r\n        // A little trick to calculate the thickness of the line.\r\n        // The value needs to be the same as the hight of the node, but scaling\r\n        // size to screen's height gives inversed value because screen's Y\r\n        // coordinate goes from the top to the bottom, whereas the graph's Y=0\r\n        // is at the bottom. So subtracting scaled doc count from screen height\r\n        // (which is the \"lower\" bound of the \"y\" scale) gives us the right value\r\n        {\r\n          type: formula\r\n          expr: range('y')[0]-scale('y', datum.size)\r\n          as: strokeWidth\r\n        }\r\n        // Tooltip needs individual link's percentage of all traffic\r\n        {\r\n          type: formula\r\n          expr: datum.size/domain('y')[1]\r\n          as: percentage\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n  scales: [\r\n    {\r\n      // calculates horizontal stack positioning\r\n      name: x\r\n      type: band\r\n      range: width\r\n      domain: [\"stk1\", \"stk2\"]\r\n      paddingOuter: 0.05\r\n      paddingInner: 0.95\r\n    }\r\n    {\r\n      // this scale goes up as high as the highest y1 value of all nodes\r\n      name: y\r\n      type: linear\r\n      range: height\r\n      domain: {data: \"nodes\", field: \"y1\"}\r\n    }\r\n    {\r\n      // use rawData to ensure the colors stay the same when clicking.\r\n      name: color\r\n      type: ordinal\r\n      range: category\r\n      domain: {data: \"rawData\", fields: [\"stk1\", \"stk2\"]}\r\n    }\r\n    {\r\n      // this scale is used to map internal ids (stk1, stk2) to stack names\r\n      name: stackNames\r\n      type: ordinal\r\n      range: [\"Source\", \"Destination\"]\r\n      domain: [\"stk1\", \"stk2\"]\r\n    }\r\n  ]\r\n  axes: [\r\n    {\r\n      // x axis should use custom label formatting to print proper stack names\r\n      orient: bottom\r\n      scale: x\r\n      encode: {\r\n        labels: {\r\n          update: {\r\n            text: {scale: \"stackNames\", field: \"value\"}\r\n          }\r\n        }\r\n      }\r\n    }\r\n    {orient: \"left\", scale: \"y\"}\r\n  ]\r\n  marks: [\r\n    {\r\n      // draw the connecting line between stacks\r\n      type: path\r\n      name: edgeMark\r\n      from: {data: \"edges\"}\r\n      // this prevents some autosizing issues with large strokeWidth for paths\r\n      clip: true\r\n      encode: {\r\n        update: {\r\n          // By default use color of the left node, except when showing traffic\r\n          // from just one country, in which case use destination color.\r\n          stroke: [\r\n            {\r\n              test: groupSelector && groupSelector.stack=='stk1'\r\n              scale: color\r\n              field: stk2\r\n            }\r\n            {scale: \"color\", field: \"stk1\"}\r\n          ]\r\n          strokeWidth: {field: \"strokeWidth\"}\r\n          path: {field: \"path\"}\r\n          // when showing all traffic, and hovering over a country,\r\n          // highlight the traffic from that country.\r\n          strokeOpacity: {\r\n            signal: !groupSelector && (groupHover.stk1 == datum.stk1 || groupHover.stk2 == datum.stk2) ? 0.9 : 0.3\r\n          }\r\n          // Ensure that the hover-selected edges show on top\r\n          zindex: {\r\n            signal: !groupSelector && (groupHover.stk1 == datum.stk1 || groupHover.stk2 == datum.stk2) ? 1 : 0\r\n          }\r\n          // format tooltip string\r\n          tooltip: {\r\n            signal: datum.stk1 + ' &#x2192; ' + datum.stk2 + '    ' + format(datum.size, ',.0f') + '   (' + format(datum.percentage, '.1%') + ')'\r\n          }\r\n        }\r\n        // Simple mouseover highlighting of a single line\r\n        hover: {\r\n          strokeOpacity: {value: 1}\r\n        }\r\n      }\r\n    }\r\n    {\r\n      // draw stack groups (countries)\r\n      type: rect\r\n      name: groupMark\r\n      from: {data: \"groups\"}\r\n      encode: {\r\n        enter: {\r\n          fill: {scale: \"color\", field: \"grpId\"}\r\n          width: {scale: \"x\", band: 1}\r\n        }\r\n        update: {\r\n          x: {scale: \"x\", field: \"stack\"}\r\n          y: {field: \"scaledY0\"}\r\n          y2: {field: \"scaledY1\"}\r\n          fillOpacity: {value: 0.6}\r\n          tooltip: {\r\n            signal: datum.grpId + '   ' + format(datum.total, ',.0f') + '   (' + format(datum.percentage, '.1%') + ')'\r\n          }\r\n        }\r\n        hover: {\r\n          fillOpacity: {value: 1}\r\n        }\r\n      }\r\n    }\r\n    {\r\n      // draw country code labels on the inner side of the stack\r\n      type: text\r\n      from: {data: \"groups\"}\r\n      // don't process events for the labels - otherwise line mouseover is unclean\r\n      interactive: false\r\n      encode: {\r\n        update: {\r\n          // depending on which stack it is, position x with some padding\r\n          x: {\r\n            signal: scale('x', datum.stack) + (datum.rightLabel ? bandwidth('x') + 8 : -8)\r\n          }\r\n          // middle of the group\r\n          yc: {signal: \"(datum.scaledY0 + datum.scaledY1)/2\"}\r\n          align: {signal: \"datum.rightLabel ? 'left' : 'right'\"}\r\n          baseline: {value: \"middle\"}\r\n          fontWeight: {value: \"bold\"}\r\n          // only show text label if the group's height is large enough\r\n          text: {signal: \"abs(datum.scaledY0-datum.scaledY1) > 13 ? datum.grpId : ''\"}\r\n        }\r\n      }\r\n    }\r\n    {\r\n      // Create a \"show all\" button. Shown only when a country is selected.\r\n      type: group\r\n      data: [\r\n        // We need to make the button show only when groupSelector signal is true.\r\n        // Each mark is drawn as many times as there are elements in the backing data.\r\n        // Which means that if values list is empty, it will not be drawn.\r\n        // Here I create a data source with one empty object, and filter that list\r\n        // based on the signal value. This can only be done in a group.\r\n        {\r\n          name: dataForShowAll\r\n          values: [{}]\r\n          transform: [{type: \"filter\", expr: \"groupSelector\"}]\r\n        }\r\n      ]\r\n      // Set button size and positioning\r\n      encode: {\r\n        enter: {\r\n          xc: {signal: \"width/2\"}\r\n          y: {value: 30}\r\n          width: {value: 80}\r\n          height: {value: 30}\r\n        }\r\n      }\r\n      marks: [\r\n        {\r\n          // This group is shown as a button with rounded corners.\r\n          type: group\r\n          // mark name allows signal capturing\r\n          name: groupReset\r\n          // Only shows button if dataForShowAll has values.\r\n          from: {data: \"dataForShowAll\"}\r\n          encode: {\r\n            enter: {\r\n              cornerRadius: {value: 6}\r\n              fill: {value: \"#f5f5f5\"}\r\n              stroke: {value: \"#c1c1c1\"}\r\n              strokeWidth: {value: 2}\r\n              // use parent group's size\r\n              height: {\r\n                field: {group: \"height\"}\r\n              }\r\n              width: {\r\n                field: {group: \"width\"}\r\n              }\r\n            }\r\n            update: {\r\n              // groups are transparent by default\r\n              opacity: {value: 1}\r\n            }\r\n            hover: {\r\n              opacity: {value: 0.7}\r\n            }\r\n          }\r\n          marks: [\r\n            {\r\n              type: text\r\n              // if true, it will prevent clicking on the button when over text.\r\n              interactive: false\r\n              encode: {\r\n                enter: {\r\n                  // center text in the paren group\r\n                  xc: {\r\n                    field: {group: \"width\"}\r\n                    mult: 0.5\r\n                  }\r\n                  yc: {\r\n                    field: {group: \"height\"}\r\n                    mult: 0.5\r\n                    offset: 2\r\n                  }\r\n                  align: {value: \"center\"}\r\n                  baseline: {value: \"middle\"}\r\n                  fontWeight: {value: \"bold\"}\r\n                  text: {value: \"Show All\"}\r\n                }\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n  signals: [\r\n    {\r\n      // used to highlight traffic to/from the same country\r\n      name: groupHover\r\n      value: {}\r\n      on: [\r\n        {\r\n          events: @groupMark:mouseover\r\n          update: \"{stk1:datum.stack=='stk1' && datum.grpId, stk2:datum.stack=='stk2' && datum.grpId}\"\r\n        }\r\n        {events: \"mouseout\", update: \"{}\"}\r\n      ]\r\n    }\r\n    // used to filter only the data related to the selected country\r\n    {\r\n      name: groupSelector\r\n      value: false\r\n      on: [\r\n        {\r\n          // Clicking groupMark sets this signal to the filter values\r\n          events: @groupMark:click!\r\n          update: \"{stack:datum.stack, stk1:datum.stack=='stk1' && datum.grpId, stk2:datum.stack=='stk2' && datum.grpId}\"\r\n        }\r\n        {\r\n          // Clicking \"show all\" button, or double-clicking anywhere resets it\r\n          events: [\r\n            {type: \"click\", markname: \"groupReset\"}\r\n            {type: \"dblclick\"}\r\n          ]\r\n          update: \"false\"\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n}"
            },
            "title": "[GCP] Sankey Source to Destination project",
            "type": "vega",
            "uiState": {}
          }
        },
        "title": "Sankey Source to Destination project"
      },
      {
        "version": "7.17.0",
        "type": "visualization",
        "gridData": {
          "h": 5,
          "i": "f3e1d305-2615-45a8-a2a9-ced28af362d1",
          "w": 8,
          "x": 40,
          "y": 0
        },
        "panelIndex": "f3e1d305-2615-45a8-a2a9-ced28af362d1",
        "embeddableConfig": {
          "enhancements": {},
          "hidePanelTitles": true,
          "savedVis": {
            "data": {
              "aggs": [],
              "searchSource": {
                "filter": [],
                "query": {
                  "language": "kuery",
                  "query": ""
                }
              }
            },
            "description": "",
            "params": {
              "axis_formatter": "number",
              "axis_position": "left",
              "axis_scale": "normal",
              "drop_last_bucket": 1,
              "id": "61ca57f0-469d-11e7-af02-69e470af7417",
              "index_pattern": "",
              "interval": "",
              "isModelInvalid": false,
              "markdown": "[Detection Engine](security/detections)\r\n\r\n[Network overview](security/network/flows)",
              "markdown_css": "#markdown-61ca57f0-469d-11e7-af02-69e470af7417 a{background-color:#07C;color:#fff;padding:8px 12px;height:40px;display:inline-block;font-family:Inter UI,-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;font-weight:400;letter-spacing:-0.005em;font-size:1rem;line-height:1.5;text-decoration:none;border-radius:4px;vertical-align:middle;width:100%;text-align:center}",
              "markdown_less": "a {\n    background-color: #07C;\n    color: #fff;\n    padding: 8px 12px;\n    height: 40px;\n    display: inline-block;\n    font-family: Inter UI,-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;\n    font-weight: 400;\n    letter-spacing: -.005em;\n    font-size: 1rem;\n    line-height: 1.5;\n    text-decoration: none;\n    border-radius: 4px;\n    vertical-align: middle;\n    width: 100%;\n    text-align: center;\n}",
              "markdown_openLinksInNewTab": 1,
              "markdown_vertical_align": "middle",
              "max_lines_legend": 1,
              "series": [
                {
                  "axis_position": "right",
                  "chart_type": "line",
                  "color": "#68BC00",
                  "fill": 0.5,
                  "formatter": "number",
                  "id": "61ca57f1-469d-11e7-af02-69e470af7417",
                  "line_width": 1,
                  "metrics": [
                    {
                      "id": "61ca57f2-469d-11e7-af02-69e470af7417",
                      "type": "count"
                    }
                  ],
                  "palette": {
                    "name": "default",
                    "type": "palette"
                  },
                  "point_size": 1,
                  "separate_axis": 0,
                  "split_mode": "everything",
                  "stacked": "none",
                  "time_range_mode": "entire_time_range"
                }
              ],
              "show_grid": 1,
              "show_legend": 1,
              "time_field": "",
              "time_range_mode": "entire_time_range",
              "tooltip_mode": "show_all",
              "truncate_legend": 1,
              "type": "markdown",
              "use_kibana_indexes": true
            },
            "title": "Nav Buttons",
            "type": "metrics",
            "uiState": {}
          }
        }
      }
    ],
    "timeRestore": false,
    "title": "[Logs GCP] VPC Flow",
    "version": 1
  },
  "references": [
    {
      "id": "logs-*",
      "name": "kibanaSavedObjectMeta.searchSourceJSON.filter[0].meta.index",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "fd65090b-d291-4771-865d-c5fa77a1b2a2:indexpattern-datasource-current-indexpattern",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "fd65090b-d291-4771-865d-c5fa77a1b2a2:indexpattern-datasource-layer-9622b1fb-f543-4d05-b868-366fa865f9e7",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "4489b109-a7f8-4a9d-b85f-0fe613368eda:indexpattern-datasource-current-indexpattern",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "4489b109-a7f8-4a9d-b85f-0fe613368eda:indexpattern-datasource-layer-9622b1fb-f543-4d05-b868-366fa865f9e7",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "061ff6b2-a70a-42dc-87fd-45d185b277ac:indexpattern-datasource-current-indexpattern",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "061ff6b2-a70a-42dc-87fd-45d185b277ac:indexpattern-datasource-layer-9622b1fb-f543-4d05-b868-366fa865f9e7",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "42eee1cd-e816-4f6e-a700-401e8ff1a2f5:indexpattern-datasource-current-indexpattern",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "42eee1cd-e816-4f6e-a700-401e8ff1a2f5:indexpattern-datasource-layer-9622b1fb-f543-4d05-b868-366fa865f9e7",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "9714edf3-3894-4567-b8ec-99b863f4fa74:indexpattern-datasource-current-indexpattern",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "9714edf3-3894-4567-b8ec-99b863f4fa74:indexpattern-datasource-layer-9622b1fb-f543-4d05-b868-366fa865f9e7",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "efe8857e-d137-4c24-ad83-dd7ddbea8c9e:indexpattern-datasource-current-indexpattern",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "efe8857e-d137-4c24-ad83-dd7ddbea8c9e:indexpattern-datasource-layer-9622b1fb-f543-4d05-b868-366fa865f9e7",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "289e8233-5d54-49c7-9b3a-30bab73711bb:indexpattern-datasource-current-indexpattern",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "289e8233-5d54-49c7-9b3a-30bab73711bb:indexpattern-datasource-layer-102a3f02-3222-48bb-8c57-b29990ae1d97",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "9d413864-ae26-4e79-a93d-df49fbad4913:indexpattern-datasource-current-indexpattern",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "9d413864-ae26-4e79-a93d-df49fbad4913:indexpattern-datasource-layer-102a3f02-3222-48bb-8c57-b29990ae1d97",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "fcaf1c3c-64a6-47ce-90a2-8226e788c062:indexpattern-datasource-current-indexpattern",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "fcaf1c3c-64a6-47ce-90a2-8226e788c062:indexpattern-datasource-layer-8929ffe2-4cf7-40b7-8e2c-1ee52bdd8d97",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "eedf536b-4b23-4689-957b-482f4d7a3332:kibanaSavedObjectMeta.searchSourceJSON.filter[0].meta.index",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "69f30a2e-79ff-4615-a83f-0aaf9b466ba7:kibanaSavedObjectMeta.searchSourceJSON.filter[0].meta.index",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "0f9ac1ed-f75b-4788-a9fe-9277d5e0551a:kibanaSavedObjectMeta.searchSourceJSON.filter[0].meta.index",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "4a23ce96-6f3b-4ae0-bec2-dc1594cedef6:kibanaSavedObjectMeta.searchSourceJSON.filter[0].meta.index",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "8700819e-d34e-4ac8-8b65-e053db64f7b8:kibanaSavedObjectMeta.searchSourceJSON.filter[0].meta.index",
      "type": "index-pattern"
    },
    {
      "id": "logs-*",
      "name": "6d32c209-a24d-4bf4-8651-83a187ed7946:kibanaSavedObjectMeta.searchSourceJSON.filter[0].meta.index",
      "type": "index-pattern"
    },
    {
      "id": "gcp-e1a359e5-543d-44c2-ab81-628138719e28",
      "name": "tag-gcp-e1a359e5-543d-44c2-ab81-628138719e28",
      "type": "tag"
    }
  ],
  "migrationVersion": {
    "dashboard": "7.17.3"
  },
  "coreMigrationVersion": "7.17.6"
}