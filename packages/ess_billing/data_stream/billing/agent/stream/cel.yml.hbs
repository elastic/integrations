config_version: 2
interval: "24h"
{{#if enable_request_tracer}}
resource.tracer.filename: "/run/service_logs/http-request-trace-*.ndjson"
resource.tracer.maxbackups: 5
{{/if}}
{{#if proxy_url}}
resource.proxy_url: {{proxy_url}}
{{/if}}
{{#if ssl}}
resource.ssl: {{ssl}}
{{/if}}
{{#if http_client_timeout}}
resource.timeout: {{http_client_timeout}}
{{/if}}
resource.url: "{{url}}/api/v2/billing/organizations/{{organization_id}}/costs/instances"
state:
  api_key: !!str {{api_key}}
  organization_id: !!str {{organization_id}}
  lookbehind: !!int {{lookbehind}}
  add_tags: !!bool {{add_tags}}
  dep_search_url: !!str {{dep_search_url}}
redact:
  fields:
    - api_key
program: |-
  (state.add_tags) ?
    request(
      "POST",
      state.dep_search_url
    ).with(
      {
        "Header": {
          "Authorization": ["ApiKey " + state.api_key],
          "Content-Type": ["application/json"]
        },
        "Body": {
          "query": {
            "bool": {
              "filter": [
                {
                  "nested": {
                    "path": "resources.elasticsearch",
                    "query": { "exists": { "field": "resources.elasticsearch.id" } }
                  }
                },
                {
                  "nested": {
                    "path": "resources.elasticsearch",
                    "query": { "match": { "resources.elasticsearch.info.settings.metadata.organization_id": { "query": state.organization_id } } }
                  }
                }
              ]
            }
          },
          "size": 100
        }.encode_json()
      }
    ).do_request().as(deployments_resp, (deployments_resp.StatusCode == 200) ?
      bytes(deployments_resp.Body).decode_json().as(deployments_body,
        zip(
          deployments_body.deployments.map(d,
            d.resources.elasticsearch[0].id
          ),
          deployments_body.deployments.map(d, d.metadata.collate("tags"))
        )
      ).as(tags,
        state.with(
          state.?cursor.last_to.optMap(ts, timestamp(ts)).orValue(
            now - duration(string(int(state.lookbehind) * 24) + "h")
          ).format(
            time_layout.DateOnly
          ).parse_time(time_layout.DateOnly).as(from,
            max(from, timestamp("2021-01-01T00:00:00Z"))
          ).as(from,
            {
              "from": from,
              "to": from + duration("24h"),
            }
          ).as(req, (req.to > now) ?
            {
              "events": [],
              "cursor": { "last_to": req.to },
              "want_more": false,
            }
          :
            get_request(
              state.url + "?" + {
                "from": [req.from.format(time_layout.RFC3339)],
                "to": [req.to.format(time_layout.RFC3339)],
              }.format_query()
            ).with(
              { "Header": { "Authorization": ["ApiKey " + state.api_key] } }
            ).do_request().as(resp, (resp.StatusCode == 200) ?
              bytes(resp.Body).decode_json().as(body, (has(body.instances) && size(body.instances) > 0) ?
                {
                  "events": body.instances.map(instance,
                    instance.product_line_items.map(line_item,
                      {
                        "ess": {
                          "billing": line_item.with(
                            {
                              "deployment_name": instance.name,
                              "deployment_id": instance.id,
                              "deployment_type": instance.type,
                              "deployment_tags": tags[?instance.id].orValue([]).map(t,
                                t.key + ":" + t.value
                              ),
                              "organization_id": state.organization_id,
                              "from": req.from.format(time_layout.RFC3339),
                              "to": req.to.format(time_layout.RFC3339),
                              "quantities": null
                            }
                          ),
                        },
                      }
                    )
                  ).flatten(),
                  "cursor": { "last_to": req.to },
                  "want_more": req.to < now - duration("24h"),
                }
              :
                {
                  "events": [ { "fake": true } ],
                  "cursor": { "last_to": req.to },
                  "want_more": req.to < now - duration("24h"),
                }
              )
            :
              {
                "events": { "error": { "code": string(resp.StatusCode), "id": string(resp.Status), "message": "GET " + resp.Request.URL + ": " + ( (size(resp.Body) != 0) ? string(resp.Body) : string(resp.Status) + " (" + string(resp.StatusCode) + ")" ) } },
                "want_more": false,
              }
            )
          )
        )
      )
    :
      {
        "events": { "error": { "code": string(deployments_resp.StatusCode), "id": string(deployments_resp.Status), "message": "POST " + deployments_resp.Request.URL + ": " + ( (size(deployments_resp.Body) != 0) ? string(deployments_resp.Body) : string(deployments_resp.Status) + " (" + string(deployments_resp.StatusCode) + ")" ) } },
        "want_more": false,
      }
    )
  :
    state.with(
      state.?cursor.last_to.optMap(ts, timestamp(ts)).orValue(
        now - duration(string(int(state.lookbehind) * 24) + "h")
      ).format(
        time_layout.DateOnly
      ).parse_time(time_layout.DateOnly).as(from,
        max(from, timestamp("2021-01-01T00:00:00Z"))
      ).as(from,
        {
          "from": from,
          "to": from + duration("24h"),
        }
      ).as(req, (req.to > now) ?
        {
          "events": [],
          "cursor": {
            "last_to": req.to,
          },
          "want_more": false,
        }
      :
        get_request(
          state.url + "?" + {
            "from": [req.from.format(time_layout.RFC3339)],
            "to": [req.to.format(time_layout.RFC3339)],
          }.format_query()
        ).with(
          {
            "Header": {
              "Authorization": ["ApiKey " + state.api_key],
            },
          }
        ).do_request().as(resp, (resp.StatusCode == 200) ?
          bytes(resp.Body).decode_json().as(body, (has(body.instances) && size(body.instances) > 0) ?
            {
              "events": body.instances.map(instance,
                instance.product_line_items.map(line_item,
                  {
                    "ess": {
                      "billing": line_item.with(
                        {
                          "deployment_name": instance.name,
                          "deployment_id": instance.id,
                          "deployment_type": instance.type,
                          "organization_id": state.organization_id,
                          "from": req.from.format(time_layout.RFC3339),
                          "to": req.to.format(time_layout.RFC3339),
                          "quantities": null,
                          "deployment_tags": [],
                        }
                      ),
                    },
                  }
                )
              ).flatten(),
              "cursor": {
                "last_to": req.to,
              },
              "want_more": req.to < now - duration("24h"),
            }
          :
            {
              "events": [
                {
                  "fake": true,
                },
              ],
              "cursor": {
                "last_to": req.to,
              },
              "want_more": req.to < now - duration("24h"),
            }
          )
        :
          {
            "events": {
              "error": {
                "code": string(resp.StatusCode),
                "id": string(resp.Status),
                "message": "GET " + resp.Request.URL + ": " + (
                  (size(resp.Body) != 0) ?
                    string(resp.Body)
                  :
                    string(resp.Status) + " (" + string(resp.StatusCode) + ")"
                ),
              },
            },
            "want_more": false,
          }
        )
      )
    )
{{#if tags.length}}
tags:
{{else if preserve_original_event}}
tags:
{{/if}}
{{#each tags as |tag i|}}
  - {{tag}}
{{/each}}
{{#if preserve_original_event}}
  - preserve_original_event
{{/if}}
{{#contains "forwarded" tags}}
publisher_pipeline.disable_host: true
{{/contains}}

processors:
- drop_event.when.equals.fake: true
{{#if processors}}
{{processors}}
{{/if}}
