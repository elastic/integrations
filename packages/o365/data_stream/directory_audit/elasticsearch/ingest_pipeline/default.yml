---
description: Pipeline for Office 365 Directory Audit logs
processors:
  - rename:
      field: message
      target_field: event.original
      if: ctx.event?.original == null
      ignore_missing: true
  - json:
      field: event.original
      tag: json_decoding
      target_field: json
      if: ctx.event?.original != null
      on_failure:
        - append:
            field: error.message
            value: 'Processor {{{_ingest.on_failure_processor_type}}} with tag {{{_ingest.on_failure_processor_tag}}} in pipeline {{{_ingest.on_failure_pipeline}}} failed with message: {{{_ingest.on_failure_message}}}'
  - script:
      lang: painless
      description: Convert keys from camelCase to snake_case recursively and remove the original camelCase keys
      tag: camel_to_snake
      if : ctx.json != null
      source: |-
        Map toSnakeCase(Map input) {
          Map output = new HashMap(); 
          Pattern camelCasePattern = /([a-z])([A-Z])/;
          for (entry in input.entrySet()) {
            String key = entry.getKey();
            def value = entry.getValue();
            // convert camelCase to snake_case
            Matcher matcher = camelCasePattern.matcher(key);
            String newKey = matcher.replaceAll("$1_$2").toLowerCase();
            // recursively process nested maps
            if (value instanceof Map) {
                output.put(newKey, toSnakeCase(value));
            }
            // recursively process lists of maps
            else if (value instanceof List) {
              List newList = new ArrayList();
              for (item in value) {
                if (item instanceof Map) {
                    newList.add(toSnakeCase(item));
                } else {
                    newList.add(item);
                }
              }
              output.put(newKey, newList);
            }
            // directly assign values for other types
            else {
              output.put(newKey, value);
            }
          }
          // return new transformed map
          return output; 
        }
        ctx.json = toSnakeCase(ctx.json);  
  - set:
      field: ecs.version
      value: '8.11.0'
  - set:
      field: event.kind
      value: event
  - append:
      field: event.type
      value: info
  - append:
      field: event.category
      value: web
  - set:
      field: event.ingested
      value: "{{_ingest.timestamp}}"
  - fingerprint:
      fields:
        - json.id
      target_field: _id
      ignore_missing: true
  - date:
      field: json.activity_date_time
      target_field: o365.directory_audit.activity_date_time
      formats:
        - ISO8601
      if: ctx.json?.activity_date_time != null
  - remove:
      field: json.activity_date_time
      ignore_missing: true
  - convert:
      field: json.initiated_by.user.ip_address
      tag: ip_conversion
      type: ip
      if: ctx.json?.initiated_by?.user?.ip_address != null
      ignore_missing: true
      on_failure:
        - remove:
            field: json.initiated_by.user.ip_address
            ignore_missing: true
        - append:
            field: error.message
            value: 'Processor {{{_ingest.on_failure_processor_type}}} with tag {{{_ingest.on_failure_processor_tag}}} in pipeline {{{_ingest.on_failure_pipeline}}} failed with message: {{{_ingest.on_failure_message}}}'
  - rename:
      field: json.initiated_by
      target_field: o365.directory_audit.initiated_by
      ignore_missing: true
  - script:
      lang: painless
      description: Parse and append target_resources
      tag: parse_target_resources
      if : ctx.json != null && ctx.json.target_resources instanceof List
      source: |-
        if (ctx.json.containsKey("target_resources")) {
          List target_resources = new ArrayList();
          for (resource in ctx.json.target_resources) {
            Map new_resource = new HashMap();
            // map simple fields
            if (resource.containsKey("id")) {
                new_resource["id"] = resource.id;
            }
            if (resource.containsKey("display_name")) {
                new_resource["display_name"] = resource.display_name;
            }
            if (resource.containsKey("type")) {
                new_resource["type"] = resource.type;
            }
            if (resource.containsKey("group_type")) {
                new_resource["group_type"] = resource.group_type;
            }
            if (resource.containsKey("user_principal_name")) {
                new_resource["user_principal_name"] = resource.user_principal_name;
            }
            // map modified_properties
            if (resource.containsKey("modified_properties") && resource.modified_properties instanceof List) {
                List modified_properties = new ArrayList();
                for (prop in resource.modified_properties) {
                  Map new_prop = new HashMap();
                  if (prop.containsKey("display_name")) {
                      new_prop["display_name"] = prop.display_name;
                  }
                  if (prop.containsKey("old_value")) {
                      new_prop["old_value"] = prop.old_value;
                  }
                  if (prop.containsKey("new_value")) {
                      new_prop["new_value"] = prop.new_value;
                  }
                  modified_properties.add(new_prop);
              }
              new_resource["modified_properties"] = modified_properties;
            }
          target_resources.add(new_resource);
        }
          ctx.o365.directory_audit.target_resources = target_resources;
          ctx.json.remove("target_resources"); 
        }
  - script:
      lang: painless
      description: Parse and append additional_details
      tag: parse_additional_details
      if : ctx.json != null && ctx.json.additional_details instanceof List
      source: |-
        if (ctx.json.containsKey("additional_details")) {
          List additional_details = new ArrayList();
          for (detail in ctx.json.additional_details) {
            Map new_detail = new HashMap();
            if (detail.containsKey("key")) {
              new_detail["key"] = detail.key;
            }
            if (detail.containsKey("value")) {
              new_detail["value"] = detail.value;
            }
            additional_details.add(new_detail);
          }
          ctx.o365.directory_audit.additional_details = additional_details;
          ctx.json.remove("additional_details");
        }
  - script:
      lang: painless
      description: Add remaining fields to o365.directory_audit
      tag: add_remaining_fields
      if : ctx.json != null
      source: |-
        for (entry in ctx.json.entrySet()) {
          String key = entry.getKey();
          def value = entry.getValue();
          if (key != null && value != null) {
            ctx.o365.directory_audit[key] = value;
          }
        }
  - script:
      lang: painless
      description: Drops null/empty values recursively.
      tag: painless_remove_null
      source: |-
        boolean drop(Object object) {
          if (object == null || object == '') {
            return true;
          } else if (object instanceof Map) {
            ((Map) object).values().removeIf(v -> drop(v));
            return (((Map) object).size() == 0);
          } else if (object instanceof List) {
            ((List) object).removeIf(v -> drop(v));
            return (((List) object).length == 0);
          }
          return false;
        }
        drop(ctx);
  - remove:
      field: json
      ignore_missing: true
on_failure:
  - set:
      field: event.kind
      value: pipeline_error
  - append:
      field: tags
      value: preserve_original_event
      allow_duplicates: false
  - append:
      field: error.message
      value: '{{{ _ingest.on_failure_message }}}'
