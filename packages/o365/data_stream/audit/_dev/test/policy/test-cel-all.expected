inputs:
    - data_stream:
        namespace: ep
      meta:
        package:
            name: o365
      name: test-cel-all-o365
      streams:
        - auth.oauth2:
            client.id: client-id
            client.secret: ${SECRET_0}
            endpoint_params:
                grant_type: client_credentials
            provider: azure
            scopes:
                - https://manage.office.com/.default
            token_url: https://login.microsoftonline.com/tenant-id/oauth2/v2.0/token
          data_stream:
            dataset: o365.audit
            type: logs
          interval: 3m
          max_executions: 10000
          processors:
            - add_fields:
                fields:
                    id: "574734885120952459"
                    name: myproject
                target: project
            - add_tags:
                tags:
                    - web
                    - production
                target: environment
          program: |-
            (
              // This exists purely to rewrite the cursor from the original list format
              // (used in v1.18.0 to v2.24.0) to a map (introduced in v2.25.0).
              // This will only happen once; we can remove it when we know there are no
              // users upgrading from the older version. This is never.
              has(state.?cursor.content_types_state_as_list) ?
                state.with(
                  {
                    "cursor": state.cursor.drop("content_types_state_as_list").with(
                      {
                        // Use zip to avoid requiring a higher agent version.
                        "last_for": zip(
                          // Lowercase key since test data has this mixed. w00t!1
                          state.cursor.content_types_state_as_list.map(e, e.content_type.to_lower()),
                          state.cursor.content_types_state_as_list.map(e, e.content_created_at)
                        ),
                      }
                    ),
                  }
                )
              :
                state
            ).as(state,
              // Initialize a fixed stopping point for this sequence of evaluations.
              // Stop just before now to avoid times that may have unstable results.
              // Make it a string value to avoid type problems.
              state.with(
                {
                  "stopping_point": state.?stopping_point.orValue(string(now - duration("3s"))),
                }
              )
            ).as(state,
              // Initialize the list of types to consider in this sequence of evaluations.
              state.with(
                {
                  "todo_types": state.?todo_types.orValue([]).as(existing_todo_types,
                    (existing_todo_types.size() > 0) ?
                      existing_todo_types
                    :
                      state.base.content_types.split(",").map(t, t.trim_space())
                  ),
                }
              )
            ).as(state,

              (state.todo_types.size() == 0) ?
                // ------------------------------------------------------------------------
                // No types active - Log an error and stop
                // ------------------------------------------------------------------------

                state.with(
                  {
                    "events": {
                      "error": {
                        "message": "No content types found: '" + state.base.content_types + "'",
                      },
                    },
                    "want_more": false,
                  }
                )
              : !state.?subscribed.orValue({}).keys().exists(k, k == state.todo_types[0]) ?
                // ------------------------------------------------------------------------
                // Not subscribed to the current type - Subscribe
                // ------------------------------------------------------------------------

                request(
                  "POST",
                  sprintf(
                    "%s/api/v1.0/%s/activity/feed/subscriptions/start?%s",
                    [
                      state.url.trim_right("/"),
                      state.base.tenant_id,
                      {
                        "contentType": [state.todo_types[0]],
                        "PublisherIdentifier": [state.base.tenant_id],
                      }.format_query(),
                    ]
                  )
                ).do_request().as(sub_resp, (sub_resp.StatusCode == 200 || sub_resp.StatusCode == 400) ?
                  // Subscription successful - Record subscription, requeue type and continue
                  state.with(
                    {
                      "todo_types": tail(state.todo_types) + [state.todo_types[0]],
                      "subscribed": state.?subscribed.orValue({}).with({state.todo_types[0]: true}),
                      "want_more": true,
                      "events": [{"retry": true}],
                    }
                  )
                :
                  // Subscription error - Log it, skip type and continue if there's another type
                  state.with(
                    {
                      "events": {
                        "error": {
                          "code": string(sub_resp.StatusCode),
                          "id": string(sub_resp.Status),
                          "message": "POST /activity/feed/subscriptions/start?contentType=" + state.todo_types[0] + ": " + (
                            (size(sub_resp.Body) != 0) ?
                              string(sub_resp.Body)
                            :
                              string(sub_resp.Status) + " (" + string(sub_resp.StatusCode) + ")"
                          ),
                        },
                      },
                      "todo_types": tail(state.todo_types),
                      "want_more": tail(state.todo_types).size() > 0,
                    }
                  )
                )
              : state.?cursor.todo_content[0].hasValue() ?
                (
                  // ------------------------------------------------------------------------
                  // Content to fetch - Fetch it
                  // ------------------------------------------------------------------------

                  (timestamp(state.cursor.todo_content[0].contentExpiration) <= now()) ?
                    // Content expired - Skip this content and continue
                    state.with(
                      {
                        "cursor": state.cursor.with({"todo_content": tail(state.cursor.todo_content)}),
                        "want_more": true,
                        "events": [{"retry": true}],
                      }
                    )
                  :
                    request(
                      "GET",
                      state.cursor.todo_content[0].contentUri
                    ).do_request().as(content_resp, (content_resp.StatusCode == 200) ?
                      // Fetch successful - Return events, continue with remaining content
                      state.with(
                        {
                          "events": content_resp.Body.decode_json().map(e,
                            {
                              "o365audit": e,
                              "event": {"original": e.encode_json()},
                            }
                          ),
                          "cursor": state.cursor.with({"todo_content": tail(state.cursor.todo_content)}),
                          "want_more": true,
                        }
                      )
                    :
                      // Fetch error - Log it, skip this content and continue
                      state.with(
                        {
                          "events": {
                            "error": {
                              "code": string(content_resp.StatusCode),
                              "id": string(content_resp.Status),
                              "message": "GET " + state.cursor.todo_content[0].contentUri + ": " + (
                                (size(content_resp.Body) != 0) ?
                                  string(content_resp.Body)
                                :
                                  string(content_resp.Status) + " (" + string(content_resp.StatusCode) + ")"
                              ),
                            },
                          },
                          "cursor": state.cursor.with({"todo_content": tail(state.cursor.todo_content)}),
                          "want_more": true,
                        }
                      )
                    )
                )
              : state.?cursor.todo_links[0].hasValue() ?
                // ------------------------------------------------------------------------
                // Listing link generated or received - Request it
                // ------------------------------------------------------------------------

                request(
                  "GET",
                  state.cursor.todo_links[0]
                ).do_request().as(list_resp, (list_resp.StatusCode == 200) ?
                  // Listing successful - Enqueue any additional link, enqueue content to fetch
                  list_resp.Body.decode_json().as(content_list,
                    state.with(
                      {
                        "cursor": state.cursor.with(
                          {
                            // The non-canonical header name NextPageUri is always normalized to Nextpageuri
                            "todo_links": tail(state.cursor.todo_links) + (list_resp.Header.?Nextpageuri[0].optMap(l, [l])).orValue([]),
                            "todo_content": state.cursor.?todo_content.orValue([]) + content_list,
                          }
                        ),
                        "want_more": true,
                        "events": [{"retry": true}],
                      }
                    )
                  )
                :
                  // Listing error - Log it, skip this link and continue
                  state.with(
                    {
                      "events": {
                        "error": {
                          "code": string(list_resp.StatusCode),
                          "id": string(list_resp.Status),
                          "message": "GET " + state.cursor.todo_links[0] + ": " + (
                            (size(list_resp.Body) != 0) ?
                              string(list_resp.Body)
                            :
                              string(list_resp.Status) + " (" + string(list_resp.StatusCode) + ")"
                          ),
                        },
                      },
                      "cursor": state.cursor.with(
                        {
                          "todo_links": tail(state.cursor.todo_links),
                        }
                      ),
                      "want_more": true,
                    }
                  )
                )
              :
                // ------------------------------------------------------------------------
                // Subscribed and no ready work - Check the current type
                // ------------------------------------------------------------------------

                max(
                  state.?cursor.last_for[state.todo_types[0].to_lower()].orValue(
                    string(now() - duration(state.base.list_contents_start_time))
                  ).parse_time(time_layout.RFC3339),
                  now() - duration(state.base.maximum_age)
                ).as(start,
                  timestamp(state.stopping_point).as(stopping_point,
                    {
                      "start": start,
                      "end": min(start + min(duration("24h"), duration(state.base.batch_interval)), stopping_point),
                      "stopping_point": stopping_point,
                    }
                  )
                ).as(time_range,
                  (time_range.start < time_range.stopping_point && time_range.end - time_range.start >= duration("1ms")) ?
                    // Not up to date - Generate a link, update last_for, requeue type
                    state.with(
                      {
                        "cursor": state.?cursor.orValue({}).with(
                          {
                            "todo_links": state.?cursor.todo_links.orValue([]) + [
                              sprintf(
                                "%s/api/v1.0/%s/activity/feed/subscriptions/content?%s",
                                [
                                  state.url.trim_right("/"),
                                  state.base.tenant_id,
                                  {
                                    "contentType": [state.todo_types[0]],
                                    "PublisherIdentifier": [state.base.tenant_id],
                                    "startTime": [string(time_range.start)],
                                    "endTime": [string(time_range.end)],
                                  }.format_query(),
                                ]
                              ),
                            ],
                            "last_for": state.?cursor.last_for.orValue({}).with(
                              {
                                state.todo_types[0].to_lower(): string(time_range.end),
                              }
                            ),
                          }
                        ),
                        "todo_types": tail(state.todo_types) + [state.todo_types[0]],
                        "want_more": true,
                        "events": [{"retry": true}],
                      }
                    )
                  : (state.todo_types.size() > 1) ?
                    // Up to date, more types to consider - Consider remaining types
                    state.with(
                      {
                        "todo_types": tail(state.todo_types),
                        "want_more": true,
                        "events": [{"retry": true}],
                      }
                    )
                  :
                    // Up to date, no more types to consider - Stop
                    state.drop("stopping_point").with(
                      {
                        "todo_types": [],
                        "want_more": false,
                        "events": [],
                      }
                    )
                )
            )
          publisher_pipeline.disable_host: true
          redact:
            fields:
                - base.tenant_id
          resource.proxy_url: http://proxy.tld
          resource.rate_limit.burst: 500
          resource.rate_limit.limit: 0.01
          resource.redirect.max_redirects: 10s
          resource.retry.max_attempts: 5
          resource.retry.wait_max: 60s
          resource.retry.wait_min: 1s
          resource.ssl:
            certificate: |
                -----BEGIN CERTIFICATE-----
                MIIDCjCCAfKgAwIBAgITJ706Mu2wJlKckpIvkWxEHvEyijANBgkqhkiG9w0BAQsF
                ADAUMRIwEAYDVQQDDAlsb2NhbGhvc3QwIBcNMTkwNzIyMTkyOTA0WhgPMjExOTA2
                MjgxOTI5MDRaMBQxEjAQBgNVBAMMCWxvY2FsaG9zdDCCASIwDQYJKoZIhvcNAQEB
                BQADggEPADCCAQoCggEBANce58Y/JykI58iyOXpxGfw0/gMvF0hUQAcUrSMxEO6n
                fZRA49b4OV4SwWmA3395uL2eB2NB8y8qdQ9muXUdPBWE4l9rMZ6gmfu90N5B5uEl
                94NcfBfYOKi1fJQ9i7WKhTjlRkMCgBkWPkUokvBZFRt8RtF7zI77BSEorHGQCk9t
                /D7BS0GJyfVEhftbWcFEAG3VRcoMhF7kUzYwp+qESoriFRYLeDWv68ZOvG7eoWnP
                PsvZStEVEimjvK5NSESEQa9xWyJOmlOKXhkdymtcUd/nXnx6UTCFgnkgzSdTWV41
                CI6B6aJ9svCTI2QuoIq2HxX/ix7OvW1huVmcyHVxyUECAwEAAaNTMFEwHQYDVR0O
                BBYEFPwN1OceFGm9v6ux8G+DZ3TUDYxqMB8GA1UdIwQYMBaAFPwN1OceFGm9v6ux
                8G+DZ3TUDYxqMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBAG5D
                874A4YI7YUwOVsVAdbWtgp1d0zKcPRR+r2OdSbTAV5/gcS3jgBJ3i1BN34JuDVFw
                3DeJSYT3nxy2Y56lLnxDeF8CUTUtVQx3CuGkRg1ouGAHpO/6OqOhwLLorEmxi7tA
                H2O8mtT0poX5AnOAhzVy7QW0D/k4WaoLyckM5hUa6RtvgvLxOwA0U+VGurCDoctu
                8F4QOgTAWyh8EZIwaKCliFRSynDpv3JTUwtfZkxo6K6nce1RhCWFAsMvDZL8Dgc0
                yvgJ38BRsFOtkRuAGSf6ZUwTO8JJRRIFnpUzXflAnGivK9M13D5GEQMmIl6U9Pvk
                sxSmbIUfc2SGJGCJD4I=
                -----END CERTIFICATE-----
            certificate_authorities:
                - |
                  -----BEGIN CERTIFICATE-----
                  MIIDCjCCAfKgAwIBAgITJ706Mu2wJlKckpIvkWxEHvEyijANBgkqhkiG9w0BAQsF
                  ADAUMRIwEAYDVQQDDAlsb2NhbGhvc3QwIBcNMTkwNzIyMTkyOTA0WhgPMjExOTA2
                  MjgxOTI5MDRaMBQxEjAQBgNVBAMMCWxvY2FsaG9zdDCCASIwDQYJKoZIhvcNAQEB
                  BQADggEPADCCAQoCggEBANce58Y/JykI58iyOXpxGfw0/gMvF0hUQAcUrSMxEO6n
                  fZRA49b4OV4SwWmA3395uL2eB2NB8y8qdQ9muXUdPBWE4l9rMZ6gmfu90N5B5uEl
                  94NcfBfYOKi1fJQ9i7WKhTjlRkMCgBkWPkUokvBZFRt8RtF7zI77BSEorHGQCk9t
                  /D7BS0GJyfVEhftbWcFEAG3VRcoMhF7kUzYwp+qESoriFRYLeDWv68ZOvG7eoWnP
                  PsvZStEVEimjvK5NSESEQa9xWyJOmlOKXhkdymtcUd/nXnx6UTCFgnkgzSdTWV41
                  CI6B6aJ9svCTI2QuoIq2HxX/ix7OvW1huVmcyHVxyUECAwEAAaNTMFEwHQYDVR0O
                  BBYEFPwN1OceFGm9v6ux8G+DZ3TUDYxqMB8GA1UdIwQYMBaAFPwN1OceFGm9v6ux
                  8G+DZ3TUDYxqMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBAG5D
                  874A4YI7YUwOVsVAdbWtgp1d0zKcPRR+r2OdSbTAV5/gcS3jgBJ3i1BN34JuDVFw
                  3DeJSYT3nxy2Y56lLnxDeF8CUTUtVQx3CuGkRg1ouGAHpO/6OqOhwLLorEmxi7tA
                  H2O8mtT0poX5AnOAhzVy7QW0D/k4WaoLyckM5hUa6RtvgvLxOwA0U+VGurCDoctu
                  8F4QOgTAWyh8EZIwaKCliFRSynDpv3JTUwtfZkxo6K6nce1RhCWFAsMvDZL8Dgc0
                  yvgJ38BRsFOtkRuAGSf6ZUwTO8JJRRIFnpUzXflAnGivK9M13D5GEQMmIl6U9Pvk
                  sxSmbIUfc2SGJGCJD4I=
                  -----END CERTIFICATE-----
            cipher_suites:
                - ECDHE-ECDSA-AES-128-CBC-SHA
                - ECDHE-ECDSA-AES-256-GCM-SHA384
            curve_types:
                - P-256
            enabled: true
            key: |
                -----BEGIN PRIVATE KEY-----
                MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDXHufGPycpCOfI
                sjl6cRn8NP4DLxdIVEAHFK0jMRDup32UQOPW+DleEsFpgN9/ebi9ngdjQfMvKnUP
                Zrl1HTwVhOJfazGeoJn7vdDeQebhJfeDXHwX2DiotXyUPYu1ioU45UZDAoAZFj5F
                KJLwWRUbfEbRe8yO+wUhKKxxkApPbfw+wUtBicn1RIX7W1nBRABt1UXKDIRe5FM2
                MKfqhEqK4hUWC3g1r+vGTrxu3qFpzz7L2UrRFRIpo7yuTUhEhEGvcVsiTppTil4Z
                HcprXFHf5158elEwhYJ5IM0nU1leNQiOgemifbLwkyNkLqCKth8V/4sezr1tYblZ
                nMh1cclBAgMBAAECggEBAKdP5jyOicqknoG9/G564RcDsDyRt64NuO7I6hBg7SZx
                Jn7UKWDdFuFP/RYtoabn6QOxkVVlydp5Typ3Xu7zmfOyss479Q/HIXxmmbkD0Kp0
                eRm2KN3y0b6FySsS40KDRjKGQCuGGlNotW3crMw6vOvvsLTlcKgUHF054UVCHoK/
                Piz7igkDU7NjvJeha53vXL4hIjb10UtJNaGPxIyFLYRZdRPyyBJX7Yt3w8dgz8WM
                epOPu0dq3bUrY3WQXcxKZo6sQjE1h7kdl4TNji5jaFlvD01Y8LnyG0oThOzf0tve
                Gaw+kuy17gTGZGMIfGVcdeb+SlioXMAAfOps+mNIwTECgYEA/gTO8W0hgYpOQJzn
                BpWkic3LAoBXWNpvsQkkC3uba8Fcps7iiEzotXGfwYcb5Ewf5O3Lrz1EwLj7GTW8
                VNhB3gb7bGOvuwI/6vYk2/dwo84bwW9qRWP5hqPhNZ2AWl8kxmZgHns6WTTxpkRU
                zrfZ5eUrBDWjRU2R8uppgRImsxMCgYEA2MxuL/C/Ko0d7XsSX1kM4JHJiGpQDvb5
                GUrlKjP/qVyUysNF92B9xAZZHxxfPWpdfGGBynhw7X6s+YeIoxTzFPZVV9hlkpAA
                5igma0n8ZpZEqzttjVdpOQZK8o/Oni/Q2S10WGftQOOGw5Is8+LY30XnLvHBJhO7
                TKMurJ4KCNsCgYAe5TDSVmaj3dGEtFC5EUxQ4nHVnQyCpxa8npL+vor5wSvmsfUF
                hO0s3GQE4sz2qHecnXuPldEd66HGwC1m2GKygYDk/v7prO1fQ47aHi9aDQB9N3Li
                e7Vmtdn3bm+lDjtn0h3Qt0YygWj+wwLZnazn9EaWHXv9OuEMfYxVgYKpdwKBgEze
                Zy8+WDm5IWRjn8cI5wT1DBT/RPWZYgcyxABrwXmGZwdhp3wnzU/kxFLAl5BKF22T
                kRZ+D+RVZvVutebE9c937BiilJkb0AXLNJwT9pdVLnHcN2LHHHronUhV7vetkop+
                kGMMLlY0lkLfoGq1AxpfSbIea9KZam6o6VKxEnPDAoGAFDCJm+ZtsJK9nE5GEMav
                NHy+PwkYsHhbrPl4dgStTNXLenJLIJ+Ke0Pcld4ZPfYdSyu/Tv4rNswZBNpNsW9K
                0NwJlyMBfayoPNcJKXrH/csJY7hbKviAHr1eYy9/8OL0dHf85FV+9uY5YndLcsDc
                nygO9KTJuUiBrLr0AHEnqko=
                -----END PRIVATE KEY-----
            supported_protocols:
                - TLSv1.2
          resource.timeout: 60s
          resource.tracer:
            enabled: true
            filename: ../../logs/cel/http-request-trace-*.ndjson
            maxbackups: 10
            maxsize: 5
          resource.url: https://manage.office.com
          state:
            base:
                batch_interval: 1h
                content_types: Audit.AzureActiveDirectory, Audit.Exchange, Audit.SharePoint, Audit.General, DLP.All
                list_contents_start_time: 167h55m
                maximum_age: 167h55m
                tenant_id: tenant-id
            want_more: false
          tags:
            - preserve_original_event
            - forwarded
            - o365-cel
      type: cel
      use_output: default
output_permissions:
    default:
        _elastic_agent_checks:
            cluster:
                - monitor
        _elastic_agent_monitoring:
            indices: []
        uuid-for-permissions-on-related-indices:
            indices:
                - names:
                    - logs-o365.audit-ep
                  privileges:
                    - auto_configure
                    - create_doc
secret_references:
    - {}
