inputs:
    - data_stream:
        namespace: ep
      meta:
        package:
            name: o365
      name: test-cel-default-o365
      streams:
        - auth.oauth2:
            client.id: client-id
            client.secret: ${SECRET_0}
            endpoint_params:
                grant_type: client_credentials
            provider: azure
            scopes:
                - https://manage.office.com/.default
            token_url: https://login.microsoftonline.com/tenant-id/oauth2/v2.0/token
          data_stream:
            dataset: o365.audit
            type: logs
          interval: 3m
          program: |-
            (
              // This exists purely to rewrite the cursor from the original list format
              // (used in v1.18.0 to v2.24.0) to a map (introduced in v2.25.0).
              // This will only happen once; we can remove it when we know there are no
              // users upgrading from the older version. This is never.
              has(state.?cursor.content_types_state_as_list) ?
                state.with(
                  {
                    "cursor": state.cursor.drop("content_types_state_as_list").with(
                      {
                        // Use zip to avoid requiring a higher agent version.
                        "last_for": zip(
                          // Lowercase key since test data has this mixed. w00t!1
                          state.cursor.content_types_state_as_list.map(e, e.content_type.to_lower()),
                          state.cursor.content_types_state_as_list.map(e, e.content_created_at)
                        ),
                      }
                    ),
                  }
                )
              :
                state
            ).as(state,
              // Initialize a fixed stopping point for this sequence of evaluations.
              // Stop just before now to avoid times that may have unstable results.
              // Make it a string value to avoid type problems.
              state.with(
                {
                  "stopping_point": state.?stopping_point.orValue(string(now - duration("3s"))),
                }
              )
            ).as(state,
              // Initialize the list of types to consider in this sequence of evaluations.
              state.with(
                {
                  "todo_types": state.?todo_types.orValue([]).as(existing_todo_types,
                    (existing_todo_types.size() > 0) ?
                      existing_todo_types
                    :
                      state.base.content_types.split(",").map(t, t.trim_space())
                  ),
                }
              )
            ).as(state,

              (state.todo_types.size() == 0) ?
                // ------------------------------------------------------------------------
                // No types active - Log an error and stop
                // ------------------------------------------------------------------------

                state.with(
                  {
                    "events": {
                      "error": {
                        "message": "No content types found: '" + state.base.content_types + "'",
                      },
                    },
                    "want_more": false,
                  }
                )
              : !state.?subscribed.orValue({}).keys().exists(k, k == state.todo_types[0]) ?
                // ------------------------------------------------------------------------
                // Not subscribed to the current type - Subscribe
                // ------------------------------------------------------------------------

                request(
                  "POST",
                  sprintf(
                    "%s/api/v1.0/%s/activity/feed/subscriptions/start?%s",
                    [
                      state.url.trim_right("/"),
                      state.base.tenant_id,
                      {
                        "contentType": [state.todo_types[0]],
                        "PublisherIdentifier": [state.base.tenant_id],
                      }.format_query(),
                    ]
                  )
                ).do_request().as(sub_resp, (sub_resp.StatusCode == 200 || sub_resp.StatusCode == 400) ?
                  // Subscription successful - Record subscription, requeue type and continue
                  state.with(
                    {
                      "todo_types": tail(state.todo_types) + [state.todo_types[0]],
                      "subscribed": state.?subscribed.orValue({}).with({state.todo_types[0]: true}),
                      "want_more": true,
                      "events": [{"retry": true}],
                    }
                  )
                :
                  // Subscription error - Log it, skip type and continue if there's another type
                  state.with(
                    {
                      "events": {
                        "error": {
                          "code": string(sub_resp.StatusCode),
                          "id": string(sub_resp.Status),
                          "message": "POST /activity/feed/subscriptions/start?contentType=" + state.todo_types[0] + ": " + (
                            (size(sub_resp.Body) != 0) ?
                              string(sub_resp.Body)
                            :
                              string(sub_resp.Status) + " (" + string(sub_resp.StatusCode) + ")"
                          ),
                        },
                      },
                      "todo_types": tail(state.todo_types),
                      "want_more": tail(state.todo_types).size() > 0,
                    }
                  )
                )
              : state.?cursor.todo_content[0].hasValue() ?
                (
                  // ------------------------------------------------------------------------
                  // Content to fetch - Fetch it
                  // ------------------------------------------------------------------------

                  (timestamp(state.cursor.todo_content[0].contentExpiration) <= now()) ?
                    // Content expired - Skip this content and continue
                    state.with(
                      {
                        "cursor": state.cursor.with({"todo_content": tail(state.cursor.todo_content)}),
                        "want_more": true,
                        "events": [{"retry": true}],
                      }
                    )
                  :
                    request(
                      "GET",
                      state.cursor.todo_content[0].contentUri
                    ).do_request().as(content_resp, (content_resp.StatusCode == 200) ?
                      // Fetch successful - Return events, continue with remaining content
                      state.with(
                        {
                          "events": content_resp.Body.decode_json().map(e,
                            {
                              "o365audit": e,
                              "event": {"original": e.encode_json()},
                            }
                          ),
                          "cursor": state.cursor.with({"todo_content": tail(state.cursor.todo_content)}),
                          "want_more": true,
                        }
                      )
                    :
                      // Fetch error - Log it, skip this content and continue
                      state.with(
                        {
                          "events": {
                            "error": {
                              "code": string(content_resp.StatusCode),
                              "id": string(content_resp.Status),
                              "message": "GET " + state.cursor.todo_content[0].contentUri + ": " + (
                                (size(content_resp.Body) != 0) ?
                                  string(content_resp.Body)
                                :
                                  string(content_resp.Status) + " (" + string(content_resp.StatusCode) + ")"
                              ),
                            },
                          },
                          "cursor": state.cursor.with({"todo_content": tail(state.cursor.todo_content)}),
                          "want_more": true,
                        }
                      )
                    )
                )
              : state.?cursor.todo_links[0].hasValue() ?
                // ------------------------------------------------------------------------
                // Listing link generated or received - Request it
                // ------------------------------------------------------------------------

                request(
                  "GET",
                  state.cursor.todo_links[0]
                ).do_request().as(list_resp, (list_resp.StatusCode == 200) ?
                  // Listing successful - Enqueue any additional link, enqueue content to fetch
                  list_resp.Body.decode_json().as(content_list,
                    state.with(
                      {
                        "cursor": state.cursor.with(
                          {
                            // The non-canonical header name NextPageUri is always normalized to Nextpageuri
                            "todo_links": tail(state.cursor.todo_links) + (list_resp.Header.?Nextpageuri[0].optMap(l, [l])).orValue([]),
                            "todo_content": state.cursor.?todo_content.orValue([]) + content_list,
                          }
                        ),
                        "want_more": true,
                        "events": [{"retry": true}],
                      }
                    )
                  )
                :
                  // Listing error - Log it, skip this link and continue
                  state.with(
                    {
                      "events": {
                        "error": {
                          "code": string(list_resp.StatusCode),
                          "id": string(list_resp.Status),
                          "message": "GET " + state.cursor.todo_links[0] + ": " + (
                            (size(list_resp.Body) != 0) ?
                              string(list_resp.Body)
                            :
                              string(list_resp.Status) + " (" + string(list_resp.StatusCode) + ")"
                          ),
                        },
                      },
                      "cursor": state.cursor.with(
                        {
                          "todo_links": tail(state.cursor.todo_links),
                        }
                      ),
                      "want_more": true,
                    }
                  )
                )
              :
                // ------------------------------------------------------------------------
                // Subscribed and no ready work - Check the current type
                // ------------------------------------------------------------------------

                max(
                  state.?cursor.last_for[state.todo_types[0].to_lower()].orValue(
                    string(now() - duration(state.base.list_contents_start_time))
                  ).parse_time(time_layout.RFC3339),
                  now() - duration(state.base.maximum_age)
                ).as(start,
                  timestamp(state.stopping_point).as(stopping_point,
                    {
                      "start": start,
                      "end": min(start + min(duration("24h"), duration(state.base.batch_interval)), stopping_point),
                      "stopping_point": stopping_point,
                    }
                  )
                ).as(time_range,
                  (time_range.start < time_range.stopping_point && time_range.end - time_range.start >= duration("1ms")) ?
                    // Not up to date - Generate a link, update last_for, requeue type
                    state.with(
                      {
                        "cursor": state.?cursor.orValue({}).with(
                          {
                            "todo_links": state.?cursor.todo_links.orValue([]) + [
                              sprintf(
                                "%s/api/v1.0/%s/activity/feed/subscriptions/content?%s",
                                [
                                  state.url.trim_right("/"),
                                  state.base.tenant_id,
                                  {
                                    "contentType": [state.todo_types[0]],
                                    "PublisherIdentifier": [state.base.tenant_id],
                                    "startTime": [string(time_range.start)],
                                    "endTime": [string(time_range.end)],
                                  }.format_query(),
                                ]
                              ),
                            ],
                            "last_for": state.?cursor.last_for.orValue({}).with(
                              {
                                state.todo_types[0].to_lower(): string(time_range.end),
                              }
                            ),
                          }
                        ),
                        "todo_types": tail(state.todo_types) + [state.todo_types[0]],
                        "want_more": true,
                        "events": [{"retry": true}],
                      }
                    )
                  : (state.todo_types.size() > 1) ?
                    // Up to date, more types to consider - Consider remaining types
                    state.with(
                      {
                        "todo_types": tail(state.todo_types),
                        "want_more": true,
                        "events": [{"retry": true}],
                      }
                    )
                  :
                    // Up to date, no more types to consider - Stop
                    state.drop("stopping_point").with(
                      {
                        "todo_types": [],
                        "want_more": false,
                        "events": [],
                      }
                    )
                )
            )
          publisher_pipeline.disable_host: true
          redact:
            fields:
                - base.tenant_id
          resource.timeout: 60s
          resource.tracer:
            enabled: false
            filename: ../../logs/cel/http-request-trace-*.ndjson
            maxbackups: 10
            maxsize: 5
          resource.url: https://manage.office.com
          state:
            base:
                batch_interval: 1h
                content_types: Audit.AzureActiveDirectory, Audit.Exchange, Audit.SharePoint, Audit.General, DLP.All
                list_contents_start_time: 167h55m
                maximum_age: 167h55m
                tenant_id: tenant-id
            want_more: false
          tags:
            - forwarded
            - o365-cel
      type: cel
      use_output: default
output_permissions:
    default:
        _elastic_agent_checks:
            cluster:
                - monitor
        _elastic_agent_monitoring:
            indices: []
        uuid-for-permissions-on-related-indices:
            indices:
                - names:
                    - logs-o365.audit-ep
                  privileges:
                    - auto_configure
                    - create_doc
secret_references:
    - {}
