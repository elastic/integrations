inputs:
    - data_stream:
        namespace: ep
      meta:
        package:
            name: o365
      name: test-cel-default-o365
      streams:
        - auth.oauth2:
            client.id: client-id
            client.secret: ${SECRET_0}
            endpoint_params:
                grant_type: client_credentials
            provider: azure
            scopes:
                - https://manage.office.com/.default
            token_url: https://login.microsoftonline.com/tenant-id/oauth2/v2.0/token
          data_stream:
            dataset: o365.audit
            type: logs
          interval: 3m
          program: |-
            state.with(
              state.?work.todo_content[0].hasValue() ?
                // Do any outstanding content collection to do.
                state.work.todo_content.filter(e,
                  // Filter out stale elements.
                  timestamp(e.contentExpiration) > now()
                ).as(list, (size(list) != 0) ?
                  list.map(e,
                    timestamp(e.endTime)
                  ).min().as(min,
                    list.filter(e, timestamp(e.endTime) == min)[0]
                  ).as(oldest,
                    {
                      "curr_content": oldest,
                      "todo_content": list.filter(e, e.contentUri != oldest.contentUri),
                    }
                  )
                :
                  {"todo_content": []}
                ).as(w, !has(w.curr_content) ?
                  {
                    "work": state.work.drop("curr_content").with(w),
                    "events": [],
                  }
                :
                  {
                    "work": state.work.with(
                      {
                        "curr_content": w.curr_content,
                        "todo_content": w.todo_content,
                      }
                    ),
                    "events": request(
                      "GET",
                      w.curr_content.contentUri
                    ).do_request().as(content_resp, (content_resp.StatusCode == 200) ?
                      dyn(
                        content_resp.Body.decode_json().map(e,
                          {
                            "o365audit": e,
                            "event": {"original": e.encode_json()},
                          }
                        )
                      ).orValue(dyn([]))
                    :
                      {
                        "error": {
                          "code": string(content_resp.StatusCode),
                          "id": string(content_resp.Status),
                          "message": "GET " + w.curr_content.contentUri + ": " + (
                            (size(content_resp.Body) != 0) ?
                              string(content_resp.Body)
                            :
                              string(content_resp.Status) + " (" + string(content_resp.StatusCode) + ")"
                          ),
                        },
                      }
                    ),
                  }
                )
              : has(state.?work.next_list) ?
                // Follow the next list link.
                request(
                  "GET",
                  state.work.next_list
                ).do_request().as(list_resp, (list_resp.StatusCode == 200) ?
                  list_resp.Body.decode_json().as(list,
                    (list + state.work.todo_content).filter(e,
                      // Filter out stale elements.
                      e.?contentExpiration.optMap(t, t.parse_time(time_layout.RFC3339) >= now()).orValue(true)
                    ).map(e,
                      // Record the cursor update time for the content.
                      has(e.endTime) ?
                        e
                      :
                        e.with(
                          {
                            "endTime": state.work.next_list.parse_url().RawQuery.parse_query().as(q,
                              [
                                ?q.?endTime[0],
                                ?q.?endtime[0],
                              ]
                            )[?0].orValue(now),
                          }
                        )
                    ).as(list, (size(list) != 0) ?
                      list.map(e,
                        timestamp(e.endTime)
                      ).min().as(min,
                        // This is known to exist since a non-empty list must have a minimum.
                        list.filter(e, timestamp(e.endTime) == min)[0]
                      ).as(oldest,
                        {
                          "curr_content": oldest,
                          "todo_content": list.filter(e, e.contentUri != oldest.contentUri),
                        }
                      )
                    :
                      {"todo_content": []}
                    )
                  ).as(w, !has(w.curr_content) ?
                    {
                      "work": state.work.drop("curr_content").with(w),
                      "events": [],
                    }
                  :
                    {
                      "cursor": state.?cursor.orValue({}).with(
                        {
                          "last_for": state.?cursor.last_for.orValue({}).with(
                            w.curr_content.as(l,
                              {l.contentType.to_lower(): l.endTime}
                            )
                          ),
                        }
                      ),
                      "work": state.work.drop(["curr_content", "next_list"]).with(
                        {
                          "curr_content": w.curr_content,
                          "todo_content": w.todo_content,
                          ?"next_list": [
                            // Work around non-conformance with HTTP header MIME standards.
                            ?list_resp.Header.?Nextpageuri[0],
                            ?list_resp.Header.?NextPageUri[0],
                          ][?0],
                        }
                      ),
                      "events": w.curr_content.as(l,
                        request(
                          "GET",
                          l.contentUri
                        ).do_request().as(content_resp, (content_resp.StatusCode == 200) ?
                          dyn(
                            content_resp.Body.decode_json().map(e,
                              {
                                "o365audit": e,
                                "event": {"original": e.encode_json()},
                              }
                            )
                          ).orValue(dyn([]))
                        :
                          {
                            "error": {
                              "code": string(content_resp.StatusCode),
                              "id": string(content_resp.Status),
                              "message": "GET " + l.contentUri + ": " + (
                                (size(content_resp.Body) != 0) ?
                                  string(content_resp.Body)
                                :
                                  string(content_resp.Status) + " (" + string(content_resp.StatusCode) + ")"
                              ),
                            },
                          }
                        )
                      ),
                    }
                  )
                :
                  {
                    "events": {
                      "error": {
                        "code": string(list_resp.StatusCode),
                        "id": string(list_resp.Status),
                        "message": "GET " + state.work.next_list + ": " + (
                          (size(list_resp.Body) != 0) ?
                            string(list_resp.Body)
                          :
                            string(list_resp.Status) + " (" + string(list_resp.StatusCode) + ")"
                        ),
                      },
                    },
                  }
                )
              :
                (
                  state.?work.todo_type[0].hasValue() ?
                    // Consume one work unit and get ready to use it.
                    {
                      "curr_type": state.work.todo_type[0],
                      "todo_type": tail(state.work.todo_type),
                    }
                  :
                    // No work todo, so get items from the config.
                    state.base.content_types.split(",").map(t, t.trim_space()).as(todo_type,
                      {
                        ?"curr_type": todo_type[?0],
                        "todo_type": tail(todo_type),
                      }
                    )
                ).as(work,
                  // Get subscription details.
                  state.with(
                    !has(work.curr_type) ?
                      // No current work item, so finish.
                      {}
                    :
                      {
                        "base": state.base,
                        "work": work.with(
                          {
                            "sub": (has(state.?cursor.last_for) && work.curr_type.to_lower() in state.cursor.last_for) ?
                              // We have started this content type before, so set "enabled: true".
                              {
                                "type": work.curr_type,
                                "enabled": true,
                              }
                            :
                              request(
                                "POST",
                                sprintf(
                                  "%s/api/v1.0/%s/activity/feed/subscriptions/start?%s",
                                  [
                                    state.url.trim_right("/"),
                                    state.base.tenant_id,
                                    {
                                      "contentType": [work.curr_type],
                                      "PublisherIdentifier": [state.base.tenant_id],
                                    }.format_query(),
                                  ]
                                )
                              ).do_request().as(sub_resp, (sub_resp.StatusCode == 200 || sub_resp.StatusCode == 400) ?
                                sub_resp.Body.decode_json().as(sub,
                                  {
                                    "type": work.curr_type, // If we get an AF20024, sub.contentType will be absent.
                                    "enabled": sub.?status == optional.of("enabled") || sub.?error.code == optional.of("AF20024"),
                                  }
                                )
                              :
                                {
                                  "error": {
                                    "code": string(sub_resp.StatusCode),
                                    "id": string(sub_resp.Status),
                                    "message": "POST /activity/feed/subscriptions/start?contentType=" + work.curr_type + ": " + (
                                      (size(sub_resp.Body) != 0) ?
                                        string(sub_resp.Body)
                                      :
                                        string(sub_resp.Status) + " (" + string(sub_resp.StatusCode) + ")"
                                    ),
                                  },
                                }
                              ),
                          }
                        ),
                      }
                  )
                ).as(state, !has(state.base) ?
                  // No current work item above, so finish.
                  {}
                : has(state.?work.sub.error) ?
                  // Getting subscription detail failed.
                  state.work.sub.as(err, state.drop("work.sub").with({"events": err}))
                :
                  (
                    // This exists purely to rewrite the cursor from the original
                    // list format to a map. This will only happen once; we can
                    // remove it when we know there are no users on the previous
                    // version. This is never.
                    has(state.?cursor.content_types_state_as_list) ?
                      state.with(
                        {
                          "cursor": state.cursor.drop("content_types_state_as_list").with(
                            {
                              // Use zip to avoid requiring a higher agent version.
                              "last_for": zip(
                                // Lowercase key since test data has this mixed. w00t!1
                                state.cursor.content_types_state_as_list.map(e, e.content_type.to_lower()),
                                state.cursor.content_types_state_as_list.map(e, e.content_created_at)
                              ),
                            }
                          ),
                        }
                      )
                    :
                      state
                  ).as(state, !state.?work.sub.enabled.orValue(false) ?
                    state
                  :
                    state.with(
                      min(duration("24h"), duration(state.base.batch_interval)).as(batch_interval,
                        (
                          // Calculate start and end time stamps.
                          (has(state.?cursor.last_for) && state.work.curr_type.to_lower() in state.cursor.last_for) ?
                            // Clamp to 7 days, the maximum age limit.
                            max(
                              now() - duration(state.base.maximum_age),
                              state.cursor.last_for[state.work.curr_type.to_lower()].parse_time(time_layout.RFC3339)
                            ).as(created_at,
                              {
                                "start": created_at,
                                "end": min(now(), created_at + batch_interval),
                              }
                            )
                          :
                            {
                              "start": now() - duration(state.base.list_contents_start_time),
                              "end": now() - duration(state.base.list_contents_start_time) + batch_interval,
                            }
                        ).as(time_range,
                          request(
                            "GET",
                            sprintf(
                              "%s/api/v1.0/%s/activity/feed/subscriptions/content?%s",
                              [
                                state.url.trim_right("/"),
                                state.base.tenant_id,
                                {
                                  "contentType": [state.work.curr_type],
                                  "PublisherIdentifier": [state.base.tenant_id],
                                  "startTime": [string(min(time_range.end - duration("1ms"), time_range.start))],
                                  "endTime": [string(time_range.end)],
                                }.format_query(),
                              ]
                            )
                          ).do_request().as(list_resp, (list_resp.StatusCode == 200) ?
                            list_resp.Body.decode_json().filter(e,
                              e.?contentExpiration.optMap(t, t.parse_time(time_layout.RFC3339) >= now()).orValue(true)
                            ).map(e,
                              e.with(
                                {"endTime": string(time_range.end)}
                              )
                            ).as(list,
                              {
                                "cursor": state.?cursor.orValue({}).with(
                                  {
                                    "last_for": state.?cursor.last_for.orValue({}).with(
                                      {state.work.curr_type.to_lower(): time_range.end}
                                    ),
                                  }
                                ),
                                "work": state.work.drop(["curr_content", "next_list"]).with(
                                  {
                                    ?"curr_content": list[?0],
                                    "todo_content": tail(list),
                                    ?"next_list": [
                                      // Work around non-conformance with HTTP header MIME standards.
                                      ?list_resp.Header.?Nextpageuri[0],
                                      ?list_resp.Header.?NextPageUri[0],
                                    ][?0],
                                  }
                                ),
                                "events": (
                                  list[?0].optMap(l,
                                    request(
                                      "GET",
                                      l.contentUri
                                    ).do_request().as(content_resp, (content_resp.StatusCode == 200) ?
                                      dyn(
                                        content_resp.Body.decode_json().map(e,
                                          {
                                            "o365audit": e,
                                            "event": {"original": e.encode_json()},
                                          }
                                        )
                                      ).orValue(dyn([]))
                                    :
                                      {
                                        "error": {
                                          "code": string(content_resp.StatusCode),
                                          "id": string(content_resp.Status),
                                          "message": "GET " + l.contentUri + ": " + (
                                            (size(content_resp.Body) != 0) ?
                                              string(content_resp.Body)
                                            :
                                              string(content_resp.Status) + " (" + string(content_resp.StatusCode) + ")"
                                          ),
                                        },
                                      }
                                    )
                                  )
                                ).orValue([]),
                              }
                            )
                          :
                            {
                              "events": {
                                "error": {
                                  "code": string(list_resp.StatusCode),
                                  "id": string(list_resp.Status),
                                  "message": "GET /activity/feed/subscriptions/content?contentType=" + state.work.curr_type + ": " + (
                                    (size(list_resp.Body) != 0) ?
                                      string(list_resp.Body)
                                    :
                                      string(list_resp.Status) + " (" + string(list_resp.StatusCode) + ")"
                                  ),
                                },
                              },
                            }
                          )
                        )
                      )
                    )
                  )
                )
            ).as(state,
              (
                // Ensure that we bring the current type up to the current time,
                // even if we did not get any content for the query period.
                has(state.?work.curr_type) && state.?cursor.last_for.optMap(last_for,
                  state.work.curr_type.to_lower().as(curr_type, curr_type in last_for ?
                      timestamp(last_for[curr_type]) < now - duration("1h")
                    :
                      false
                  )
                ).orValue(false) && !state.work.todo_type.exists(t, t == state.work.curr_type)
              ) ?
                state.with(
                  {
                    "work": state.work.with({"todo_type": [state.work.curr_type] + state.work.todo_type}),
                  }
                )
              :
                state
            ).as(state,
              state.with(
                {
                  "want_more": state.work.as(w,
                    size(w.?todo_type.orValue([])) != 0 || size(w.?todo_content.orValue([])) != 0 || w.?next_list.orValue("") != ""
                  ),
                }
              )
            ).as(state,
              // Make sure we complete the remaining work if we got
              // no events but the work lists are not empty.
              (state.want_more && type(state.events) == list && size(state.events) == 0) ?
                state.with(
                  {
                    "events": [{"retry": true}],
                  }
                )
              :
                state
            )
          publisher_pipeline.disable_host: true
          redact:
            fields:
                - base.tenant_id
          resource.timeout: 60s
          resource.tracer:
            enabled: false
            filename: ../../logs/cel/http-request-trace-*.ndjson
            maxbackups: 10
            maxsize: 5
          resource.url: https://manage.office.com
          state:
            base:
                batch_interval: 1h
                content_types: Audit.AzureActiveDirectory, Audit.Exchange, Audit.SharePoint, Audit.General, DLP.All
                list_contents_start_time: 167h55m
                maximum_age: 167h55m
                tenant_id: tenant-id
            want_more: false
          tags:
            - forwarded
            - o365-cel
      type: cel
      use_output: default
output_permissions:
    default:
        _elastic_agent_checks:
            cluster:
                - monitor
        _elastic_agent_monitoring:
            indices: []
        uuid-for-permissions-on-related-indices:
            indices:
                - names:
                    - logs-o365.audit-ep
                  privileges:
                    - auto_configure
                    - create_doc
secret_references:
    - {}
