interval: {{interval}}
auth.oauth2:
    client.id: {{client_id}}
    client.secret: {{client_secret}}
    provider: azure
    scopes:
{{#each token_scopes as |token_scope|}}
      - {{token_scope}}
{{/each}}
{{#if oauth_endpoint_params}}
    endpoint_params: {{oauth_endpoint_params}}
{{/if}}
{{#if token_url}}
    token_url: {{token_url}}/{{azure_tenant_id}}/oauth2/v2.0/token
{{else if azure_tenant_id}}
    azure.tenant_id: {{azure_tenant_id}}
{{/if}}

resource.url: {{url}}
{{#if resource_ssl}}
resource.ssl:
  {{resource_ssl}}
{{/if}}
{{#if resource_timeout}}
resource.timeout: {{resource_timeout}}
{{/if}}
{{#if resource_proxy_url}}
resource.proxy_url: {{resource_proxy_url}}
{{/if}}
{{#if resource_retry_max_attempts}}
resource.retry.max_attempts: {{resource_retry_max_attempts}}
{{/if}}
{{#if resource_retry_wait_min}}
resource.retry.wait_min: {{resource_retry_wait_min}}
{{/if}}
{{#if resource_retry_wait_max}}
resource.retry.wait_max: {{resource_retry_wait_max}}
{{/if}}
{{#if resource_redirect_forward_headers}}
resource.redirect.forward_headers: {{resource_redirect_forward_headers}}
{{/if}}
{{#if resource_redirect_headers_ban_list}}
resource.redirect.headers_ban_list:
{{#each resource_redirect_headers_ban_list as |item|}}
  - {{item}}
{{/each}}
{{/if}}
{{#if resource_redirect_max_redirects}}
resource.redirect.max_redirects: {{resource_redirect_max_redirects}}
{{/if}}
{{#if resource_rate_limit_limit}}
resource.rate_limit.limit: {{resource_rate_limit_limit}}
{{/if}}
{{#if resource_rate_limit_burst}}
resource.rate_limit.burst: {{resource_rate_limit_burst}}
{{/if}}

resource.tracer:
  enabled: {{enable_request_tracer}}
  filename: "../../logs/cel/http-request-trace-*.ndjson"
  maxbackups: 10
  maxsize: 5

state:
  want_more: false
  base:
    tenant_id: "{{azure_tenant_id}}"
    list_contents_start_time: "{{initial_interval}}"
    batch_interval: "{{batch_interval}}"
    maximum_age: "{{maximum_age}}"
    content_types: "{{content_types}}"

redact:
  fields:
    - base.tenant_id

program: |-
  state.with(
    state.?work.todo_content[0].hasValue() ?
      // Do any outstanding content collection to do.
      state.work.todo_content.filter(e,
        // Filter out stale elements.
        timestamp(e.contentExpiration) > now()
      ).as(list, (size(list) != 0) ?
        list.map(e,
          timestamp(e.endTime)
        ).min().as(min,
          list.filter(e, timestamp(e.endTime) == min)[0]
        ).as(oldest,
          {
            "curr_content": oldest,
            "todo_content": list.filter(e, e.contentUri != oldest.contentUri),
          }
        )
      :
        {"todo_content": []}
      ).as(w, !has(w.curr_content) ?
        {
          "work": state.work.drop("curr_content").with(w),
          "events": [],
        }
      :
        {
          "work": state.work.with(
            {
              "curr_content": w.curr_content,
              "todo_content": w.todo_content,
            }
          ),
          "events": request(
            "GET",
            w.curr_content.contentUri
          ).do_request().as(content_resp, (content_resp.StatusCode == 200) ?
            dyn(
              content_resp.Body.decode_json().map(e,
                {
                  "o365audit": e,
                  "event": {"original": e.encode_json()},
                }
              )
            ).orValue(dyn([]))
          :
            {
              "error": {
                "code": string(content_resp.StatusCode),
                "id": string(content_resp.Status),
                "message": "GET " + w.curr_content.contentUri + ": " + (
                  (size(content_resp.Body) != 0) ?
                    string(content_resp.Body)
                  :
                    string(content_resp.Status) + " (" + string(content_resp.StatusCode) + ")"
                ),
              },
            }
          ),
        }
      )
    : has(state.?work.next_list) ?
      // Follow the next list link.
      request(
        "GET",
        state.work.next_list
      ).do_request().as(list_resp, (list_resp.StatusCode == 200) ?
        list_resp.Body.decode_json().as(list,
          (list + state.work.todo_content).filter(e,
            // Filter out stale elements.
            e.?contentExpiration.optMap(t, t.parse_time(time_layout.RFC3339) >= now()).orValue(true)
          ).map(e,
            // Record the cursor update time for the content.
            has(e.endTime) ?
              e
            :
              e.with(
                {
                  "endTime": state.work.next_list.parse_url().RawQuery.parse_query().endTime[0],
                }
              )
          ).as(list, (size(list) != 0) ?
            list.map(e,
              timestamp(e.endTime)
            ).min().as(min,
              // This is known to exist since a non-empty list must have a minimum.
              list.filter(e, timestamp(e.endTime) == min)[0]
            ).as(oldest,
              {
                "curr_content": oldest,
                "todo_content": list.filter(e, e.contentUri != oldest.contentUri),
              }
            )
          :
            {"todo_content": []}
          )
        ).as(w, !has(w.curr_content) ?
          {
            "work": state.work.drop("curr_content").with(w),
            "events": [],
          }
        :
          {
            "cursor": state.?cursor.orValue({}).with(
              {
                "last_for": state.?cursor.last_for.orValue({}).with(
                  w.curr_content.as(l,
                    {l.contentType.to_lower(): l.endTime}
                  )
                ),
              }
            ),
            "work": state.work.drop(["curr_content", "next_list"]).with(
              {
                "curr_content": w.curr_content,
                "todo_content": w.todo_content,
                ?"next_list": [
                  // Work around non-conformance with HTTP header MIME standards.
                  ?list_resp.Header.?Nextpageuri[0],
                  ?list_resp.Header.?NextPageUri[0],
                ][?0],
              }
            ),
            "events": w.curr_content.as(l,
              request(
                "GET",
                l.contentUri
              ).do_request().as(content_resp, (content_resp.StatusCode == 200) ?
                dyn(
                  content_resp.Body.decode_json().map(e,
                    {
                      "o365audit": e,
                      "event": {"original": e.encode_json()},
                    }
                  )
                ).orValue(dyn([]))
              :
                {
                  "error": {
                    "code": string(content_resp.StatusCode),
                    "id": string(content_resp.Status),
                    "message": "GET " + l.contentUri + ": " + (
                      (size(content_resp.Body) != 0) ?
                        string(content_resp.Body)
                      :
                        string(content_resp.Status) + " (" + string(content_resp.StatusCode) + ")"
                    ),
                  },
                }
              )
            ),
          }
        )
      :
        {
          "error": {
            "code": string(list_resp.StatusCode),
            "id": string(list_resp.Status),
            "message": "GET " + state.work.next_list + ": " + (
              (size(list_resp.Body) != 0) ?
                string(list_resp.Body)
              :
                string(list_resp.Status) + " (" + string(list_resp.StatusCode) + ")"
            ),
          },
        }
      )
    :
      (
        state.?work.todo_type[0].hasValue() ?
          // Consume one work unit and get ready to use it.
          {
            "curr_type": state.work.todo_type[0],
            "todo_type": tail(state.work.todo_type),
          }
        :
          // No work todo, so get items from the config.
          state.base.content_types.split(",").map(t, t.trim_space()).as(todo_type,
            {
              ?"curr_type": todo_type[?0],
              "todo_type": tail(todo_type),
            }
          )
      ).as(work,
        // Get subscription details.
        state.with(
          !has(work.curr_type) ?
            // No current work item, so finish.
            {}
          :
            {
              "base": state.base,
              "work": work.with(
                {
                  "sub": request(
                    "POST",
                    sprintf(
                      "%s/api/v1.0/%s/activity/feed/subscriptions/start?%s",
                      [
                        state.url.trim_right("/"),
                        state.base.tenant_id,
                        {
                          "contentType": [work.curr_type],
                          "PublisherIdentifier": [state.base.tenant_id],
                        }.format_query(),
                      ]
                    )
                  ).do_request().as(sub_resp, (sub_resp.StatusCode == 200 || sub_resp.StatusCode == 400) ?
                    sub_resp.Body.decode_json().as(sub,
                      {
                        "type": work.curr_type, // If we get an AF20024, sub.contentType will be absent.
                        "enabled": sub.?status == optional.of("enabled") || sub.?error.code == optional.of("AF20024"),
                      }
                    )
                  :
                    {
                      "error": {
                        "code": string(sub_resp.StatusCode),
                        "id": string(sub_resp.Status),
                        "message": "POST /activity/feed/subscriptions/start?contentType=" + work.curr_type + ": " + (
                          (size(sub_resp.Body) != 0) ?
                            string(sub_resp.Body)
                          :
                            string(sub_resp.Status) + " (" + string(sub_resp.StatusCode) + ")"
                        ),
                      },
                    }
                  ),
                }
              ),
            }
        )
      ).as(state, !has(state.base) ?
        // No current work item above, so finish.
        {}
      : has(state.error) ?
        // Getting subscription detail failed.
        state
      :
        (
          // This exists purely to rewrite the cursor from the original
          // list format to a map. This will only happen once; we can
          // remove it when we know there are no users on the previous
          // version. This is never.
          has(state.?cursor.content_types_state_as_list) ?
            state.with(
              {
                "cursor": state.cursor.drop("content_types_state_as_list").with(
                  {
                    // Use zip to avoid requiring a higher agent version.
                    "last_for": zip(
                      // Lowercase key since test data has this mixed. w00t!1
                      state.cursor.content_types_state_as_list.map(e, e.content_type.to_lower()),
                      state.cursor.content_types_state_as_list.map(e, e.content_created_at)
                    ),
                  }
                ),
              }
            )
          :
            state
        ).as(state, !state.?work.sub.enabled.orValue(false) ?
          state
        :
          state.with(
            min(duration("24h"), duration(state.base.batch_interval)).as(batch_interval,
              (
                // Calculate start and end time stamps.
                (has(state.?cursor.last_for) && state.work.curr_type.to_lower() in state.cursor.last_for) ?
                  // Clamp to 7 days, the maximum age limit.
                  max(
                    now() - duration(state.base.maximum_age),
                    state.cursor.last_for[state.work.curr_type.to_lower()].parse_time(time_layout.RFC3339)
                  ).as(created_at,
                    {
                      "start": created_at,
                      "end": created_at + batch_interval,
                    }
                  )
                :
                  {
                    "start": now() - duration(state.base.list_contents_start_time),
                    "end": now() - duration(state.base.list_contents_start_time) + batch_interval,
                  }
              ).as(time_range,
                request(
                  "GET",
                  sprintf(
                    "%s/api/v1.0/%s/activity/feed/subscriptions/content?%s",
                    [
                      state.url.trim_right("/"),
                      state.base.tenant_id,
                      {
                        "contentType": [state.work.curr_type],
                        "PublisherIdentifier": [state.base.tenant_id],
                        "startTime": [string(min(now() - duration("1ms"), time_range.start))],
                        "endTime": [string(min(now(), time_range.end))],
                      }.format_query(),
                    ]
                  )
                ).do_request().as(list_resp, (list_resp.StatusCode == 200) ?
                  list_resp.Body.decode_json().filter(e,
                    e.?contentExpiration.optMap(t, t.parse_time(time_layout.RFC3339) >= now()).orValue(true)
                  ).map(e,
                    e.with(
                      {"endTime": string(time_range.end)}
                    )
                  ).as(list,
                    {
                      "cursor": state.?cursor.orValue({}).with(
                        {
                          "last_for": state.?cursor.last_for.orValue({}).with(
                            {state.work.curr_type.to_lower(): time_range.end}
                          ),
                        }
                      ),
                      "work": state.work.drop(["curr_content", "next_list"]).with(
                        {
                          ?"curr_content": list[?0],
                          "todo_content": tail(list),
                          ?"next_list": [
                            // Work around non-conformance with HTTP header MIME standards.
                            ?list_resp.Header.?Nextpageuri[0],
                            ?list_resp.Header.?NextPageUri[0],
                          ][?0],
                        }
                      ),
                      "events": (
                        list[?0].optMap(l,
                          request(
                            "GET",
                            l.contentUri
                          ).do_request().as(content_resp, (content_resp.StatusCode == 200) ?
                            dyn(
                              content_resp.Body.decode_json().map(e,
                                {
                                  "o365audit": e,
                                  "event": {"original": e.encode_json()},
                                }
                              )
                            ).orValue(dyn([]))
                          :
                            {
                              "error": {
                                "code": string(content_resp.StatusCode),
                                "id": string(content_resp.Status),
                                "message": "GET " + l.contentUri + ": " + (
                                  (size(content_resp.Body) != 0) ?
                                    string(content_resp.Body)
                                  :
                                    string(content_resp.Status) + " (" + string(content_resp.StatusCode) + ")"
                                ),
                              },
                            }
                          )
                        )
                      ).orValue([]),
                    }
                  )
                :
                  {
                    "error": {
                      "code": string(list_resp.StatusCode),
                      "id": string(list_resp.Status),
                      "message": "GET /activity/feed/subscriptions/content?contentType=" + state.work.curr_type + ": " + (
                        (size(list_resp.Body) != 0) ?
                          string(list_resp.Body)
                        :
                          string(list_resp.Status) + " (" + string(list_resp.StatusCode) + ")"
                      ),
                    },
                  }
                )
              )
            )
          )
        )
      )
  ).as(state,
    (
      // Ensure that we bring the current type up to the current time,
      // even if we did not get any content for the query period.
      timestamp(state.cursor.last_for[state.work.curr_type.to_lower()]) < now - duration("1h") &&
      !state.work.todo_type.exists(t, t == state.work.curr_type)
    ) ?
      state.with(
        {
          "work": state.work.with({"todo_type": [state.work.curr_type] + state.work.todo_type}),
        }
      )
    :
      state
  ).as(state,
    state.with(
      {
        "want_more": state.work.as(w,
          size(w.todo_type) != 0 || size(w.todo_content) != 0 || w.?next_list.orValue("") != ""
        ),
      }
    )
  ).as(state,
    // Make sure we complete the remaining work if we got
    // no events but the work lists are not empty.
    (state.want_more && type(state.events) == list && size(state.events) == 0) ?
      state.with(
        {
          "events": [{"retry": true}],
        }
      )
    :
      state
  )
{{#if tags}}
tags:
{{#if preserve_original_event}}
  - preserve_original_event
{{/if}}
{{#each tags as |tag|}}
  - {{tag}}
{{/each}}
{{/if}}
{{#contains "forwarded" tags}}
publisher_pipeline.disable_host: true
{{/contains}}
{{#if processors}}
processors:
{{processors}}
{{/if}}
