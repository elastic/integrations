config_version: 2
resource.url: {{url}}
{{#if oauth2}}
auth.oauth2: {{oauth2}}
{{/if}}
{{#if ssl}}
resource.ssl: {{ssl}}
{{/if}}
{{#if proxy_url}}
resource.proxy_url: {{proxy_url}}
{{/if}}
interval: {{interval}}
max_executions: {{max_executions}}
resource.timeout: {{http_client_timeout}}
tags:
{{#if preserve_original_event}}
  - preserve_original_event
{{/if}}
{{#each tags as |tag|}}
  - {{tag}}
{{/each}}
{{#contains "forwarded" tags}}
publisher_pipeline.disable_host: true
{{/contains}}
{{#if enable_request_tracer}}
resource.tracer.filename: "../../logs/opencti-indicator/http-request-trace-*.ndjson"
resource.tracer.maxbackups: 5
{{/if}}
{{#if processors}}
processors:
{{processors}}
{{/if}}
fields_under_root: true
keep_null: true
fields:
  _conf:
    url: {{url}}
program: |
  request(
        "POST",
        state.url.trim_suffix("graphql").trim_suffix("/") + "/graphql"
      ).with({
        "Header": ({
          "Content-Type": ["application/json"]
        }).with(
          has(state.api_key) && size(state.api_key) > 0 ?
            { "Authorization": ["Bearer " + state.api_key] }
          :
            {}
        )
      }).with({
        "Body": {
          "query": state.query,
          "variables": {
        "after": has(state.cursor) && has(state.cursor.value) ? state.cursor.value : null,
        "first": state.page_size,
        "orderBy": "modified",
        "orderMode": "asc",
        "filters": (
          // Build the FilterGroup object
          (
            (has(state.pattern_types) && size(state.pattern_types) > 0) ||
            (has(state.indicator_types) && size(state.indicator_types) > 0) ||
            (has(state.revoked) && state.revoked != null) ||
            (has(state.valid_from_start) && state.valid_from_start != null) ||
            (has(state.valid_until_end) && state.valid_until_end != null) ||
            (has(state.label_ids) && size(state.label_ids) > 0) ||
            (has(state.confidence_min) && state.confidence_min != null) ||
            (has(state.author_ids) && size(state.author_ids) > 0) ||
            (has(state.creator_ids) && size(state.creator_ids) > 0) ||
            (has(state.created_after) && state.created_after != null) ||
            (has(state.modified_after) && state.modified_after != null) ||
            (has(state.last_modified) && state.last_modified != null) ||
            (has(state.marking_ids) && size(state.marking_ids) > 0)
          ) ?
          {
            "mode": "and",
            "filters": (
              // Always filter for Indicator entity type
              [{"key": "entity_type", "values": ["Indicator"], "operator": "eq"}] +
              (has(state.pattern_types) && size(state.pattern_types) > 0 ? 
                [{"key": "pattern_type", "values": state.pattern_types, "operator": "eq", "mode": "or"}] : []
              ) +
              (has(state.indicator_types) && size(state.indicator_types) > 0 ? 
                [{"key": "indicator_types", "values": state.indicator_types, "operator": "eq", "mode": "or"}] : []
              ) +
              (has(state.revoked) && state.revoked != null ? 
                [{"key": "revoked", "values": [state.revoked == "true"], "operator": "eq"}] : []
              ) +
              (has(state.valid_from_start) && state.valid_from_start != null ? 
                [{"key": "valid_from", "values": [state.valid_from_start], "operator": "gte"}] : []
              ) +
              (has(state.valid_until_end) && state.valid_until_end != null ? 
                [{"key": "valid_until", "values": [state.valid_until_end], "operator": "lte"}] : []
              ) +
              (has(state.label_ids) && size(state.label_ids) > 0 ? 
                [{"key": "objectLabel", "values": state.label_ids, "operator": "eq", "mode": "or"}] : []
              ) +
              (has(state.confidence_min) && state.confidence_min != null ? 
                [{"key": "confidence", "values": [string(state.confidence_min)], "operator": "gte"}] : []
              ) +
              (has(state.author_ids) && size(state.author_ids) > 0 ? 
                [{"key": "createdBy", "values": state.author_ids, "operator": "eq", "mode": "or"}] : []
              ) +
              (has(state.creator_ids) && size(state.creator_ids) > 0 ? 
                [{"key": "creator_id", "values": state.creator_ids, "operator": "eq", "mode": "or"}] : []
              ) +
              (has(state.created_after) && state.created_after != null ? 
                [{"key": "created", "values": [state.created_after], "operator": "gt"}] : []
              ) +
              (has(state.last_modified) && state.last_modified != null ? 
                [{"key": "updated_at", "values": [state.last_modified], "operator": "gt"}] : 
                (has(state.modified_after) && state.modified_after != null ? 
                  [{"key": "updated_at", "values": [state.modified_after], "operator": "gt"}] : []
                )
              ) +
              (has(state.marking_ids) && size(state.marking_ids) > 0 ? 
                [{"key": "objectMarking", "values": state.marking_ids, "operator": "eq", "mode": "or"}] : []
              )
            ),
            "filterGroups": []
          } : 
          // Default filter: always filter for Indicator entity type
          {
            "mode": "and",
            "filters": [{"key": "entity_type", "values": ["Indicator"], "operator": "eq"}],
            "filterGroups": []
          }
        )
      }
    }.encode_json()
  }).do_request().as(resp,
    bytes(resp.Body).decode_json().as(body,
      has(body.errors) && size(body.errors) > 0 ?
        state.with({
          "events": [{
            "error": { "message": body.errors.map(e, e.message) },
            "event": { "original": body.encode_json() }
          }],
          "last_modified": state.?last_modified.orValue(null)
        })
      :
        state.with({
          "events": body.data.indicators.edges.map(e, e.node.with(
            has(state.preserve_original_event) && state.preserve_original_event ?
              { "event": { "original": e.node.encode_json() } }
            :
              {}
          )),
          "want_more": body.data.indicators.pageInfo.hasNextPage,
          "cursor": { "value": body.data.indicators.pageInfo.endCursor },
          "last_modified": has(body.data.indicators.edges) && body.data.indicators.edges.size() > 0 ? 
            body.data.indicators.edges.map(e, e.node.modified).max() 
          : 
            state.?last_modified.orValue(null)
        })
      )
    )
redact:
  fields:
    - api_key
state:
  url: {{url}}
  api_key: {{api_key}}
  page_size: {{page_size}}
  preserve_original_event: {{preserve_original_event}}
  want_more: false
  # Track last modified timestamp to avoid re-fetching
  last_modified: null
  # Filter configuration
  pattern_types: {{#if pattern_types}}{{pattern_types}}{{else}}[]{{/if}}
  indicator_types: {{#if indicator_types}}{{indicator_types}}{{else}}[]{{/if}}
  revoked: {{#if revoked}}"{{revoked}}"{{else}}null{{/if}}
  valid_from_start: {{#if valid_from_start}}"{{valid_from_start}}"{{else}}null{{/if}}
  valid_until_end: {{#if valid_until_end}}"{{valid_until_end}}"{{else}}null{{/if}}
  label_ids: {{#if label_ids}}{{label_ids}}{{else}}[]{{/if}}
  confidence_min: {{#if confidence_min}}{{confidence_min}}{{else}}null{{/if}}
  author_ids: {{#if author_ids}}{{author_ids}}{{else}}[]{{/if}}
  creator_ids: {{#if creator_ids}}{{creator_ids}}{{else}}[]{{/if}}
  created_after: {{#if created_after}}"{{created_after}}"{{else}}null{{/if}}
  modified_after: {{#if modified_after}}"{{modified_after}}"{{else}}null{{/if}}
  marking_ids: {{#if marking_ids}}{{marking_ids}}{{else}}[]{{/if}}
  # How to work with this API: https://docs.opencti.io/latest/deployment/integrations/#graphql-api
  # Relevant schema source: https://github.com/OpenCTI-Platform/opencti/blob/master/opencti-platform/opencti-graphql/config/schema/opencti.graphql
  query: |

    query IndicatorsLinesPaginationQuery(
      $search: String
      $filters: FilterGroup
      $first: Int!
      $after: ID
      $orderBy: IndicatorsOrdering
      $orderMode: OrderingMode
    ) {
      indicators(
        search: $search
        filters: $filters
        first: $first
        after: $after
        orderBy: $orderBy
        orderMode: $orderMode
      ) {
        edges {
          node {
            ...IndicatorLine_node
          }
          cursor
        }
        pageInfo {
          endCursor
          hasNextPage
          globalCount
        }
      }
    }
    fragment IndicatorLine_node on Indicator {
      id
      standard_id
      is_inferred
      revoked
      confidence
      lang
      created
      modified
      pattern_type
      pattern_version
      pattern
      name
      description
      valid_from
      valid_until
      x_opencti_score
      x_opencti_detection
      x_opencti_main_observable_type
      createdBy {
        identity_class
        name
      }
      objectMarking {
        definition_type
        definition
      }
      objectLabel {
        value
      }
      killChainPhases {
        phase_name
        kill_chain_name
      }
      externalReferences(first: 100) {
        edges {
          node {
            external_id
            source_name
            url
            description
          }
        }
      }
      observables(first: 100) { # StixCyberObservableConnection
        edges {
          node {
            id
            standard_id
            entity_type
            observable_value
            ... on AutonomousSystem {
              number # Int!
              name # String
              rir # String
            }
            ... on Directory {
              path # String!
              path_enc # String
              ctime # DateTime
              mtime # DateTime
              atime # DateTime
            }
            ... on DomainName {
              value # String!
            }
            ... on EmailAddr {
              value # String
              display_name # String
            }
            ... on EmailMessage {
              is_multipart # Boolean
              attribute_date # DateTime
              content_type # String
              message_id # String
              subject # String
              received_lines # [String]
              body # String
            }
            ... on EmailMimePartType {
              body # String
              content_type # String
              content_disposition # String
            }
            ... on Artifact {
              hashes { # [Hash]
                algorithm
                hash
              }
              mime_type # String
              payload_bin # String
              url # String
              encryption_algorithm # String
              decryption_key # String
              x_opencti_additional_names # [String]
            }
            ... on StixFile {
              hashes { # [Hash]
                algorithm
                hash
              }
              size # Int
              name # String
              name_enc # String
              magic_number_hex # String
              mime_type # String
              ctime # DateTime
              mtime # DateTime
              atime # DateTime
              x_opencti_additional_names # [String]
              obsContent { # Artifact
                payload_bin # String
                url # String
                encryption_algorithm # String
                decryption_key # String
              }
            }
            ... on X509Certificate {
              hashes { # [Hash]
                algorithm
                hash
              }
              is_self_signed # Boolean
              version # String
              serial_number # String
              signature_algorithm # String
              issuer # String
              subject # String
              subject_public_key_algorithm # String
              subject_public_key_modulus # String
              subject_public_key_exponent # Int
              validity_not_before # DateTime
              validity_not_after # DateTime
              basic_constraints # String
              name_constraints # String
              policy_constraints # String
              key_usage # String
              extended_key_usage # String
              subject_key_identifier # String
              authority_key_identifier # String
              subject_alternative_name # String
              issuer_alternative_name # String
              subject_directory_attributes # String
              crl_distribution_points # String
              inhibit_any_policy # String
              private_key_usage_period_not_before # DateTime
              private_key_usage_period_not_after # DateTime
              certificate_policies # String
              policy_mappings # String
            }
            ... on IPv4Addr {
              value # String
            }
            ... on IPv6Addr {
              value # String
            }
            ... on MacAddr {
              value # String
            }
            ... on Mutex {
              name # String
            }
            ... on NetworkTraffic {
              start # DateTime
              end # DateTime
              is_active # Boolean
              src_port # Int
              dst_port # Int
              protocols # [String]
              src_byte_count # Int
              dst_byte_count # Int
              src_packets # Int
              dst_packets # Int
            }
            ... on Process {
              is_hidden # Boolean
              pid # Int
              created_time # DateTime
              cwd # String
              x_opencti_description # String
              command_line # String!
              environment_variables # [String]
              aslr_enabled # Boolean
              dep_enabled # Boolean
              priority # String
              owner_sid # String
              window_title # String
              startup_info { # [Dictionary]
                key
                value
              }
              integrity_level # String
              service_name # String
              descriptions # [String]
              display_name # String
              group_name # String
              start_type # String
              service_type # String
              service_status # String
              serviceDlls { # StixFileConnection
                edges {
                  node {
                    hashes { # [Hash]
                      algorithm
                      hash
                    }
                    size # Int
                    name # String
                    name_enc # String
                    magic_number_hex # String
                    mime_type # String
                    ctime # DateTime
                    mtime # DateTime
                    atime # DateTime
                    x_opencti_additional_names # [String]
                    obsContent { # Artifact
                      payload_bin # String
                      url # String
                      encryption_algorithm # String
                      decryption_key # String
                    }
                  }
                }
              }
            }
            ... on Software {
              name # String
              cpe # String
              swid # String
              languages # [String]
              vendor # String
              version # String
            }
            ... on Url {
              value # String
            }
            ... on UserAccount {
              user_id # String
              credential # String
              account_login # String
              account_type # String
              display_name # String
              is_service_account # Boolean
              is_privileged # Boolean
              can_escalate_privs # Boolean
              is_disabled # Boolean
              account_created # DateTime
              account_expires # DateTime
              credential_last_changed # DateTime
              account_first_login # DateTime
              account_last_login # DateTime
            }
            ... on WindowsRegistryKey {
              attribute_key # String
              modified_time # DateTime
              number_of_subkeys # Int
            }
            ... on WindowsRegistryValueType {
              name # String
              data # String
              data_type # String
            }
            ... on CryptographicKey {
              value # String
            }
            ... on CryptocurrencyWallet {
              value # String
            }
            ... on Hostname {
              value # String
            }
            ... on Text {
              value # String
            }
            ... on UserAgent {
              value # String
            }
            ... on BankAccount {
              iban # String
              bic # String
              account_number # String
            }
            ... on PhoneNumber {
              value # String
            }
            ... on PaymentCard {
              card_number # String!
              expiration_date # DateTime
              cvv # Int
              holder_name # String
            }
            ... on MediaContent {
              title # String
              content # String
              media_category # String
              url # String!
              publication_date # DateTime
            }
          }
        }
        pageInfo {
          globalCount
        }
      }
    }
