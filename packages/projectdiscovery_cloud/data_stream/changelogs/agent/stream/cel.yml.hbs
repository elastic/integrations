config_version: 2
interval: {{interval}}
resource.max_executions: 1000

# HTTP client settings (not visible inside CEL)
resource.url: {{base_url}}
resource.timeout: {{http_client_timeout}}

# NEW â€” drive request tracing from var
resource.tracer:
  enabled: {{enable_request_tracer}}
  filename: "../../logs/cel/http-request-trace-*.ndjson"
  maxbackups: 5

# Avoid host enrichment (useful for agentless)
publisher_pipeline.disable_host: true

# Redact these keys in tracer logs by name
redact:
  fields:
    - api_key
    - team_id

# Everything the CEL program needs must be under `state`
state:
  url: {{base_url}}
  api_key: "{{api_key}}"
  team_id: "{{team_id}}"
  offset: 0
  batch_size: {{batch_size}}
  # force string; when unset this becomes ""
  time_window: "{{time_window}}"

program: |-
  state.?cursor.?offset.orValue(int(state.offset)).as(current_offset,
    state.with(
      {
        "base": state.url.trim_right("/") + "/v1/scans/vuln/changelogs",
        "q": {
          "limit": [string(state.batch_size)],
          "offset": [string(current_offset)],
          "event_type": ["vuln_status"],
          "sort_desc": ["created_at"],
          ?"time": (state.time_window != "") ?
            optional.of([string(state.time_window)])
          :
            optional.none(),
        },
      }.as(p,
        request(
          "GET",
          p.base + "?" + p.q.format_query()
        ).with(
          {
            "Header": {
              ?"X-API-Key": ("api_key" in state && string(state["api_key"]) != "") ?
                optional.of([string(state["api_key"])]) :
                optional.none(),
              ?"X-Team-Id": ("team_id" in state && string(state["team_id"]) != "") ?
                optional.of([string(state["team_id"])]) :
                optional.none(),
            },
          }
        ).do_request().as(resp,
          {
            "status_ok": resp.StatusCode == 200,
            "resp": resp,
            "body": (size(resp.Body) != 0) ? bytes(resp.Body).decode_json() : {}
          }.as(vars,
            {
              "items": (vars.status_ok && ("data" in vars.body) && vars.body["data"] != null) ? vars.body["data"] : []
            }.as(x,
              {
                "events": x.items.map(e, {"message": e.encode_json()}),
                "cursor": { "offset": int(current_offset) + x.items.size() },
                "want_more": vars.status_ok && x.items.size() == int(state.batch_size),
                ?"error": vars.status_ok ?
                  optional.none() :
                  optional.of({"message": "HTTP " + string(vars.resp.StatusCode) + " " + string(vars.resp.Body)}),
                "api_key": ("api_key" in state) ? state["api_key"] : "",
                "team_id": ("team_id" in state) ? state["team_id"] : "",
                "url": ("url" in state) ? state["url"] : "",
                "batch_size": state.batch_size,
                "time_window": state.time_window,
              }
            )
          )
        )
      )
    )
  )
tags:
  - projectdiscovery-cloud
  - vulnerability
  - changelogs
  - forwarded
