config_version: 2
interval: {{interval}}

# HTTP client settings (not visible inside CEL)
resource.url: {{base_url}}
resource.timeout: {{http_client_timeout}}
{{#if ssl}}
resource.ssl: {{ssl}}
{{/if}}

# NEW â€” drive request tracing from var
resource.tracer:
  enabled: {{enable_request_tracer}}
  filename: "../../logs/cel/http-request-trace-*.ndjson"
  maxbackups: 5

# Redact these keys in tracer logs by name
redact:
  fields:
    - api_key
    - team_id

# Everything the CEL program needs must be under `state`
state:
  url: {{base_url}}
  api_key: "{{api_key}}"
  team_id: "{{team_id}}"
  offset: 0
  batch_size: {{batch_size}}
  # force string; when unset this becomes ""
  time_window: "{{time_window}}"

program: |-
  // Early validation: fail fast if required credentials are missing
  !has(state.api_key) || string(state.api_key) == "" ?
    {
      "events": [],
      "want_more": false,
      "error": {"message": "api_key is required but was not provided"}
    }
  : !has(state.team_id) || string(state.team_id) == "" ?
    {
      "events": [],
      "want_more": false,
      "error": {"message": "team_id is required but was not provided"}
    }
  :
    state.?cursor.?offset.orValue(int(state.offset)).as(current_offset,
      state.with(
        {
          "base": state.url.trim_right("/") + "/v1/scans/vuln/changelogs",
          "query": {
            "limit": [string(state.batch_size)],
            "offset": [string(current_offset)],
            "event_type": ["vuln_status"],
            "sort_desc": ["created_at"],
            ?"time": (state.time_window != "") ?
              optional.of([string(state.time_window)])
            :
              optional.none()
          }
        }.as(req,
          request(
            "GET",
            req.base + "?" + req.query.format_query()
          ).with(
            {
              "Header": {
                "X-API-Key": [string(state.api_key)],
                "X-Team-Id": [string(state.team_id)]
              }
            }
          ).do_request().as(resp,
          {
            "status_ok": resp.StatusCode == 200,
            "resp": resp,
            "body": (size(resp.Body) != 0) ? bytes(resp.Body).decode_json() : {}
          }.as(vars,
            {
              "items": (vars.status_ok && ("data" in vars.body) && vars.body["data"] != null) ? vars.body["data"] : []
            }.as(x,
              {
                "events": x.items.map(e, {"message": e.encode_json()}),
                "cursor": { "offset": int(current_offset) + x.items.size() },
                "want_more": vars.status_ok && x.items.size() == int(state.batch_size),
                ?"error": vars.status_ok ?
                  optional.none() :
                  optional.of({"message": "HTTP " + string(vars.resp.StatusCode) + " " + string(vars.resp.Body)}),
                "api_key": ("api_key" in state) ? state["api_key"] : "",
                "team_id": ("team_id" in state) ? state["team_id"] : "",
                "url": ("url" in state) ? state["url"] : "",
                "batch_size": state.batch_size,
                "time_window": state.time_window
              }
            )
          )
        )
      )
    )
  )
tags:
  - projectdiscovery-cloud
  - vulnerability
  - changelogs
  - forwarded
