{
    "attributes": {
        "author": [
            "Elastic"
        ],
        "description": "This rule detects potential initial access activity where an adversary uploads a web shell or malicious script to a web server via a file upload mechanism (e.g., through a web form using multipart/form-data), followed by a GET or POST request to access the uploaded file. By checking the body content of HTTP requests for file upload indicators such as \"Content-Disposition: form-data\" and \"filename=\", the rule identifies suspicious upload activities. This sequence of actions is commonly used by attackers to gain and maintain access to compromised web servers.",
        "from": "now-9m",
        "index": [
            "logs-endpoint.events.*",
            "logs-network_traffic.*"
        ],
        "language": "eql",
        "license": "Elastic License v2",
        "name": "Initial Access via File Upload Followed by GET Request",
        "note": "## Triage and analysis\n\n> **Disclaimer**:\n> This investigation guide was created using generative AI technology and has been reviewed to improve its accuracy and relevance. While every effort has been made to ensure its quality, we recommend validating the content and adapting it to suit your specific environment and operational needs.\n\n### Investigating Initial Access via File Upload Followed by GET Request\n\nThis rule flags a common initial-access pattern: a multipart/form-data upload that drops a dynamic web script on a server, followed shortly by a request to execute that file and establish a foothold. Attackers exploit a permissive upload form to plant shell.php or shell.jsp in an uploads or temp directory, then immediately request it to spawn a web shell, enumerate files, and run commands\u2014often leveraging redirects or 2xx/3xx responses that indicate successful placement and access.\n\n### Possible investigation steps\n\n- Correlate the upload transaction with the server-side file creation and the subsequent access to the same resource, matching timestamps, source IP, and path, and follow any redirects to the final executed file.\n- Retrieve the uploaded artifact from disk, verify it sits in a web-accessible location, inspect content for web shell traits (eval/system/exec, obfuscation, password gates), and record hashes.\n- Examine server process telemetry immediately after the access for interpreter or shell spawns and unexpected outbound connections originating from web server workers.\n- Review application logs and access context to determine whether the upload was authenticated, which account or session performed it, and whether user-agent, referer, or headers deviate from normal clients.\n- Broaden the timeline to identify related uploads, file renames, or repeated requests from the same actor, including parameterized calls that suggest command execution or directory enumeration.\n\n### False positive analysis\n\n- An authenticated administrator installs a legitimate plugin or module via the application\u2019s upload form, which unpacks or renames .php or .jsp files and then auto-loads a setup page, producing the multipart upload, file creation/rename, and immediate GET pattern.\n- Automated deployment or QA routines upload and deploy a .war or server-side script through a web-based admin interface and then perform health-check or warm-up requests, resulting in the same multipart upload, server-side file creation, and follow-up GET sequence.\n\n### Response and remediation\n\n- Immediately block access to the uploaded script that was invoked via GET/POST (e.g., /uploads/shell.php) and the source IPs that executed it, restrict the site to allowlisted IPs or maintenance mode, and temporarily disable the upload endpoint.\n- Quarantine and remove the uploaded web shell and any additional executable scripts or WARs in web-accessible directories (uploads, webroot, temp), terminate interpreter or shell processes spawned by the web server account (www-data/nginx/w3wp/tomcat), and revert malicious .htaccess/web.config rewrites.\n- Hunt for persistence and lateral-movement artifacts created after the upload, including recent .php/.jsp/.cgi file creations or renames in static asset folders, cron/systemd tasks, startup scripts, unauthorized admin users or plugins, and remove them.\n- Restore altered application files from known-good backups or redeploy a clean container/VM, rotate database and API credentials stored in config files or environment variables, invalidate active sessions, and only re-enable uploads after confirming execution is blocked in upload directories.\n- Escalate to incident command and privacy/legal if you observe command execution parameters on the uploaded page (?cmd=, ?exec=), shells spawning (/bin/sh, powershell.exe), database dumps, or outbound callbacks from web server processes to external hosts.\n- Harden by storing uploads outside the webroot, denying execution in upload paths (disable PHP/CGI handlers and set noexec permissions), enforcing strict extension/MIME allowlists and AV/sandbox scanning for multipart/form-data, enabling file-integrity alerts on new .php/.jsp in served paths, and deploying WAF rules to block direct requests to uploaded executables.\n",
        "query": "sequence by agent.id with maxspan=5m\n  [network where\n   data_stream.dataset == \"network_traffic.http\" and\n   http.request.method in (\"POST\", \"PUT\") and\n   /* We can restrict to 200 in the future, but I prefer to broaden the scope and decrease it later if necessary */\n   http.response.status_code in (200, 201, 204, 301, 302, 303, 409) and\n   /* These should detect most common file upload activities, adhering to browser standards */\n   http.request.body.content like \"*Content-Disposition: form-data*\" and\n   http.request.body.content like \"*filename=*\"\n   /* May add a lower/upper boundary limit to reduce FPs in the future, e.g.\n   and http.request.body.bytes >= 500\n   */\n  ]\n  [file where\n   event.dataset == \"endpoint.events.file\" and\n   event.action in (\"creation\", \"rename\") and\n   file.extension in (\"php\", \"phtml\", \"pht\", \"php5\", \"asp\", \"aspx\", \"jsp\", \"jspx\", \"war\", \"cgi\")\n   /* We can add file.path values here in the future, if telemetry is noisy */\n  ]\n  [network where\n   data_stream.dataset == \"network_traffic.http\" and\n   http.request.method in (\"GET\", \"POST\") and\n   /* we may restrict to 200, but keeping it broader right now */\n   http.response.status_code >= 200 and http.response.status_code < 600 and\n   url.extension in (\"php\", \"phtml\", \"pht\", \"php5\", \"asp\", \"aspx\", \"jsp\", \"jspx\", \"war\", \"cgi\")\n  ]\n",
        "related_integrations": [
            {
                "package": "endpoint",
                "version": "^8.2.0"
            },
            {
                "package": "network_traffic",
                "version": "^1.1.0"
            }
        ],
        "required_fields": [
            {
                "ecs": true,
                "name": "agent.id",
                "type": "keyword"
            },
            {
                "ecs": true,
                "name": "data_stream.dataset",
                "type": "constant_keyword"
            },
            {
                "ecs": true,
                "name": "event.action",
                "type": "keyword"
            },
            {
                "ecs": true,
                "name": "event.dataset",
                "type": "keyword"
            },
            {
                "ecs": true,
                "name": "file.extension",
                "type": "keyword"
            },
            {
                "ecs": true,
                "name": "http.request.body.content",
                "type": "wildcard"
            },
            {
                "ecs": true,
                "name": "http.request.method",
                "type": "keyword"
            },
            {
                "ecs": true,
                "name": "http.response.status_code",
                "type": "long"
            },
            {
                "ecs": true,
                "name": "url.extension",
                "type": "keyword"
            }
        ],
        "risk_score": 47,
        "rule_id": "1d306bf0-7bcf-4acd-83fd-042f5711acc9",
        "setup": "## Setup\n\nThis rule requires data coming in from both Elastic Defend (for file events) and Network Packet Capture integrations (for HTTP traffic analysis).\n\n### Network Packet Capture Integration Setup\n\n**IMPORTANT**: This rule requires HTTP request body capture to be enabled in order to detect the multipart/form-data content containing WebKitFormBoundary indicators. The network traffic integration must be configured to capture HTTP request bodies for POST requests with `multipart/form-data` content type.\n\nTo enable HTTP request body capture, follow these steps:\n1. Navigate to the Fleet policy leveraging the Network Packet Capture integration in Kibana.\n2. Locate and select the \"Network Packet Capture\" integration, and edit the integration.\n3. Locate \"Change Default\", and scroll down to the \"HTTP\" section.\n4. Enable the \"HTTP\" toggle to capture HTTP traffic, add the correct ports for your web application, and click \"advanced options\".\n5. Edit the integration settings to enable HTTP request body capture for POST requests with `multipart/form-data` content type.\n6. Save the integration configuration and wait for the policy to deploy to the agents.\n",
        "severity": "medium",
        "tags": [
            "Domain: Endpoint",
            "Domain: Web",
            "Domain: Network",
            "OS: Linux",
            "OS: Windows",
            "OS: macOS",
            "Use Case: Threat Detection",
            "Tactic: Initial Access",
            "Tactic: Persistence",
            "Data Source: Elastic Defend",
            "Data Source: Network Traffic",
            "Resources: Investigation Guide"
        ],
        "threat": [
            {
                "framework": "MITRE ATT&CK",
                "tactic": {
                    "id": "TA0001",
                    "name": "Initial Access",
                    "reference": "https://attack.mitre.org/tactics/TA0001/"
                },
                "technique": [
                    {
                        "id": "T1190",
                        "name": "Exploit Public-Facing Application",
                        "reference": "https://attack.mitre.org/techniques/T1190/"
                    }
                ]
            },
            {
                "framework": "MITRE ATT&CK",
                "tactic": {
                    "id": "TA0003",
                    "name": "Persistence",
                    "reference": "https://attack.mitre.org/tactics/TA0003/"
                },
                "technique": [
                    {
                        "id": "T1505",
                        "name": "Server Software Component",
                        "reference": "https://attack.mitre.org/techniques/T1505/",
                        "subtechnique": [
                            {
                                "id": "T1505.003",
                                "name": "Web Shell",
                                "reference": "https://attack.mitre.org/techniques/T1505/003/"
                            }
                        ]
                    }
                ]
            }
        ],
        "type": "eql",
        "version": 1
    },
    "id": "1d306bf0-7bcf-4acd-83fd-042f5711acc9_1",
    "type": "security-rule"
}