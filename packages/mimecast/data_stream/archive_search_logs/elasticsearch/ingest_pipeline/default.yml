---
description: Pipeline for processing Mimecast archive_search_logs.
processors:
  # Generic event/ecs fields we always want to populate.
  - set:
      field: ecs.version
      value: '8.11.0'
  - rename:
      field: message
      target_field: event.original
      ignore_missing: true
      if: ctx.event?.original == null
  - json:
      description: Parse 'message' JSON contents into a 'mimecast' object.
      field: event.original
      target_field: mimecast
  - drop:
      if: ctx.mimecast?.createTime == null || (ctx.mimecast?.data != null && ctx.mimecast.data.isEmpty())
  - fingerprint:
      fields:
        - mimecast.id
      target_field: "_id"
      ignore_missing: true

  - date:
      description: Use 'mimecast.createTime' as the '@timestamp'
      field: mimecast.createTime
      timezone: UTC
      formats:
        - "yyyy-MM-dd'T'HH:mm:ssz"
        - "yyyy-MM-dd'T'HH:mm:ssZ"
        - "yyyy-MM-dd'T'HH:mm:ss.Sz"
        - "yyyy-MM-dd'T'HH:mm:ss.SZ"
        - "yyyy-MM-dd'T'HH:mm:ss.SSz"
        - "yyyy-MM-dd'T'HH:mm:ss.SSZ"
        - "yyyy-MM-dd'T'HH:mm:ss.SSSz"
        - "yyyy-MM-dd'T'HH:mm:ss.SSSZ"
        - "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSSz"
        - "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSSZ"
        - "yyyy-MM-dd'T'HH:mm:ss z"

  ###

  # Search related fields
  - rename:
      field: mimecast.searchText
      target_field: mimecast.search_details.text
      ignore_missing: true
  - rename:
      field: mimecast.description
      target_field: mimecast.search_details.description
      ignore_missing: true
  - rename:
      field: mimecast.source
      target_field: mimecast.search_details.source
      ignore_missing: true
  - rename:
      field: mimecast.searchPath
      target_field: mimecast.search_details.path
      ignore_missing: true
  - rename:
      field: mimecast.searchReason
      target_field: mimecast.search_details.reason
      ignore_missing: true

  ###

  # User fields
  - remove:
      field: mimecast.emailAddr
      if: ctx.mimecast?.emailAddr == "<>"
  - rename:
      field: mimecast.emailAddr
      target_field: user.email
      ignore_missing: true
  - dissect:
      field: user.email
      pattern: "<%{user.email}>"
      ignore_missing: true
      ignore_failure: true
  - split:
      field: user.email
      separator: "@"
      target_field: user.parts
      if: 'ctx.user?.email != null'
  - set:
      field: user.name
      copy_from: user.parts.0
      if: ctx.user?.parts?.length != null && ctx.user.parts.length > 1
  - set:
      field: user.domain
      copy_from: user.parts.1
      if: ctx.user?.parts?.length != null && ctx.user.parts.length > 1
  
  - append:
      field: related.user
      value: "{{{user.name}}}"
      allow_duplicates: false
      if: 'ctx.user?.name !=null'
  - append:
      field: related.user
      value: "{{{user.email}}}"
      allow_duplicates: false
      if: ctx.user?.email != null
  
  # Event related fields
  # Sets event.created from the @timestamp field generated by filebeat before being overwritten further down
  - set:
      field: event.created
      copy_from: "@timestamp"
  - set:
      field: event.kind
      value: event
  - append:
      field: event.category
      value: [api]
  - append:
      field: event.type
      value: [admin]

  # Cleanup
  - script:
      description: Drops null/empty values recursively
      tag: script_to_drop_empty_values
      lang: painless
      ignore_failure: true
      source: |
        void handleMap(Map map) {
          map.values().removeIf(v -> {
            if (v instanceof Map) {
                handleMap(v);
            } else if (v instanceof List) {
                handleList(v);
            }
            return v == null || v == '' || (v instanceof Map && v.size() == 0) || (v instanceof List && v.size() == 0)
          });
        }
        void handleList(List list) {
          list.removeIf(v -> {
            if (v instanceof Map) {
                handleMap(v);
            } else if (v instanceof List) {
                handleList(v);
            }
            return v == null || v == '' || (v instanceof Map && v.size() == 0) || (v instanceof List && v.size() == 0)
          });
        }
        handleMap(ctx);
  - remove:
      description: Cleanup of repeated/unwanted/temporary fields.
      field: 
        - mimecast.createTime
        - mimecast.searchPath
        - mimecast.searchText
        - mimecast.description
        - mimecast.searchReason
        - mimecast.source
        - user.parts
      ignore_missing: true

# Error handling
on_failure:
  - set:
      field: event.kind
      value: pipeline_error
  - append:
      field: tags
      value: preserve_original_event
      allow_duplicates: false
  - append:
      field: error.message
      value: >-
        Processor '{{{ _ingest.on_failure_processor_type }}}'
        {{{#_ingest.on_failure_processor_tag}}}with tag '{{{ _ingest.on_failure_processor_tag }}}'
        {{{/_ingest.on_failure_processor_tag}}}failed with message '{{{ _ingest.on_failure_message }}}'
