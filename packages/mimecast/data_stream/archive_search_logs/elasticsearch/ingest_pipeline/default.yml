---
description: Pipeline for processing Mimecast archive_search_logs.
processors:
  # Generic event/ecs fields we always want to populate.
  - set:
      field: ecs.version
      value: '8.9.0'
  - rename:
      field: message
      target_field: event.original
  - json:
      description: Parse 'message' JSON contents into a 'mimecast' object.
      field: event.original
      target_field: mimecast
  - drop:
      if: ctx.mimecast?.createTime == null || (ctx.mimecast?.data != null && ctx.mimecast.data.isEmpty())
  - fingerprint:
      fields:
        - mimecast.id
      target_field: "_id"
      ignore_missing: true

  - date:
      description: Use 'mimecast.createTime' as the '@timestamp'
      field: mimecast.createTime
      timezone: UTC
      formats:
        - "yyyy-MM-dd'T'HH:mm:ssz"
        - "yyyy-MM-dd'T'HH:mm:ssZ"
        - "yyyy-MM-dd'T'HH:mm:ss.Sz"
        - "yyyy-MM-dd'T'HH:mm:ss.SZ"
        - "yyyy-MM-dd'T'HH:mm:ss.SSz"
        - "yyyy-MM-dd'T'HH:mm:ss.SSZ"
        - "yyyy-MM-dd'T'HH:mm:ss.SSSz"
        - "yyyy-MM-dd'T'HH:mm:ss.SSSZ"
        - "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSSz"
        - "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSSZ"
        - "yyyy-MM-dd'T'HH:mm:ss z"

  ###

  # Search related fields
  - rename:
      field: mimecast.searchText
      target_field: mimecast.search_details.text
      ignore_missing: true
  - rename:
      field: mimecast.description
      target_field: mimecast.search_details.description
      ignore_missing: true
  - rename:
      field: mimecast.source
      target_field: mimecast.search_details.source
      ignore_missing: true
  - rename:
      field: mimecast.searchPath
      target_field: mimecast.search_details.path
      ignore_missing: true
  - rename:
      field: mimecast.searchReason
      target_field: mimecast.search_details.reason
      ignore_missing: true

  ###

  # User fields
  - rename:
      field: mimecast.emailAddr
      target_field: user.email
      ignore_missing: true

  - split:
      field: user.email
      separator: "@"
      target_field: user.parts
      if: 'ctx.user?.email != null'
  - set:
      field: user.name
      copy_from: user.parts.0
      if: 'ctx.user?.parts?.length > 1'
  - set:
      field: user.domain
      copy_from: user.parts.1
      if: 'ctx.user?.parts?.length > 1'
  
  - append:
      field: related.user
      value: "{{{user.name}}}"
      allow_duplicates: false
      if: 'ctx.user?.name !=null'
  - append:
      field: related.user
      value: "{{{user.email}}}"
      allow_duplicates: false
      if: ctx.user?.email != null
  
  # Event related fields
  # Sets event.created from the @timestamp field generated by filebeat before being overwritten further down
  - set:
      field: event.created
      copy_from: "@timestamp"
  - set:
      field: event.kind
      value: event
  - append:
      field: event.category
      value: [api]
  - append:
      field: event.type
      value: [admin]

  # Cleanup
  - script:
      description: Drops null/empty values recursively
      lang: painless
      ignore_failure: true
      source: |
        boolean drop(Object o) {
          if (o == null || o == "") {
            return true;
          } else if (o instanceof Map) {
            ((Map) o).values().removeIf(v -> drop(v));
            return (((Map) o).size() == 0);
          } else if (o instanceof List) {
            ((List) o).removeIf(v -> drop(v));
            return (((List) o).length == 0);
          }
          return false;
        }
        drop(ctx);
  - remove:
      description: Cleanup of repeated/unwanted/temporary fields.
      field: 
        - mimecast.createTime
        - mimecast.searchPath
        - mimecast.searchText
        - mimecast.description
        - mimecast.searchReason
        - mimecast.source
        - user.parts
      ignore_missing: true
  - remove:
      description: Remove 'event.original' if 'preserve_original_event' is not set.
      field: event.original
      if: "ctx?.tags == null || !(ctx.tags.contains('preserve_original_event'))"
      ignore_failure: true

# Error handling
on_failure:
  - set:
      field: event.kind
      value: pipeline_error
  - append:
      field: error.message
      value: '{{{ _ingest.on_failure_message }}}'
