---
description: Pipeline for processing Mimecast siem_logs.
processors:
  # Generic event/ecs fields we always want to populate.
  - set:
      field: ecs.version
      value: '8.11.0'
  - rename:
      field: message
      target_field: event.original
      ignore_missing: true
      if: ctx.event?.original == null
  - json:
      description: Parse 'message' JSON contents into a 'mimecast' object.
      field: event.original
      target_field: mimecast
  - drop:
      if: ctx?.mimecast?.datetime == null

  - date:
      description: Use 'mimecast.datetime' as the '@timestamp'
      field: mimecast.datetime
      timezone: UTC
      formats:
        - yyyy-MM-dd'T'HH:mm:ssZ

  ### NOTE LOG TYPE
  - script:
      lang: painless
      params:
        definite_positive:
          Action: receipt
          Attempt: delivery
          AttNames: process
          CustomerIP: avlog
          CustomName: impersonation-protect
          CustomThreatDictionary: impersonation-protect
          Definition: impersonation-protect
          Delivered: delivery
          Err: delivery
          Error: receipt
          fileName: attachment-protect
          Hits: impersonation-protect
          Hld: process
          InternalName: impersonation-protect
          IPInternalName: process
          IPNewDomain: process
          IPReplyMismatch: process
          IPSimilarDomain: process
          IPThreadDict: process
          Latency: delivery
          MimecastIP: avlog
          MsgSize: process
          NewDomain: impersonation-protect
          reason: url-protect
          ReceiptAck: delivery
          ReplyMismatch: impersonation-protect
          RcptActType: journal
          ScanResultInfo: internal-email-protect
          SenderDomainInternal: avlog
          SimilarCustomExternalDomain: impersonation-protect
          SimilarInternalDomain: impersonation-protect
          SimilarMimecastExternalDomain: impersonation-protect
          Snt: delivery
          SpamInfo: receipt
          SpamLimit: receipt
          SpamProcessingDetail: receipt
          SpamScore: receipt
          TaggedExternal: impersonation-protect
          TaggedMalicious: impersonation-protect
          ThreatDictionary: impersonation-protect
          UseTls: delivery
        negative:
          aCode: [avlogs, url-protect, attachment-protect]
          Act: [delivery, avlogs, spam, internal-email-protect, impersonation-protect, url-protect, attachment-protect, journal]
          AttCnt: [receipt, avlogs, spam, internal-email-protect, impersonation-protect, url-protect, attachment-protect, journal]
          AttSize: [receipt, avlogs, spam, internal-email-protect, impersonation-protect, url-protect, attachment-protect, journal]
          Cphr: [process,avlogs, spam, internal-email-protect, impersonation-protect, url-protect, attachment-protect, journal]
          Dir: [process, avlogs, spam, internal-email-protect, impersonation-protect, url-protect, attachment-protect]
          fileExt: [receipt, process, delivery, spam, internal-email-protect, impersonation-protect, url-protect, journal]
          fileMime: [receipt, process, delivery, spam, internal-email-protect, impersonation-protect, url-protect, journal]
          headerFrom: [process, delivery, avlogs, internal-email-protect, impersonation-protect, url-protect, attachment-protect, journal]
          IP: [process, spam, internal-email-protect, url-protect, journal]
          md5: [receipt, process, delivery, spam, internal-email-protect, impersonation-protect, url-protect, journal]
          Rcpt: [process, avlogs, spam, internal-email-protect, impersonation-protect, url-protect, attachment-protect]
          recipient: [receipt, process, delivery, journal]
          Recipient: [receipt, process, delivery, journal]
          RejCode: [process, avlogs, spam, internal-email-protect, impersonation-protect, url-protect, attachment-protect, journal]
          RejInfo: [process, avlogs, spam, internal-email-protect, impersonation-protect, url-protect, attachment-protect, journal]
          RejType: [process, avlogs, spam, internal-email-protect, impersonation-protect, url-protect, attachment-protect, journal]
          route: [receipt, process, journal]
          Route: [receipt, process, journal]
          senderDomain: [receipt, process, delivery, internal-email-protect, impersonation-protect, journal]
          SenderDomain: [receipt, process, delivery, internal-email-protect, impersonation-protect, journal]
          sha1: [receipt, process, delivery, spam, internal-email-protect, impersonation-protect, url-protect, journal]
          sha256: [receipt, process, delivery, spam, internal-email-protect, impersonation-protect, url-protect, journal]
          Size: [receipt, process, delivery, spam, internal-email-protect, impersonation-protect, url-protect, journal]
          sourceIp: [receipt, process, delivery, avlogs, internal-email-protect, impersonation-protect, attachment-protect, journal]
          SourceIP: [receipt, process, delivery, avlogs, internal-email-protect, impersonation-protect, attachment-protect, journal]
          TlsVer: [process, avlogs, spam, internal-email-protect, impersonation-protect, url-protect, attachment-protect, journal]
          url: [receipt, process, delivery, avlogs, spam, impersonation-protect, attachment-protect, journal]
          URL: [receipt, process, delivery, avlogs, spam, impersonation-protect, attachment-protect, journal]
          urlCategory: [receipt, process, delivery, avlogs, spam, impersonation-protect, attachment-protect, journal]
          UrlCategory: [receipt, process, delivery, avlogs, spam, impersonation-protect, attachment-protect, journal]
          Virus: [rprocess, delivery, spam, internal-email-protect, impersonation-protect, url-protect, attachment-protect, journal]
        positive:
          aCode: [receipt, process, delivery, spam, internal-email-protect, impersonation-protect, journal]
          Act: [receipt, process]
          AttCnt: [process, delivery]
          AttSize: [process, delivery]
          Cphr: [receipt, delivery]
          Dir: [receipt, delivery, journal]
          fileExt: [avlog, attachment-protect]
          fileMime: [avlog, attachment-protect]
          headerFrom: [receipt, spam]
          IP: [receipt, delivery, avlogs, impersonation-protect, attachment-protect]
          md5: [avlogs, attachment-protect]
          Rcpt: [receipt, delivery, journal]
          recipient: [avlogs, spam, internal-email-protect, impersonation-protect, url-protect, attachment-protect]
          Recipient: [avlogs, spam, internal-email-protect, impersonation-protect, url-protect, attachment-protect]
          RejCode: [receipt, delivery]
          RejInfo: [receipt, delivery]
          RejType: [receipt, delivery]
          route: [delivery, avlogs, spam, internal-email-protect, impersonation-protect, url-protect, attachment-protect]
          Route: [delivery, avlogs, spam, internal-email-protect, impersonation-protect, url-protect, attachment-protect]
          senderDomain: [avlogs, spam, url-protect, attachment-protect]
          SenderDomain: [avlogs, spam, url-protect, attachment-protect]
          sha1: [avlog, attachment-protect]
          sha256: [avlog, attachment-protect]
          Size: [avlog, attachment-protect]
          sourceIp: [spam, url-protect]
          SourceIP: [spam, url-protect]
          TlsVer: [receipt, delivery]
          url: [internal-email-protect, url-protect]
          URL: [internal-email-protect, url-protect]
          urlCategory: [internal-email-protect, url-protect]
          UrlCategory: [internal-email-protect, url-protect]
          Virus: [receipt, avlogs]
        candidates:
          receipt: 0
          process: 0
          delivery: 0
          journal: 0
          avlogs: 0
          spam: 0
          internal-email-protect: 0
          impersonation-protect: 0
          url-protect: 0
          attachment-protect: 0
      if: ctx.mimecast instanceof Map
      source: |
        for (def k: ctx.mimecast.keySet()) {
          def typ = params.definite_positive.get(k);
          if (typ != null) {
            // We have a definitive known stage.
            ctx.mimecast.stage = typ;
            return;
          }
        }
        def score = params.candidates.clone();
        for (def k: ctx.mimecast.keySet()) {
          def typ = params.negative.get(k);
          if (typ == null) {
            continue;
          }
          for (String e: typ) {
            score.remove(e);
          }
        }
        if (score.size() == 1) {
          // We have removed all but one of the candidates.
          ctx.mimecast.stage = score.keySet().toArray()[0];
          return;
        }
        // Find best remaining and list all co-equal winners.
        int max = 0;
        for (def k: ctx.mimecast.keySet()) {
          def typ = params.positive.get(k);
          if (typ == null) {
            continue;
          }
          for (String e: typ) {
            def s = score.get(e);
            if (s == null) {
              continue;
            }
            s++;
            if (s > max) {
              max = s;
            }
            score.put(e, s);
          }
        }
        for (def e: score.entrySet()) {
          if (e.getValue() < max) {
            score.remove(e.getKey());
          }
        }
        ctx.mimecast.stage = score.keySet();

  - fingerprint:
      fields:
        - mimecast.MsgId
        - mimecast.aCode
        - mimecast.datetime
        - mimecast.Sender
        - mimecast.Rcpt
        - mimecast.Attempt
        - mimecast.stage
        - mimecast.sha256
        - mimecast.url
      target_field: "_id"
      ignore_missing: true

  ### RECEIPT LOGS
  - rename:
      field: mimecast.aCode
      target_field: email.local_id
      ignore_missing: true
  - rename:
      field: mimecast.Act
      target_field: event.action
      ignore_missing: true
  - rename:
      field: mimecast.Cphr
      target_field: tls.cipher
      ignore_missing: true
  - rename:
      field: mimecast.Dir
      target_field: email.direction
      ignore_missing: true
  - rename:
      field: mimecast.Error
      target_field: error.message
      ignore_missing: true
  - rename:
      field: mimecast.IP
      target_field: source.ip
      ignore_missing: true
  - rename:
      field: mimecast.MsgId
      target_field: email.message_id
      ignore_missing: true
  - append:
      field: email.to.address
      value: '{{{mimecast.Rcpt}}}'
      allow_duplicates: false
      if: ctx.mimecast?.Rcpt != null
  - append:
      field: email.from.address
      value: '{{{mimecast.headerFrom}}}'
      allow_duplicates: false
      if: ctx.mimecast?.headerFrom != null
  - rename:
      field: mimecast.RejCode
      target_field: error.code
      ignore_missing: true
  - rename:
      field: mimecast.RejInfo
      target_field: event.reason
      ignore_missing: true
  - rename:
      field: mimecast.RejType
      target_field: error.type
      ignore_missing: true
  - append:
      field: email.from.address
      value: "{{{mimecast.Sender}}}"
      allow_duplicates: false
      if: "ctx?.mimecast?.Sender != null"
  - rename:
      field: mimecast.Subject
      target_field: email.subject
      ignore_missing: true
  - rename:
      field: mimecast.TlsVer
      target_field: tls.version
      ignore_missing: true

  ### PROCESS LOGS
  - rename:
      field: mimecast.AttSize
      target_field: email.attachments.file.size
      ignore_missing: true
  - rename:
      field: mimecast.AttNames
      target_field: email.attachments.file.name
      ignore_missing: true
  - rename:
      field: mimecast.Hld
      target_field: event.reason
      ignore_missing: true

  ### DELIVERY LOGS
  - rename:
      field: mimecast.Err
      target_field: error.message
      ignore_missing: true
  - rename:
      field: mimecast.UseTls
      target_field: tls.established
      ignore_missing: true
  - set:
      field: tls.established
      value: true
      if: 'ctx.tls?.established instanceof String && ctx.tls.established.toLowerCase() == "yes"'
  - set:
      field: tls.established
      value: false
      if: 'ctx.tls?.established instanceof String && ctx.tls.established.toLowerCase() == "no"'

  ### AV LOGS
  - rename:
      field: mimecast.fileExt
      target_field: email.attachments.file.extension
      ignore_missing: true
  - rename:
      field: mimecast.fileMime
      target_field: email.attachments.file.mime_type
      ignore_missing: true
  - rename:
      field: mimecast.md5
      target_field: email.attachments.file.hash.md5
      ignore_missing: true
  - append:
      field: email.to.address
      value: '{{{mimecast.Recipient}}}'
      allow_duplicates: false
      if: ctx.mimecast?.Recipient != null
  - rename:
      field: mimecast.SenderDomain
      target_field: source.domain
      ignore_missing: true
  - rename:
      field: mimecast.sha1
      target_field: email.attachments.file.hash.sha1
      ignore_missing: true
  - rename:
      field: mimecast.sha256
      target_field: email.attachments.file.hash.sha256
      ignore_missing: true
  - rename:
      field: mimecast.Size
      target_field: email.attachments.file.size
      ignore_missing: true
  - rename:
      field: mimecast.fileName
      target_field: email.attachments.file.name
      ignore_missing: true

  ### SPAM EVENT THREAD LOGS
  - rename:
      field: mimecast.SourceIP
      target_field: source.ip
      ignore_missing: true

  ### SIEM Email Protect Logs
  - rename:
      field: mimecast.URL
      target_field: url.full
      ignore_missing: true

  ### SIEM Impersonation logs                       
  - rename:
      field: mimecast.Action
      target_field: event.action
      ignore_missing: true
  - rename:
      field: mimecast.Definition
      target_field: rule.name
      ignore_missing: true
  - rename:
      field: mimecast.NewDomain
      target_field: source.domain
      ignore_missing: true

  ### SIEM TTP Url Logs
  - rename:
      field: mimecast.reason
      target_field: event.reason
      ignore_missing: true
  - append:
      field: email.to.address
      value: '{{{mimecast.recipient}}}'
      allow_duplicates: false
      if: ctx.mimecast?.recipient != null
  - rename:
      field: mimecast.route
      target_field: email.direction
      ignore_missing: true
  - append:
      field: email.from.address
      value: "{{{mimecast.sender}}}"
      allow_duplicates: false
      if: "ctx?.mimecast?.sender != null"
  - rename:
      field: mimecast.senderDomain
      target_field: source.domain
      ignore_missing: true
  - rename:
      field: mimecast.sourceIp
      target_field: source.ip
      ignore_missing: true
  - rename:
      field: mimecast.subject
      target_field: email.subject
      ignore_missing: true
  - rename:
      field: mimecast.url
      target_field: url.full
      ignore_missing: true
  - rename:
      field: mimecast.action
      target_field: event.action
      ignore_missing: true
  - dissect:
      field: mimecast.Content-Disposition
      pattern: "%{?drop->}=\"%{mimecast.log_type}.%{?drop->}"
      ignore_missing: true
  - split:
      field: mimecast.log_type
      separator: "_"
      target_field: mimecast.log_type_parts
      if: 'ctx?.mimecast?.log_type != null'
  - set:
      field: mimecast.log_type_part1
      copy_from: mimecast.log_type_parts.0
      if: 'ctx?.mimecast?.log_type_parts instanceof List && ctx.mimecast.log_type_parts.size() > 0'
  - set:
      field: mimecast.log_type_part2
      copy_from: mimecast.log_type_parts.1
      if: 'ctx?.mimecast?.log_type_parts instanceof List && ctx.mimecast.log_type_parts.size() > 1'
  - set:
      field: mimecast.log_type
      value: "{{mimecast.log_type_part1}}"
      if: 'ctx?.mimecast?.log_type_part1 != "ttp"'
      ignore_failure: true
  - set:
      field: mimecast.log_type
      value: "{{mimecast.log_type_part1}}_{{mimecast.log_type_part2}}"
      if: 'ctx?.mimecast?.log_type_part1 =="ttp" && ctx?.mimecast?.log_type_part2 != null'
      ignore_failure: true 
  - set:
      field: event.created
      value: "{{mimecast.datetime}}"
      if: 'ctx?.mimecast?.datetime != null'
  - set:
      field: tls.established
      value: false
      if: 'ctx?.tls?.established == "No"'
  - set:
      field: tls.established
      value: true
      if: 'ctx?.tls?.established == "Yes"'
  - rename:
      field: mimecast.Delivered
      target_field: event.outcome
      ignore_missing: true
  - set:
      field: event.outcome
      value: "success"
      if: ctx?.event?.outcome == true
  - set:
      field: event.outcome
      value: "failure"
      if: ctx?.event?.outcome == false
  - set:
      field: event.outcome
      value: "unknown"
      if: ctx?.event?.outcome == null
  - lowercase:
      field: email.direction
      ignore_missing: true
  - geoip:
      field: source.ip
      target_field: source.geo
      ignore_missing: true
  - geoip:
      database_file: GeoLite2-ASN.mmdb
      field: source.ip
      target_field: source.as
      properties:
        - asn
        - organization_name
      ignore_missing: true
  - rename:
      field: source.as.asn
      target_field: source.as.number
      ignore_missing: true
  - rename:
      field: source.as.organization_name
      target_field: source.as.organization.name
      ignore_missing: true

  # Cleanup
  - remove:
      description: Cleanup of repeated/unwanted/temporary fields.
      field: 
        - mimecast.eventTime
        - mimecast.Content-Disposition
        - mimecast.datetime
        - mimecast.headerFrom
        - mimecast.log_type_part1
        - mimecast.log_type_part2
        - mimecast.log_type_parts
        - mimecast.recipient
        - mimecast.Rcpt
        - mimecast.sender
        - mimecast.Sender
      ignore_missing: true
  - script:
      lang: painless
      description: This script processor iterates over the whole document to remove fields with null values.
      source: |
        void handleMap(Map map) {
          for (def x : map.values()) {
            if (x instanceof Map) {
                handleMap(x);
            } else if (x instanceof List) {
                handleList(x);
            }
          }
          map.values().removeIf(v -> v == null || v == '' || (v instanceof Map && v.size() == 0) || (v instanceof List && v.size() == 0));
        }
        void handleList(List list) {
          for (def x : list) {
              if (x instanceof Map) {
                  handleMap(x);
              } else if (x instanceof List) {
                  handleList(x);
              }
          }
          list.removeIf(v -> v == null || v == '' || (v instanceof Map && v.size() == 0) || (v instanceof List && v.size() == 0));
        }
        handleMap(ctx);
  - remove:
      description: Remove 'event.original' if 'preserve_original_event' is not set.
      field: event.original
      if: "ctx?.tags == null || !(ctx.tags.contains('preserve_original_event'))"
      ignore_failure: true  

# Error handling
on_failure:
  - set:
      field: event.kind
      value: pipeline_error
  - append:
      field: error.message
      value: '{{{ _ingest.on_failure_message }}}'
