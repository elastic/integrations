---
description: Pipeline for parsing Nginx Ingress Controller access logs. Requires the
  geoip and user_agent plugins.
processors:
  - set:
      field: ecs.version
      value: '8.4.0'
  - rename:
      field: message
      target_field: event.original
      ignore_missing: true
  - grok:
      field: event.original
      patterns:
      - (%{NGINX_HOST} )?"?(?:%{NGINX_ADDRESS_LIST:nginx_ingress_controller.access.remote_ip_list}|%{NOTSPACE:source.address})
        - (-|%{DATA:user.name}) \[%{HTTPDATE:nginx_ingress_controller.access.time}\] "%{DATA:nginx_ingress_controller.access.info}"
        %{NUMBER:http.response.status_code:long} %{NUMBER:http.response.body.bytes:long}
        "(-|%{DATA:http.request.referrer})" "(-|%{DATA:user_agent.original})" %{NUMBER:nginx_ingress_controller.access.http.request.length:long}
        %{NUMBER:nginx_ingress_controller.access.http.request.time:double} \[%{DATA:nginx_ingress_controller.access.upstream.name}\]
        \[%{DATA:nginx_ingress_controller.access.upstream.alternative_name}\] (%{UPSTREAM_ADDRESS_LIST:nginx_ingress_controller.access.upstream.ip_port_list}|-)
        (%{UPSTREAM_RESPONSE_LENGTH_LIST:nginx_ingress_controller.access.upstream.response_length_list}|-) (%{UPSTREAM_RESPONSE_TIME_LIST:nginx_ingress_controller.access.upstream.response_time_list}|-)
        (%{UPSTREAM_RESPONSE_STATUS_CODE_LIST:nginx_ingress_controller.access.upstream.response_status_code_list}|-) %{GREEDYDATA:nginx_ingress_controller.access.http.request.id}
      pattern_definitions:
        NGINX_HOST: (?:%{IP:destination.ip}|%{NGINX_NOTSEPARATOR:destination.domain})(:%{NUMBER:destination.port})?
        NGINX_NOTSEPARATOR: "[^\t ,:]+"
        NGINX_ADDRESS_LIST: (?:%{IP}|%{WORD})("?,?\s*(?:%{IP}|%{WORD}))*
        UPSTREAM_ADDRESS: '\[?%{IP:nginx_ingress_controller.access.upstream.ip}\]?(:%{NUMBER:nginx_ingress_controller.access.upstream.port})?'
        UPSTREAM_ADDRESS_LIST: '%{UPSTREAM_ADDRESS}(, %{UPSTREAM_ADDRESS})*'
        UPSTREAM_RESPONSE_LENGTH_LIST: '%{NUMBER:nginx_ingress_controller.access.upstream.response.length:long}(, %{NUMBER})*'
        UPSTREAM_RESPONSE_TIME_LIST: '%{NUMBER:nginx_ingress_controller.access.upstream.response.time:double}(, %{NUMBER})*'
        UPSTREAM_RESPONSE_STATUS_CODE_LIST: '%{NUMBER:nginx_ingress_controller.access.upstream.response.status_code:long}(, %{NUMBER})*'
      ignore_missing: true
  - grok:
      field: nginx_ingress_controller.access.info
      patterns:
      - '%{WORD:http.request.method} %{DATA:url.original} HTTP/%{NUMBER:http.version}'
      - ""
      ignore_missing: true
  - split:
      field: nginx_ingress_controller.access.remote_ip_list
      separator: '"?,?\s+'
      ignore_missing: true
  - split:
      field: nginx_ingress_controller.access.origin
      separator: '"?,?\s+'
      ignore_missing: true
  - script:
      if: ctx.nginx_ingress_controller?.access?.upstream?.response_length_list != null && ctx.nginx_ingress_controller.access.upstream.response_length_list.contains(', ')
      lang: painless
      source: >-
        def response_length_list = Arrays.asList(ctx.nginx_ingress_controller.access.upstream.response_length_list.splitOnToken(", ")).stream().distinct().map(str -> Long.parseLong(str)).collect(Collectors.toList());
        if(response_length_list.length == 1) {
            response_length_list = response_length_list[0]
        }
        ctx.nginx_ingress_controller.access.upstream.response.put("length", response_length_list);
  - script:
      if: ctx.nginx_ingress_controller?.access?.upstream?.response_time_list != null && ctx.nginx_ingress_controller.access.upstream.response_time_list.contains(', ')
      lang: painless
      source: >-
        def response_time_list = Arrays.asList(ctx.nginx_ingress_controller.access.upstream.response_time_list.splitOnToken(", ")).stream().distinct().map(str -> Double.parseDouble(str)).collect(Collectors.toList());
        if(response_time_list.length == 1) {
            response_time_list = response_time_list[0]
        }
        ctx.nginx_ingress_controller.access.upstream.response.put("time", response_time_list);
  - script:
      if: ctx.nginx_ingress_controller?.access?.upstream?.response_status_code_list != null && ctx.nginx_ingress_controller.access.upstream.response_status_code_list.contains(', ')
      lang: painless
      source: >-
        def response_status_code_list = Arrays.asList(ctx.nginx_ingress_controller.access.upstream.response_status_code_list.splitOnToken(", ")).stream().distinct().map(str -> Long.parseLong(str)).collect(Collectors.toList());
        if(response_status_code_list.length == 1) {
            response_status_code_list = response_status_code_list[0]
        }
        ctx.nginx_ingress_controller.access.upstream.response.put("status_code", response_status_code_list);
  - split:
      field: nginx_ingress_controller.access.upstream.ip_port_list
      separator: '"?,?\s+'
      ignore_missing: true
  - remove:
      field: 
        - nginx_ingress_controller.access.info
        - nginx_ingress_controller.access.upstream.response_length_list
        - nginx_ingress_controller.access.upstream.response_time_list
        - nginx_ingress_controller.access.upstream.response_status_code_list
      ignore_missing: true
  - set:
      field: http.request.id
      copy_from: nginx_ingress_controller.access.http.request.id
      ignore_empty_value: true
  - set:
      field: source.address
      if: ctx.source?.address == null
      value: ""
  - script:
      if: ctx.nginx_ingress_controller.access.remote_ip_list.length > 0
      lang: painless
      source: >-
        boolean isPrivate(def dot, def ip) {
          try {
            StringTokenizer tok = new StringTokenizer(ip, dot);
            int firstByte = Integer.parseInt(tok.nextToken());
            int secondByte = Integer.parseInt(tok.nextToken());
            if (firstByte == 10) {
              return true;
            }
            if (firstByte == 192 && secondByte == 168) {
              return true;
            }
            if (firstByte == 172 && secondByte >= 16 && secondByte <= 31) {
              return true;
            }
            if (firstByte == 127) {
              return true;
            }
            return false;
          }
          catch (Exception e) {
            return false;
          }
        }
        try {
          ctx.source.address = null;
          if (ctx.nginx_ingress_controller.access.remote_ip_list == null) {
            return;
          }
          def found = false;
          for (def item : ctx.nginx_ingress_controller.access.remote_ip_list) {
            if (!isPrivate(params.dot, item)) {
              ctx.source.address = item;
              found = true;
              break;
            }
          }
          if (!found) {
            ctx.source.address = ctx.nginx_ingress_controller.access.remote_ip_list[0];
          }
        }
        catch (Exception e) {
          ctx.source.address = null;
        }
      params:
        dot: .
  - remove:
      field: source.address
      if: ctx.source.address == null
  - grok:
      field: source.address
      patterns:
      - ^%{IP:source.ip}$
      ignore_failure: true
  - rename:
      field: '@timestamp'
      target_field: event.created
  - date:
      field: nginx_ingress_controller.access.time
      target_field: '@timestamp'
      formats:
      - dd/MMM/yyyy:H:m:s Z
      on_failure:
      - append:
          field: error.message
          value: '{{ _ingest.on_failure_message }}'
  - remove:
      field: nginx_ingress_controller.access.time
  - user_agent:
      field: user_agent.original
      ignore_missing: true
  - geoip:
      field: source.ip
      target_field: source.geo
      ignore_missing: true
  - geoip:
      database_file: GeoLite2-ASN.mmdb
      field: source.ip
      target_field: source.as
      properties:
      - asn
      - organization_name
      ignore_missing: true
  - rename:
      field: source.as.asn
      target_field: source.as.number
      ignore_missing: true
  - rename:
      field: source.as.organization_name
      target_field: source.as.organization.name
      ignore_missing: true
  - set:
      field: event.kind
      value: event
  - append:
      field: event.category
      value: web
  - append:
      field: event.type
      value: info
  - set:
      field: event.outcome
      value: success
      if: "ctx?.http?.response?.status_code != null && ctx.http.response.status_code < 400"
  - set:
      field: event.outcome
      value: failure
      if: "ctx?.http?.response?.status_code != null && ctx.http.response.status_code >= 400"
  - append:
      field: related.ip
      value: "{{source.ip}}"
      if: "ctx?.source?.ip != null"
  - append:
      field: related.ip
      value: "{{destination.ip}}"
      if: "ctx?.destination?.ip != null"
  - append:
      field: related.user
      value: "{{user.name}}"
      if: "ctx?.user?.name != null"
  - remove:
      field: event.original
      if: "ctx?.tags == null || !(ctx.tags.contains('preserve_original_event'))"
      ignore_failure: true
      ignore_missing: true
on_failure:
  - set:
      field: error.message
      value: '{{ _ingest.on_failure_message }}'
