config_version: 2
interval: {{interval}}
resource.tracer:
  enabled: {{enable_request_tracer}}
  filename: "../../logs/cel/http-request-trace-*.ndjson"
  maxbackups: 5
{{#if proxy_url}}
resource.proxy_url: {{proxy_url}}
{{/if}}
{{#if http_client_timeout}}
resource.timeout: {{http_client_timeout}}
{{/if}}
resource.ssl.renegotiation: freely
resource.url: {{url}}
{{#if ssl}}
resource.ssl: {{ssl}}
{{/if}}
state:
  limit: {{limit}}
  apikey: {{escape_string apikey}}
  password: {{escape_string password}}
  username: {{escape_string username}}
redact:
  fields:
    - apikey
    - password
{{!--
API References:
  https://docs.beyondtrust.com/bips/docs/api#post-authsignappin
  https://docs.beyondtrust.com/bips/docs/beyondinsight-apis#workgroups-1
  https://docs.beyondtrust.com/bips/docs/beyondinsight-apis#get-workgroupsworkgroupidassets

Cursor variable definitions:
  workgroup_ids: Array of objects containing {workgroup_id: string, offset: int}.
    After the assets for the workgroup have been fully collected, the item is removed.
  cookies: Session cookie.
--}}
program: |-
  (
    (has(state.?cursor.asset_reqs) && !has(state.?cursor.workgroup_ids)) ?
      // Migrate cursor from old asset_reqs (array of arrays) to new workgroup_ids (array of objects).
      state.with(
        {
          "cursor": state.cursor.with(
            {
              "workgroup_ids": state.cursor.asset_reqs.map(item,
                {"workgroup_id": string(item[0]), "offset": int(item[1])}
              ),
            }
          ).drop("asset_reqs"),
        }
      )
    :
      state
  ).with(
    has(state.?cursor.cookies) ?
      (
        // Use existing authenticated session to fetch assets from workgroups.
        (size(state.?cursor.workgroup_ids.orValue([])) > 0) ?
          // We already have workgroup IDs, process assets from them.
          {
            "workgroup_id": state.cursor.workgroup_ids[0].workgroup_id,
            "offset": state.cursor.workgroup_ids[0].offset,
            "remaining_workgroups": tail(state.cursor.workgroup_ids),
          }.as(r,
            request(
              "GET",
              state.url.trim_suffix("/") + "/Workgroups/" + r.workgroup_id + "/Assets?" + {
                "limit": [string(state.limit)],
                "offset": [string(r.offset)],
              }.format_query()
            ).with(
              {
                "Header": {
                  "Content-Type": ["application/json"],
                  "Cookie": state.cursor.cookies,
                },
              }
            ).do_request().as(resp,
              (resp.StatusCode == 200) ?
                // Success: process JSON response with Data array of asset objects.
                resp.Body.decode_json().as(body,
                  (
                    (size(body.Data) + int(r.offset) < int(body.TotalCount)) ?
                      ([{"workgroup_id": r.workgroup_id, "offset": int(r.offset) + size(body.Data)}] + r.remaining_workgroups)
                    :
                      r.remaining_workgroups
                  ).as(next_workgroup_ids,
                    {
                      "events": body.Data.map(e,
                        {
                          "event": {
                            "original": e.encode_json(),
                          },
                        }
                      ),
                      "want_more": size(next_workgroup_ids) > 0,
                      "cursor": {
                        "cookies": state.cursor.cookies,
                        "workgroup_ids": next_workgroup_ids,
                      },
                      "retries": 0,
                    }
                  )
                )
              : (resp.StatusCode == 401) ?
                (
                  // Authentication failure: clear session and retry once.
                  (int(state.?retries.orValue(0)) == 0) ?
                    {
                      "events": [
                        // Must produce an event for want_more=true to be honored.
                        {"cel": true},
                      ],
                      "retries": 1,
                      "want_more": true,
                      "cursor": state.?cursor.orValue({}).drop("cookies"),
                    }
                  :
                    {
                      "events": {
                        "error": {
                          "code": string(resp.StatusCode),
                          "id": string(resp.Status),
                          "message": "Authentication failed after retry: " + "GET " + state.url.trim_suffix("/") + "/Workgroups/" + r.workgroup_id + "/Assets: " + (
                            (size(resp.Body) != 0) ?
                              string(resp.Body)
                            :
                              string(resp.Status) + " (" + string(resp.StatusCode) + ")"
                          ),
                        },
                      },
                      "want_more": false,
                    }
                )
              :
                // Handle all other HTTP error responses.
                {
                  "events": {
                    "error": {
                      "code": string(resp.StatusCode),
                      "id": string(resp.Status),
                      "message": "GET " + state.url.trim_suffix("/") + "/Workgroups/" + r.workgroup_id + "/Assets: " + (
                        (size(resp.Body) != 0) ?
                          string(resp.Body)
                        :
                          string(resp.Status) + " (" + string(resp.StatusCode) + ")"
                      ),
                    },
                  },
                  "want_more": false,
                }
            )
          )
        :
          // Fetch workgroup IDs first.
          request("GET", state.url.trim_suffix("/") + "/Workgroups").with(
            {
              "Header": {
                "Content-Type": ["application/json"],
                "Cookie": state.cursor.cookies,
              },
            }
          ).do_request().as(resp,
            (resp.StatusCode == 200) ?
              // Success: extract workgroup IDs and set up for asset fetching.
              resp.Body.decode_json().as(workgroups,
                (size(workgroups) == 0) ?
                  {
                    "events": [],
                    "want_more": false,
                    "cursor": {
                      "cookies": state.cursor.cookies,
                    },
                  }
                :
                  {
                    "events": [
                      // Must produce an event for want_more=true to be honored.
                      {"cel": true},
                    ],
                    "want_more": true,
                    "cursor": {
                      "cookies": state.cursor.cookies,
                      "workgroup_ids": workgroups.map(wg, {"workgroup_id": string(wg.ID), "offset": 0}),
                    },
                  }
              )
            : (resp.StatusCode == 401) ?
              (
                // Authentication failure: clear session and retry once.
                (int(state.?retries.orValue(0)) == 0) ?
                  {
                    "events": [
                      // Must produce an event for want_more=true to be honored.
                      {"cel": true},
                    ],
                    "retries": 1,
                    "want_more": true,
                    "cursor": state.?cursor.orValue({}).drop("cookies"),
                  }
                :
                  {
                    "events": {
                      "error": {
                        "code": string(resp.StatusCode),
                        "id": string(resp.Status),
                        "message": "Authentication failed after retry: " + "GET " + state.url.trim_suffix("/") + "/Workgroups: " + (
                          (size(resp.Body) != 0) ?
                            string(resp.Body)
                          :
                            string(resp.Status) + " (" + string(resp.StatusCode) + ")"
                        ),
                      },
                    },
                    "want_more": false,
                  }
              )
            :
              // Handle all other HTTP error responses.
              {
                "events": {
                  "error": {
                    "code": string(resp.StatusCode),
                    "id": string(resp.Status),
                    "message": "GET " + state.url.trim_suffix("/") + "/Workgroups: " + (
                      (size(resp.Body) != 0) ?
                        string(resp.Body)
                      :
                        string(resp.Status) + " (" + string(resp.StatusCode) + ")"
                    ),
                  },
                },
                "want_more": false,
              }
          )
      )
    :
      // Establish new authenticated session.
      request("POST", state.url.trim_suffix("/") + "/Auth/SignAppin").with(
        {
          "Header": {
            "Authorization": [
              sprintf("PS-Auth key=%s; runas=%s;", [state.apikey, state.username]) +
              ((state.password != "") ? (sprintf(" pwd=[%s];", [state.password])) : ""),
            ],
            "Content-Type": ["application/json"],
          },
        }
      ).do_request().as(resp,
        (resp.StatusCode == 200) ?
          {
            "events": [
              // Must produce an event for want_more=true to be honored.
              {"cel": true},
            ],
            "cursor": state.?cursor.orValue({}).with(
              {
                "cookies": resp.Header["Set-Cookie"],
              }
            ),
            "want_more": true,
          }
        :
          {
            "events": {
              "error": {
                "code": string(resp.StatusCode),
                "id": string(resp.Status),
                "message": "Failed to create session: " + "POST " + state.url.trim_suffix("/") + "/Auth/SignAppin: " + (
                  (size(resp.Body) != 0) ?
                    string(resp.Body)
                  :
                    string(resp.Status) + " (" + string(resp.StatusCode) + ")"
                ),
              },
            },
            "want_more": false,
          }
      )
  ).as(state, (state.want_more == false) ?
    // Restart fresh on the next periodic execution.
    state.drop("retries").drop("cursor.workgroup_ids")
  :
    state
  )
tags:
{{#if preserve_original_event}}
  - preserve_original_event
{{/if}}
{{#each tags as |tag|}}
  - {{tag}}
{{/each}}
{{#contains "forwarded" tags}}
publisher_pipeline.disable_host: true
{{/contains}}

processors:
- drop_event.when.equals.cel: true
{{#if processors}}
{{processors}}
{{/if}}
