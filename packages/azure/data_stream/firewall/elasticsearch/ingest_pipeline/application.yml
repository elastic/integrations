---
description: Pipeline for processing Azure Firewall application rule logs.
processors:
  - grok:
      field: json.properties.msg
      patterns:
        - "^%{DATA:azure.firewall.proto} request from %{IPORHOST:source.address}:%{NUMBER:source.port:long} to %{IPORHOST:destination.address}:%{NUMBER:destination.port:long}. Action: %{DATA:azure.firewall.action}. Policy: %{DATA:azure.firewall.policy}. Rule Collection Group: %{DATA:azure.firewall.rule_collection_group}. Rule Collection: %{DATA:rule.ruleset}. Rule: %{DATA:rule.name}. Web Category: %{DATA:rule.category}$"
        - "^%{DATA:azure.firewall.proto} request from %{IPORHOST:source.address}:%{NUMBER:source.port:long} to %{IPORHOST:destination.address}:%{NUMBER:destination.port:long}. Url: %{DATA:url.original}. Action: %{DATA:azure.firewall.action}. Policy: %{DATA:azure.firewall.policy}. Rule Collection Group: %{DATA:azure.firewall.rule_collection_group}. Rule Collection: %{DATA:rule.ruleset}. Rule: %{DATA:rule.name}$"
        - "^%{DATA:azure.firewall.proto} request from %{IPORHOST:source.address}:%{NUMBER:source.port:long} to %{IPORHOST:destination.address}:%{NUMBER:destination.port:long}. Action: %{DATA:azure.firewall.action}. %{DATA:event.reason}$"
        - "^%{DATA:azure.firewall.proto} request from %{IPORHOST:source.address}:%{NUMBER:source.port:long}. Action: %{DATA:azure.firewall.action}. Reason: %{DATA:event.reason}$"

  - set:
      field: json.event.alert.action
      value: denied
      if: ctx.azure?.firewall?.action == 'Deny'
  - set:
      field: json.event.alert.action
      value: allowed
      if: ctx.azure?.firewall?.action == 'Allow'
  - append:
      field: event.type
      value: "{{json.event.alert.action}}"
      if: ctx.json?.event?.alert?.action != null

  - grok:
      field: source.address
      patterns:
        - "%{IP:source.ip}"
        - "%{HOSTNAME:source.domain}"
      ignore_missing: true
      
  - grok:
      field: destination.address
      patterns:
        - "%{IP:destination.ip}"
        - "%{HOSTNAME:destination.domain}"
      ignore_missing: true

  - append:
      if: ctx?.source?.ip != null
      field: related.ip
      value: "{{source.ip}}"
      allow_duplicates: false
      ignore_failure: true
  - append:
      if: ctx?.destination?.ip != null
      field: related.ip
      value: "{{destination.ip}}"
      allow_duplicates: false
      ignore_failure: true
  - append:
      if: ctx?.source?.domain != null
      field: related.hosts
      value: "{{source.domain}}"
      allow_duplicates: false
      ignore_failure: true
  - append:
      if: ctx?.destination?.domain != null
      field: related.hosts
      value: "{{destination.domain}}"
      allow_duplicates: false
      ignore_failure: true

  - lowercase:
      field: azure.firewall.proto
      ignore_failure: true
  - set:
      field: network.transport
      value: "{{azure.firewall.proto}}"
      if: "ctx?.azure?.firewall?.proto != null && ['udp', 'tcp', 'icmp'].contains(ctx.azure.firewall.proto)"
  - set:
      field: network.protocol
      value: "{{azure.firewall.proto}}"
      if: "ctx?.network?.transport == null"
  - remove:
      field:
        - azure.firewall.proto
      ignore_missing: true

  - script:
      lang: painless
      ignore_failure: true
      if: ctx?.network?.transport != null
      source: |
        def transport = ctx.network.transport;
        if (transport == 'udp') {
            ctx.network.iana_number = '17';
        } else if (transport == 'tcp') {
            ctx.network.iana_number = '6';
        }
  
on_failure:
  - append:
      field: error.message
      value: >-
        error in Application pipeline:
        error in [{{_ingest.on_failure_processor_type}}] processor{{#_ingest.on_failure_processor_tag}}
        with tag [{{_ingest.on_failure_processor_tag }}]{{/_ingest.on_failure_processor_tag}}
        {{ _ingest.on_failure_message }}