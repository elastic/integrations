---
description: Pipeline for rerouting logs streams from Amazon Data Firehose.
processors:
  - set:
      field: ecs.version
      value: 8.11.0
  - script:
      lang: painless
      source: |
        if (ctx.message == null) {
            return;
        }
        // Initialize event object if it doesn't exist
        if (ctx.event == null) {
            ctx.event = [:];
        }
        
        // AWS WAF Logs
        def message_lower = ctx.message.toLowerCase();
        
        if (ctx['aws.kinesis.name'] != null && ctx['aws.kinesis.name'].contains('aws-waf-logs-') ||
            (ctx['aws.cloudwatch.log_group'] != null && ctx['aws.cloudwatch.log_group'].contains('aws-waf-logs-'))) {
            ctx.event.dataset = 'aws.waf';
        }
        else if (message_lower.contains('webaclid') && message_lower.contains('terminatingrule') &&
                 message_lower.contains('httpsource') && message_lower.contains('rulegrouplist')) {
            ctx.event.dataset = 'aws.waf';
        }
        
        // AWS CloudTrail Logs
        else if (ctx['aws.cloudwatch.log_stream'] != null && ctx['aws.cloudwatch.log_stream'].contains('CloudTrail')) {
            ctx.event.dataset = 'aws.cloudtrail';
        }

        // AWS VPC Flow Logs
        else if (message_lower.contains('"eni-') && message_lower.contains('"vpc-') && message_lower.contains('accept') || message_lower.contains('reject')) {
            ctx.event.dataset = 'aws.vpcflow';
        }

        // AWS Firewall Logs
        else if (message_lower.contains('"firewall_name":') && message_lower.contains('"availability_zone":') &&
                 message_lower.contains('"event_timestamp":') && message_lower.contains('"event":')) {
            ctx.event.dataset = 'aws.firewall_logs';
        }
        
        // AWS Route53 Resolver Logs - This needs to be before the Route53 Public Logs
        else if (message_lower.contains('"version":') && message_lower.contains('"account_id":') && message_lower.contains('"region":') &&
                 message_lower.contains('"vpc_id":') && message_lower.contains('"query_timestamp":')) {
            ctx.event.dataset = 'aws.route53_resolver_logs';
        }
        
        // AWS Route53 Public Logs
        else if (ctx['aws.cloudwatch.log_group'] != null && ctx['aws.cloudwatch.log_group'].contains('/aws/route53/')) {
            if (ctx.message.contains("T") && ctx.message.contains("Z") && ctx.message.contains("NOERROR") && ctx.message.contains("UDP")) {
                ctx.event.dataset = 'aws.route53_public_logs';
            }
        }
        
        // AWS API Gateway Logs
        else if (message_lower.contains('"requestid":') && message_lower.contains('"ip":')
                 && (message_lower.contains('"requesttime":') || message_lower.contains('"request_time":'))
                 && (message_lower.contains('"httpmethod":') || message_lower.contains('"eventtype":'))) {
            ctx.event.dataset = 'aws.apigateway_logs';
        }
        
        // AWS S3 Access Logs, CloudFront, and ELB Logs
        else {
            // Inlined logic for splitting tokens
            // Note - Tokenization split Time field into two sections, hence token count after index 3 (0 based) is increased by 1
            def tokens_result = new ArrayList();
            StringBuilder currentToken = new StringBuilder();
            boolean insideQuotes = false;
            for (int i = 0; i < ctx.message.length(); i++) {
                char c = ctx.message.charAt(i);
                if (c.toString().equals("\"")) {
                    insideQuotes = !insideQuotes;
                    currentToken.append(c);
                } else if (c.toString().equals(" ") && !insideQuotes) {
                    if (currentToken.length() > 0) {
                        tokens_result.add(currentToken.toString());
                    }
                    currentToken = new StringBuilder();
                } else {
                    currentToken.append(c);
                }
            }
            if (currentToken.length() > 0) {
                tokens_result.add(currentToken.toString()); // Add the last token
            }
            def tokens = tokens_result.toArray(new String[0]);
            def tokenCount = tokens.length;
        
            // Check for S3 Access logs
            if (tokenCount >= 24) {
                def hostHeader = tokens[23];
                if (hostHeader.contains('s3') && hostHeader.contains('amazonaws.com')) {
                    ctx.event.dataset = 'aws.s3access';
                    return;
                } 

                // Check for Operation field content. Refer - https://docs.aws.amazon.com/AmazonS3/latest/userguide/LogFormat.html#log-record-fields
                def opField = tokens[7];
                if (opField.startsWith("SOAP.") || opField.startsWith("REST.") || opField.startsWith("BATCH.") || opField.startsWith("WEBSITE.") || opField.startsWith("S3.")) {
                     ctx.event.dataset = 'aws.s3access';
                     return;
                }
            }
        
            // Fallback to CloudFront and ELB if S3 check fails
            if (ctx.event.dataset == null) {
                // AWS CloudFront Logs - Updated logic
                if (tokenCount == 33) {
                    String date = tokens[0];
                    String time = tokens[1];
                    if (date != null && time != null &&
                        date.length() == 10 && date.substring(4, 5).equals("-") && date.substring(7, 8).equals("-") &&
                        time.length() == 8 && time.substring(2, 3).equals(":") && time.substring(5, 6).equals(":")) {
                        ctx.event.dataset = 'aws.cloudfront_logs';
                    }
                }
                // AWS ELB Logs - Updated logic to handle multiple log types
                else if (tokens.length > 0 && (tokens[0].equals("http") || tokens[0].equals("https") || tokens[0].equals("tcp") || tokens[0].equals("tls") || tokens[0].equals("udp"))) {
                    // This identifies ALBs and NLBs
                    ctx.event.dataset = 'aws.elb_logs';
                }
                else if ((tokenCount == 15 || tokenCount == 29 || tokenCount == 22)) { // For classic ELBs
                    if (tokens.length >= 4) {
                        boolean token2IsIpPort = tokens[2].contains(':');
                        boolean token3IsIpPort = tokens[3].contains(':');
        
                        try {
                            Double.parseDouble(tokens[4]);
                            if (token2IsIpPort && token3IsIpPort) {
                                ctx.event.dataset = 'aws.elb_logs';
                            }
                        } catch (Exception e) {
                            // Token 4 is not a number, so this is not an ELB log
                        }
                    }
                }
            }
        }
      ignore_failure: true

on_failure:
  - set:
      field: error.message
      value: "{{ _ingest.on_failure_message }}"
