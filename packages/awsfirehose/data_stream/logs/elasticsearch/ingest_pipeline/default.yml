description: Pipeline for rerouting logs streams from Amazon Data Firehose.
processors:
  - set:
      field: ecs.version
      value: 8.11.0
  - script:
      lang: painless
      source: |
        if (ctx.message == null) {
            return;
        }
        // Initialize event object if it doesn't exist
        if (ctx.event == null) {
            ctx.event = [:];
        }
        
        // AWS WAF Logs
        if (ctx['aws.kinesis.name'] != null && ctx['aws.kinesis.name'].contains('aws-waf-logs-')) {
            ctx.event.dataset = 'aws.waf';
        }
        else if (ctx['aws.cloudwatch.log_group'] != null && ctx['aws.cloudwatch.log_group'].contains('aws-waf-logs-')) {
            ctx.event.dataset = 'aws.waf';
        }
        else if (ctx.message.contains('webaclld') && ctx.message.contains('terminatingRule') &&
                 ctx.message.contains('httpSource') && ctx.message.contains('ruleGroupList') && ctx.message.contains('rateBasedRuleList') &&
                 ctx.message.contains('nonTerminatingMatchingRules') && ctx.message.contains('httpRequest') && ctx.message.contains('labels')) {
            ctx.event.dataset = 'aws.waf';
        }
        // AWS CloudTrail Logs
        else if (ctx['aws.cloudwatch.log_stream'] != null && ctx['aws.cloudwatch.log_stream'].contains('CloudTrail')) {
            ctx.event.dataset = 'aws.cloudtrail';
        }
        // AWS VPC Flow Logs
        else if (ctx.message.splitOnToken(" ").length == 14) {
            ctx.event.dataset = 'aws.vpcflow';
        }
        // AWS Firewall Logs
        else if (ctx.message.contains('firewall_name') && ctx.message.contains('availability_zone') &&
                 ctx.message.contains('event_timestamp') && ctx.message.contains('event')) {
            ctx.event.dataset = 'aws.firewall_logs';
        }
        // AWS Route53 Resolver Logs - This needs to be before the Route53 Public Logs
        else if (ctx.message != null && ctx.message.contains('version') && ctx.message.contains('account_id') && ctx.message.contains('region') &&
                 ctx.message.contains('vpc_id') && ctx.message.contains('query_timestamp') && ctx.message.contains('query_name') &&
                 ctx.message.contains('query_type') && ctx.message.contains('query_class') && ctx.message.contains('rcode') &&
                 ctx.message.contains('answers') && ctx.message.contains('srcaddr') && ctx.message.contains('srcport') &&
                 ctx.message.contains('transport') && ctx.message.contains('srcids')) {
            ctx.event.dataset = 'aws.route53_resolver_logs';
        }
        // AWS Route53 Public Logs
        else if (ctx['aws.cloudwatch.log_stream'] != null && ctx['aws.cloudwatch.log_group'] != null && 
                 ctx['aws.cloudwatch.log_group'].contains('/aws/route53/')) {
            def split_log_stream_name = ctx['aws.cloudwatch.log_stream'].splitOnToken('/');
            if (split_log_stream_name.length == 2) {
                def hosted_zone_id = split_log_stream_name[0];
                def edge_location_id = split_log_stream_name[1];
                if (ctx.message != null && ctx.message.contains(hosted_zone_id) && ctx.message.contains(edge_location_id)) {
                    ctx.event.dataset = 'aws.route53_public_logs';
                }
            }
        }
        // AWS API Gateway Logs - This needs to be before the S3 Access Logs 
        else if ((ctx.message != null && ctx.message.contains('requestId') && ctx.message.contains('ip')
                 && ctx.message.contains('requestTime') && ctx.message.contains('httpMethod') && ctx.message.contains('routeKey')
                 && ctx.message.contains('status') && ctx.message.contains('protocol') && ctx.message.contains('responseLength'))
                || (ctx.message != null && ctx.message.contains('requestId') && ctx.message.contains('ip') && ctx.message.contains('caller')
                 && ctx.message.contains('user') && ctx.message.contains('requestTime') && ctx.message.contains('httpMethod')
                 && ctx.message.contains('resourcePath') && ctx.message.contains('status') && ctx.message.contains('protocol')
                 && ctx.message.contains('responseLength'))
                || (ctx.message != null && ctx.message.contains('requestId') && ctx.message.contains('ip') && ctx.message.contains('caller')
                 && ctx.message.contains('user') && ctx.message.contains('requestTime') && ctx.message.contains('eventType')
                 && ctx.message.contains('routeKey') && ctx.message.contains('status') && ctx.message.contains('connectionId'))) {
            ctx.event.dataset = 'aws.apigateway_logs';
        }
        // AWS S3 Access Logs
        else if (ctx.message.length() > 0) {
            int tokenCount = 1;
            StringBuilder currentToken = new StringBuilder();
            String hostHeader = "-";
            boolean insideQuotes = false;
            for (int i = 0; i < ctx.message.length(); i++) {
                String c = String.valueOf(ctx.message.charAt(i));
                if (c.equals(" ") && !insideQuotes) {
                    tokenCount++;
                    if (tokenCount == 24) {
                        hostHeader = currentToken.toString();
                    }
                    currentToken = new StringBuilder();
                } else if (c.equals("\"")) {
                    insideQuotes = !insideQuotes;
                    currentToken.append(c);
                } else {
                    currentToken.append(c);
                }
            }
            if (hostHeader != "-" && hostHeader.contains('s3') && hostHeader.contains('amazonaws.com')) {
                ctx.event.dataset = 'aws.s3access';
            } else if (tokenCount == 25) {
                ctx.event.dataset = 'aws.s3access';
            } else {
                tokenCount = 1;
                insideQuotes = false;
                for (int i = 0; i < ctx.message.length(); i++) {
                    String c = String.valueOf(ctx.message.charAt(i));
                    if (c.equals(" ") && !insideQuotes) {
                        tokenCount++;
                    } else if (c.equals("\"")) {
                        insideQuotes = !insideQuotes;
                    }
                }
                // AWS CloudFront Logs
                if (tokenCount==33 && ctx.message =~ /^\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}\s[a-zA-Z0-9-]+\s\d+\s(\d+\.\d+\.\d+\.\d+|[a-fA-F0-9:]+)/) {
                    ctx.event.dataset = 'aws.cloudfront_logs';
                }
                //AWS ELB Logs
                else if ((tokenCount == 15 || tokenCount == 29 || tokenCount == 22) && 
                (ctx.message =~ /.*\s(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d{1,5})|([0-9a-fA-F:.]+:\d{1,5})\s(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d{1,5})|([0-9a-fA-F:.]+:\d{1,5})\s-?\d+(\.\d+)?\s/)) {
                ctx.event.dataset = 'aws.elb_logs';
                }
            }
        }
        
      ignore_failure: true
    
on_failure:
  - set:
      field: error.message
      value: "{{ _ingest.on_failure_message }}"
