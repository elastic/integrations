config_version: 2
interval: {{interval}}
resource.tracer:
  enabled: {{enable_request_tracer}}
  filename: "../../logs/cel/http-request-trace-*.ndjson"
  maxbackups: 5
{{#if proxy_url}}
resource.proxy_url: {{proxy_url}}
{{/if}}
{{#if ssl}}
resource.ssl: {{ssl}}
{{/if}}
{{#if http_client_timeout}}
resource.timeout: {{http_client_timeout}}
{{/if}}
resource.url: {{url}}
state:
  access_key: {{access_key}}
  secret_key: {{secret_key}}
redact:
  fields:
    - access_key
    - secret_key
program: |
  // Using worklist pattern: fetch scans, then process one at a time fetching details for each
  state.with(
    // If worklist has scans, skip fetching and proceed to details
    (has(state.worklist) && size(state.worklist) > 0) ?
      {}
    :
      // Fetch all scans and populate worklist
      request("GET", state.url.trim_right("/") + "/scans").with({
        "Header": {
          "X-ApiKeys": ["accessKey=" + state.access_key + ";secretKey=" + state.secret_key],
          "User-Agent": ["Integration/1.0 (Elastic; Tenable.io; Build/3.0.0)"]
        }
      }).do_request().as(resp,
        resp.StatusCode == 200 ?
          bytes(resp.Body).decode_json().as(body, {
            "worklist": has(body.scans) ? body.scans : [],
          })
        :
          {
            "events": {
              "error": {
                "code": string(resp.StatusCode),
                "id": string(resp.Status),
                "message": "GET /scans: " + (
                  size(resp.Body) != 0 ?
                    string(resp.Body)
                  :
                    string(resp.Status) + ' (' + string(resp.StatusCode) + ')'
                )
              }
            },
            "want_more": false
          }
      )
  ).as(state,
    // Process first scan in worklist
    (has(state.worklist) && size(state.worklist) > 0) ?
      state.worklist[0].as(scan,
        state.with(
          request("GET", state.url.trim_right("/") + "/was/v2/scans/" + string(scan.id)).with({
            "Header": {
              "X-ApiKeys": ["accessKey=" + state.access_key + ";secretKey=" + state.secret_key],
              "User-Agent": ["Integration/1.0 (Elastic; Tenable.io; Build/3.0.0)"]
            }
          }).do_request().as(details_resp,
            details_resp.StatusCode == 200 ?
              bytes(details_resp.Body).decode_json().as(scan_details, {
                "events": [{"message": scan.with({"scan_details": scan_details}).encode_json()}],
                "worklist": size(state.worklist) > 1 ? tail(state.worklist) : [],
                "want_more": size(state.worklist) > 1
              })
            :
              {
                "events": {
                  "error": {
                    "code": string(details_resp.StatusCode),
                    "id": string(details_resp.Status),
                    "message": "GET /was/v2/scans/" + string(scan.id) + ": " + (
                      size(details_resp.Body) != 0 ?
                        string(details_resp.Body)
                      :
                        string(details_resp.Status) + ' (' + string(details_resp.StatusCode) + ')'
                    )
                  }
                },
                "worklist": size(state.worklist) > 1 ? tail(state.worklist) : [],
                "want_more": size(state.worklist) > 1
              }
          )
        )
      )
    :
      // No worklist or worklist is empty - pass through state
      state
  )
  
tags:
{{#if preserve_original_event}}
  - preserve_original_event
{{/if}}
{{#if preserve_duplicate_custom_fields}}
  - preserve_duplicate_custom_fields
{{/if}}
{{#each tags as |tag|}}
  - {{tag}}
{{/each}}
{{#contains "forwarded" tags}}
publisher_pipeline.disable_host: true
{{/contains}}
{{#if processors}}
processors:
{{processors}}
{{/if}}
