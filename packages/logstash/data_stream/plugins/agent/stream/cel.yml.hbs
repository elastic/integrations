config_version: "2"
interval: {{period}}
resource.url: "{{url}}/_node"
{{#if resource_ssl}}
resource.ssl:
  {{resource_ssl}}
{{/if}}

{{#if username}}
auth.basic.user: {{escape_string username}}
{{/if}}
{{#if password}}
auth.basic.password: {{escape_string password}}
{{/if}}

redact:
  fields: ~

program: |
  get(state.url + "/stats?graph=true&vertices=true")
  .as(resp, bytes(resp.Body)
  .decode_json().as(body,
    body.pipelines.map(pipeline_name, pipeline_name != ".monitoring-logstash", {"name":pipeline_name}.with(body.pipelines[pipeline_name])
      .with({
        "pipeline_source_map":
          get(state.url + "/pipelines/" + pipeline_name + "?graph=true&vertices=true")
            .as(resp, bytes(resp.Body).decode_json()
              .as(body, body.pipelines.map(pipeline_name, ((body.pipelines[pipeline_name].graph.graph.vertices)
                .as(vertices, vertices.map(each, each.type == "plugin", {"plugin_id":each.id, "source":each.meta.source})
                )
              )
            ).drop("graph").flatten()
          )
        ),
        "es_cluster_id":((body.pipelines[pipeline_name].vertices).as(vertices, vertices.map(each, has(each.cluster_uuid), each.cluster_uuid))),
        "es_cluster_id_map":((body.pipelines[pipeline_name].vertices).as(vertices, vertices.map(each, has(each.cluster_uuid), {"plugin_id":each.id, "cluster_id":each.cluster_uuid}))),
        "counter_map":((body.pipelines[pipeline_name].vertices).as(vertices, vertices.map(each, has(each.long_counters), each.long_counters.map(counter, {"plugin_id":each.id, "name":counter.name, "value":counter.value})))),
        "outputs":body.pipelines[pipeline_name].plugins.outputs,
        "inputs":body.pipelines[pipeline_name].plugins.inputs,
        "filters":body.pipelines[pipeline_name].plugins.filters,
        "codecs":body.pipelines[pipeline_name].plugins.codecs,
        "host":{
          "name":body.name,
          "address":body.http_address,
        }
      })
    )
    )).as(events, events.map(event,
    {
      "inputs":event.inputs.map(input,
      {
        "name":event.name,
        "id":event.hash,
        "host":event.host,
        "elasticsearch.cluster.id":event.es_cluster_id,
        "plugin":{
          "type":"input",
          "input":{
            "source":event.pipeline_source_map.map(tuple, (tuple.plugin_id == input.id), tuple.source)[0],
            "elasticsearch.cluster.id":event.es_cluster_id_map.map(tuple, (tuple.plugin_id == input.id), tuple.cluster_id),
            "metrics":{input.name:zip(event['counter_map'].flatten().map(tuple, (tuple.plugin_id == input.id), tuple.name),
                event['counter_map'].flatten().map(tuple, (tuple.plugin_id == input.id), tuple.value))},
            "name":input.name,
            "id":input.id,
            "flow": has(input.flow) ? input.flow : {},
            "events":{
              "out":input.events.out,
            },
            "time":{
              "queue_push_duration":{
                "ms":input.events.queue_push_duration_in_millis
              }
            }
          }
        }
      }.drop_empty()
      ),
      "codecs":event.codecs.map(codec,
      {
        "name":event.name,
        "id":event.hash,
        "host":event.host,
        "elasticsearch.cluster.id":event.es_cluster_id,
        "plugin":{
          "type":"codec",
          "codec":{
          "id":codec.id,
          "name":codec.name,
            "flow": has(codec.flow) ? codec.flow : {},
            "decode":{
              "duration":{
                "ms":codec.decode.duration_in_millis
              },
              "in":codec.decode.writes_in,
              "out":codec.decode.out,
            },
            "encode":{
              "in":codec.encode.writes_in,
              "duration":{
                "ms":codec.encode.duration_in_millis
              }
            }
          }
        }
      }.drop_empty()
      ),
      "filters":event.filters.map(filter,
      {
        "name":event.name,
        "id":event.hash,
        "host":event.host,
        "elasticsearch.cluster.id":event.es_cluster_id,
        "plugin":{
          "type":"filter",
          "filter":{
            "source":event.pipeline_source_map.map(tuple, (tuple.plugin_id == filter.id), tuple.source).flatten()[0],
            "id":filter.id,
            "name":filter.name,
            "elasticsearch.cluster.id":event.es_cluster_id_map.map(tuple, (tuple.plugin_id == filter.id), tuple.cluster_id),
            "metrics":{filter.name:zip(event['counter_map'].flatten().map(tuple, (tuple.plugin_id == filter.id), tuple.name),
                event['counter_map'].flatten().map(tuple, (tuple.plugin_id == filter.id), tuple.value))},
            "flow": has(filter.flow) ? filter.flow : {},
            "events":{
              "in":filter.events['in'],
              "out":filter.events.out,
            },
            "time":{
              "duration":{
                "ms":filter.events.duration_in_millis
              }
            }
          }
        }
      }.drop_empty()
      ),
      "outputs":event.outputs.map(output,
      {
        "name":event.name,
        "id":event.hash,
        "host":event.host,
        "elasticsearch.cluster.id":event.es_cluster_id,
        "plugin":{
          "type":"output",
          "output":{
            "id":output.id,
            "name":output.name,
            "source":event.pipeline_source_map.map(tuple, (tuple.plugin_id == output.id), tuple.source).flatten()[0],
            "elasticsearch.cluster.id":event.es_cluster_id_map.map(tuple, (tuple.plugin_id == output.id), tuple.cluster_id),
            "metrics":{output.name:zip(event['counter_map'].flatten().map(tuple, (tuple.plugin_id == output.id), tuple.name),
                event['counter_map'].flatten().map(tuple, (tuple.plugin_id == output.id), tuple.value))},
            "flow": has(output.flow) ? output.flow : {},
            "events":{
              "in":output.events['in'],
              "out":output.events.out,
            },
            "time":{
              "duration":{
                "ms":output.events.duration_in_millis
              }
            }
          }
        }
      }.drop_empty()
      )
    }).collate(["filters", "outputs", "inputs", "codecs"])).as(plugins, {
      "events":plugins.map(plugin, {"logstash":{"pipeline":plugin}})})