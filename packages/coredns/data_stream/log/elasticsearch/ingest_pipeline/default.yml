---
description: "Pipeline for parsing CoreDNS logs."
processors:
  - set:
      field: ecs.version
      value: '8.3.0'
  - rename:
      field: message
      target_field: event.original
  - set:
      field: event.kind
      value: event
  - set:
      field: event.category
      value: network
  - grok:
      field: event.original
      patterns:
      - '\[%{LOGLEVEL:log.level}\] \[?%{IP:source.address}\]?:%{POSINT:source.port:long} - %{POSINT:dns.id} "%{WORD:dns.question.type} %{WORD:dns.question.class} 
         %{IPORHOST:dns.question.name}\. %{WORD:network.transport} %{POSINT:source.bytes:long} %{WORD:coredns.log.edns0.do:boolean} %{POSINT:coredns.log.edns0.buffer_size:long}" 
         %{WORD:dns.response_code} %{NOTSPACE:dns.header_flags} %{POSINT:destination.bytes:long} %{NOTSPACE:event.duration}s( "%{NONNEGINT:dns.op_code}")?'
      ignore_missing: true
      ecs_compatibility: v1
    #   on_failure:
    #     - drop:
    #         description: Drop if a log other than query
  - lowercase:
      field: network.transport
      ignore_missing: true
  - set:
      field: network.iana_number
      value: '6'
      if: ctx.network?.transport == "tcp"
  - set:
      field: network.iana_number
      value: '17'
      if: ctx.network?.transport == "udp"
  - set:
      field: network.protocol
      value: dns
  - registered_domain:
      field: dns.question.name
      target_field: dns.question
  - remove:
      field: dns.question.domain
      ignore_missing: true
  - uppercase:
      field: dns.header_flags
      ignore_missing: true
  - split:
      field: dns.header_flags
      separator: ","
      ignore_missing: true
  - set: 
      field: event.outcome
      value: success
      if: ctx?.dns?.response_code != null && ctx?.dns?.response_code == "NOERROR"
  - set: 
      field: event.outcome
      value: failure
      if: ctx?.dns?.response_code != null && ctx?.dns?.response_code != "NOERROR"
  - script:
      lang: painless
      if: ctx.event?.duration != null
      params:
        S_TO_NS: 1000000000
      source: >-
        double f = Double.parseDouble(ctx.event.duration);
        ctx.event.duration = f * params.S_TO_NS;
  - convert:
      field: source.address
      target_field: source.ip
      type: ip
      ignore_failure: true
  - geoip:
      field: source.ip
      target_field: source.geo
      ignore_missing: true
  - geoip:
      database_file: GeoLite2-ASN.mmdb
      field: source.ip
      target_field: source.as
      properties:
      - asn
      - organization_name
      ignore_missing: true
  - rename:
      field: source.as.asn
      target_field: source.as.number
      ignore_missing: true
  - rename:
      field: source.as.organization_name
      target_field: source.as.organization.name
      ignore_missing: true
  - append:
      field: related.ip
      value: "{{source.ip}}"
      allow_duplicates: false
      if: ctx.source?.ip != null
  - append:
      field: related.hosts
      value: "{{dns.question.name}}"
      allow_duplicates: false
      if: ctx.dns?.question?.name != null
  - script:
      lang: painless
      description: This script processor iterates over the whole document to remove fields with null values.
      source: |
        void handleMap(Map map) {
          for (def x : map.values()) {
            if (x instanceof Map) {
                handleMap(x);
            } else if (x instanceof List) {
                handleList(x);
            }
          }
          map.values().removeIf(v -> v == null);
        }
        void handleList(List list) {
          for (def x : list) {
              if (x instanceof Map) {
                  handleMap(x);
              } else if (x instanceof List) {
                  handleList(x);
              }
          }
        }
        handleMap(ctx);
  - remove:
      field: event.original
      if: "ctx?.tags == null || !(ctx.tags.contains('preserve_original_event'))"
      ignore_failure: true
      ignore_missing: true
on_failure:
  - set:
      field: error.message
      value: '{{ _ingest.on_failure_message }}'
