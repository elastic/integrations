config_version: 2
interval: {{interval}}
resource.tracer:
  enabled: {{enable_request_tracer}}
  filename: "../../logs/cel/http-request-trace-*.ndjson"
  maxbackups: 5
{{#if proxy_url}}
resource.proxy_url: {{proxy_url}}
{{/if}}
{{#if ssl}}
resource.ssl: {{ssl}}
{{/if}}
{{#if http_client_timeout}}
resource.timeout: {{http_client_timeout}}
{{/if}}
resource.url: {{url}}
auth.oauth2:
  provider: azure
  client.id: {{client_id}}
  client.secret: {{client_secret}}
  scopes:
{{#each token_scopes as |token_scope|}}
    - {{token_scope}}
{{/each}}
{{#if token_url}}
  token_url: {{token_url}}/{{azure_tenant_id}}/oauth2/v2.0/token
{{else if azure_tenant_id}}
  azure.tenant_id: {{azure_tenant_id}}
{{/if}}

state:
  product_batch_size: 10000
  product_skip: 0
  machine_batch_size: 10000
  machine_skip: 0
  vulnerabilities_batch_size: {{batch_size}}  
  vulnerabilities_skip: 0
  affected_machines_only: {{affected_machines_only}}
redact:
  fields: ~
program: |-
  state.with(
    // Get products.
    (
      state.?is_all_products_fetched.orValue(false) ?
        {
          "products": state.products,
          "product_batch_size": state.product_batch_size,
          "product_skip": 0,
          "is_all_products_fetched": state.is_all_products_fetched,
          ?"machines": state.?machines,
          "machine_batch_size": state.machine_batch_size,
          "machine_skip": state.machine_skip,
          ?"is_all_machines_fetched": state.?is_all_machines_fetched,
          ?"vulnerabilities": state.?vulnerabilities,
          "vulnerabilities_batch_size": state.vulnerabilities_batch_size,
          "vulnerabilities_skip": state.vulnerabilities_skip,
          ?"is_all_vulnerabilities_fetched": state.?is_all_vulnerabilities_fetched,
          "affected_machines_only": state.affected_machines_only,
        }
      :
        request(
          "GET",
          state.url.trim_right("/") + "/api/vulnerabilities/machinesVulnerabilities?" + {
            "$top": [string(state.product_batch_size)],
            "$skip": [string(state.product_skip)],
          }.format_query()
        ).do_request().as(productResp, (productResp.StatusCode == 200) ?
          productResp.Body.decode_json().as(productBody,
            {
              "events": [{"message": "retry"}],
              "products": (state.?products.orValue([]) + productBody.value).flatten(),
              "product_batch_size": state.product_batch_size,
              "product_skip": (size(productBody.value) > 0) ? (int(state.product_skip) + int(state.product_batch_size)) : 0,
              "is_all_products_fetched": size(productBody.value) < int(state.product_batch_size),
              "want_more": true,
              "machine_batch_size": state.machine_batch_size,
              "machine_skip": state.machine_skip,
              "vulnerabilities_batch_size": state.vulnerabilities_batch_size,
              "vulnerabilities_skip": state.vulnerabilities_skip,
              "affected_machines_only": state.affected_machines_only,
            }
          )
        :
          {
            "events": {
              "error": {
                "code": string(productResp.StatusCode),
                "id": string(productResp.Status),
                "message": "GET " + state.url.trim_right("/") + "/api/vulnerabilities/machinesVulnerabilities" + (
                  (size(productResp.Body) != 0) ?
                    string(productResp.Body)
                  :
                    string(productResp.Status) + " (" + string(productResp.StatusCode) + ")"
                ),
              },
            },
            "want_more": false,
            "products": [],
            "product_skip": 0,
            "is_all_products_fetched": false,
            "machines": [],
            "machine_skip": 0,
            "is_all_machines_fetched": false,
            "vulnerabilities": [],
            "vulnerabilities_skip": 0,
            "is_all_vulnerabilities_fetched": false,
          }
        )
    ).as(res, !res.?is_all_products_fetched.orValue(false) ?
      res
    : res.?is_all_machines_fetched.orValue(false) ?
      {
        "products": res.products,
        "product_batch_size": res.product_batch_size,
        "product_skip": 0,
        "is_all_products_fetched": res.is_all_products_fetched,
        "machines": res.machines,
        "machine_batch_size": res.machine_batch_size,
        "machine_skip": 0,
        "is_all_machines_fetched": res.is_all_machines_fetched,
        ?"vulnerabilities": res.?vulnerabilities,
        "vulnerabilities_batch_size": res.vulnerabilities_batch_size,
        "vulnerabilities_skip": res.vulnerabilities_skip,
        ?"is_all_vulnerabilities_fetched": res.?is_all_vulnerabilities_fetched,
        "affected_machines_only": res.affected_machines_only,
      }
    :
      request(
        "GET",
        state.url.trim_right("/") + "/api/machines?" + {
          "$top": [string(res.machine_batch_size)],
          "$skip": [string(res.machine_skip)],
        }.format_query()
      ).do_request().as(machineResp, (machineResp.StatusCode == 200) ?
        machineResp.Body.decode_json().as(machineBody,
          {
            "events": [{"message": "retry"}],
            "machines": (res.?machines.orValue([]) + machineBody.value).flatten(),
            "machine_batch_size": res.machine_batch_size,
            "machine_skip": (size(machineBody.value) > 0) ? (int(res.machine_skip) + int(res.machine_batch_size)) : 0,
            "is_all_machines_fetched": size(machineBody.value) < int(res.machine_batch_size),
            "want_more": true,
            "products": res.products,
            "product_batch_size": res.product_batch_size,
            "product_skip": 0,
            "is_all_products_fetched": res.is_all_products_fetched,
            "vulnerabilities_batch_size": res.vulnerabilities_batch_size,
            "vulnerabilities_skip": res.vulnerabilities_skip,
            "affected_machines_only": res.affected_machines_only,
          }
        )
      :
        {
          "events": {
            "error": {
              "code": string(machineResp.StatusCode),
              "id": string(machineResp.Status),
              "message": "GET " + state.url.trim_right("/") + "/api/machines" + (
                (size(machineResp.Body) != 0) ?
                  string(machineResp.Body)
                :
                  string(machineResp.Status) + " (" + string(machineResp.StatusCode) + ")"
              ),
            },
          },
          "want_more": false,
          "products": [],
          "product_skip": 0,
          "is_all_products_fetched": false,
          "machines": [],
          "machine_skip": 0,
          "is_all_machines_fetched": false,
          "vulnerabilities": [],
          "vulnerabilities_skip": 0,
          "is_all_vulnerabilities_fetched": false,
        }
      )
    // Get products with machines.
    ).as(res, !res.?is_all_machines_fetched.orValue(false) ?
      res
    : res.?is_all_vulnerability_fetched.orValue(false) ?
      {
        "products": res.products,
        "product_batch_size": res.product_batch_size,
        "product_skip": 0,
        "is_all_products_fetched": res.is_all_products_fetched,
        "machines": res.machines,
        "machine_batch_size": res.machine_batch_size,
        "machine_skip": 0,
        "is_all_machines_fetched": res.is_all_machines_fetched,
        "vulnerabilities": res.vulnerabilities,
        "vulnerabilities_batch_size": res.vulnerabilities_batch_size,
        "vulnerabilities_skip": 0,
        "is_all_vulnerability_fetched": res.is_all_vulnerability_fetched,
        "affected_machines_only": res.affected_machines_only,
      }
    :
      request(
        "GET",
        state.url.trim_right("/") + "/api/vulnerabilities?" + {
          "$top": [string(res.vulnerabilities_batch_size)],
          "$skip": [string(res.vulnerabilities_skip)],
        }.format_query()
      ).do_request().as(vulnerabilityResp, (vulnerabilityResp.StatusCode == 200) ?
        vulnerabilityResp.Body.decode_json().as(vulnerabilityBody,
          {
            "events": [{"message": "retry"}],
            "vulnerabilities": (res.?vulnerabilities.orValue([]) + vulnerabilityBody.value).flatten(),
            "vulnerabilities_batch_size": state.vulnerabilities_batch_size,
            "vulnerabilities_skip": (size(vulnerabilityBody.value) > 0) ? (int(res.vulnerabilities_skip) + int(res.vulnerabilities_batch_size)) : 0,
            "is_all_vulnerabilities_fetched": size(vulnerabilityBody.value) < int(res.vulnerabilities_batch_size),
            "want_more": true,
            "products": res.products,
            "product_batch_size": res.product_batch_size,
            "product_skip": 0,
            "is_all_products_fetched": res.is_all_products_fetched,
            "machines": res.machines,
            "machine_batch_size": res.machine_batch_size,
            "machine_skip": 0,
            "is_all_machines_fetched": res.is_all_machines_fetched,
            "affected_machines_only": res.affected_machines_only,
          }
        )
      :
        {
          "events": {
            "error": {
              "code": string(vulnerabilityResp.StatusCode),
              "id": string(vulnerabilityResp.Status),
              "message": "GET " + state.url.trim_right("/") + "/api/vulnerabilities" + (
                (size(vulnerabilityResp.Body) != 0) ?
                  string(vulnerabilityResp.Body)
                :
                  string(vulnerabilityResp.Status) + " (" + string(vulnerabilityResp.StatusCode) + ")"
              ),
            },
          },
          "want_more": false,
          "products": [],
          "product_skip": 0,
          "is_all_products_fetched": false,
          "machines": [],
          "machine_skip": 0,
          "is_all_machines_fetched": false,
          "vulnerabilities": [],
          "vulnerabilities_skip": 0,
          "is_all_vulnerabilities_fetched": false,
        }
      )
    // Collate data.
    ).as(res, !res.?is_all_vulnerabilities_fetched.orValue(false) ?
      res
    :
      res.products.map(p, res.machines.filter(m, m.id == p.machineId)[0].with(p)).as(mapped_products,
        {
          "vulnerability_with_machines": res.vulnerabilities.filter(v, v.exposedMachines > 0),
          "vulnerability_without_machines": !res.affected_machines_only ?
            res.vulnerabilities.filter(v, v.exposedMachines == 0)
          :
            [],
          "mapped_products": mapped_products,
        }
      ).as(final_data,
        {
          "events": (
            final_data.vulnerability_with_machines.map(v,
              final_data.mapped_products.filter(mp, mp.cveId == v.id).map(related_mapped_products,
                {"message": v.with({"affectedMachine": related_mapped_products}).encode_json()}
              )
            ).flatten() + final_data.vulnerability_without_machines.map(v,
              {
                "message": v.with({"affectedMachine": null}).encode_json(),
              }
            )
          ).flatten(),
          "product_batch_size": res.product_batch_size,
          "product_skip": 0,
          "machine_batch_size": res.machine_batch_size,
          "machine_skip": 0,
          "vulnerabilities_batch_size": res.vulnerabilities_batch_size,
          "affected_machines_only": res.affected_machines_only,
          "want_more": false,
          "vulnerabilities_skip": 0,
        }
      )
    )
  )
tags:
{{#if preserve_original_event}}
  - preserve_original_event
{{/if}}
{{#if preserve_duplicate_custom_fields}}
  - preserve_duplicate_custom_fields
{{/if}}
{{#each tags as |tag|}}
  - {{tag}}
{{/each}}
{{#contains "forwarded" tags}}
publisher_pipeline.disable_host: true
{{/contains}}
{{#if processors}}
processors:
{{processors}}
{{/if}}
