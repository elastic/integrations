config_version: 2
interval: {{interval}}
resource.tracer:
  enabled: {{enable_request_tracer}}
  filename: "../../logs/cel/http-request-trace-*.ndjson"
  maxbackups: 5
{{#if proxy_url}}
resource.proxy_url: {{proxy_url}}
{{/if}}
{{#if ssl}}
resource.ssl: {{ssl}}
{{/if}}
{{#if http_client_timeout}}
resource.timeout: {{http_client_timeout}}
{{/if}}
resource.url: {{url}}
state:
  sas_valid_hours: {{sas_valid_hours}}
  token_url: {{token_url}}/{{azure_tenant_id}}/oauth2/v2.0/token
  client_id: {{client_id}}
  client_secret: {{client_secret}}
  token_scopes:
{{#each token_scopes as |token_scope|}}
    - {{token_scope}}
{{/each}}
redact:
  fields:
    - client_id
    - client_secret
    - token.access_token
program: |-
  state.with(
    state.?work_list.orValue([]).size() > 0 ?
      request(
        "GET", 
        state.work_list[0]
      ).do_request().as(resp, resp.StatusCode == 200 ?
        resp.Body.mime("application/gzip").decode_json_stream().map(v,
          {"message": dyn(v.encode_json())}
        ).as(events, {
          "events": events,
          // Keep polling if more work.
          "want_more": state.work_list.size() > 1,
          "work_list": tail(state.work_list),
        })
      :
        // It is possible that download URLs have expired, so ignore remaining work_list and return error.
        {
          "events": {
            "error": {
              "code": string(resp.StatusCode),
              "id": string(resp.Status),
              "message": "GET "+ state.work_list[0] + ":" + (
                size(resp.Body) != 0 ?
                  string(resp.Body)
                :
                  string(resp.Status) + ' (' + string(resp.StatusCode) + ')'
              ),
            },
          },
          "want_more": false,
        }
      )
    :
      // Periodic poll. No work_list, so get new token and work_list.
      post_request(state.token_url.trim_right("/"), "application/x-www-form-urlencoded",
        {
          "grant_type": ["client_credentials"],
          "client_id": [state.client_id],
          "client_secret": [state.client_secret],
          "scope": state.token_scopes,
        }.format_query()
      ).do_request().as(auth, auth.StatusCode == 200 ?
        auth.Body.decode_json()
      :
        {
          "events": {
            "error": {
              "code": string(auth.StatusCode),
              "id": string(auth.Status),
              "message": "POST /oauth2/v2.0/token :" +(
                size(auth.Body) != 0 ?
                  string(auth.Body)
                :
                  string(auth.Status) + ' (' + string(auth.StatusCode) + ')'
              ),
            },
          },
          "want_more": false,
        }
      ).as(token, !has(token.access_token) ? token :
        request(
          "GET",
          state.url.trim_right("/") + "/api/machines/SoftwareVulnerabilitiesExport?" + {
            "sasValidHours": [string(duration(state.sas_valid_hours).getHours())],
          }.format_query()
        ).with({
          "Header":{
            "Authorization": ["Bearer " + string(token.access_token)],
          }
        }).do_request().as(resp, resp.StatusCode == 200 ?
          resp.Body.decode_json().as(exportBody, exportBody.?exportFiles.orValue([]).size() == 0 ?
            // Nothing to download. Don't poll again.
            {
              "events": [],
              "want_more": false,
            }
          :
            // Return new work_list to download.
            {
              "events": [{"message":"retry"}],
              "work_list": exportBody.exportFiles,
              "want_more": true,
            }
          )
        :
          {
            "events": {
              "error": {
                "code": string(resp.StatusCode),
                "id": string(resp.Status),
                "message": "GET /api/machines/SoftwareVulnerabilitiesExport :" + (
                  size(resp.Body) != 0 ?
                    string(resp.Body)
                  :
                    string(resp.Status) + ' (' + string(resp.StatusCode) + ')'
                ),
              },
            },
            "want_more": false,
          }
        )
      )
  )
tags:
{{#if preserve_original_event}}
  - preserve_original_event
{{/if}}
{{#if preserve_duplicate_custom_fields}}
  - preserve_duplicate_custom_fields
{{/if}}
{{#each tags as |tag|}}
  - {{tag}}
{{/each}}
{{#contains "forwarded" tags}}
publisher_pipeline.disable_host: true
{{/contains}}
{{#if processors}}
processors:
{{processors}}
{{/if}}
