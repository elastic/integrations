inputs:
    - data_stream:
        namespace: ep
      meta:
        package:
            name: m365_defender
      name: test-default-m365_defender
      streams:
        - config_version: 2
          data_stream:
            dataset: m365_defender.vulnerability
          interval: 30s
          program: |-
            state.with(
              state.?work_list.orValue([]).size() > 0 ?
                request(
                  "GET",
                  state.work_list[0]
                ).do_request().as(resp, resp.StatusCode == 200 ?
                  resp.Body.mime("application/gzip").decode_json_stream().map(v,
                    {"message": dyn(v.encode_json())}
                  ).as(events, {
                    "events": events,
                    // Keep polling if more work.
                    "want_more": state.work_list.size() > 1,
                    "work_list": tail(state.work_list),
                  })
                :
                  // It is possible that download URLs have expired, so ignore remaining work_list and return error.
                  {
                    "events": {
                      "error": {
                        "code": string(resp.StatusCode),
                        "id": string(resp.Status),
                        "message": "GET "+ state.work_list[0] + ":" + (
                          size(resp.Body) != 0 ?
                            string(resp.Body)
                          :
                            string(resp.Status) + ' (' + string(resp.StatusCode) + ')'
                        ),
                      },
                    },
                    "want_more": false,
                  }
                )
              :
                // Periodic poll. No work_list, so get new token and work_list.
                post_request(state.token_url.trim_right("/"), "application/x-www-form-urlencoded",
                  {
                    "grant_type": ["client_credentials"],
                    "client_id": [state.client_id],
                    "client_secret": [state.client_secret],
                    "scope": state.token_scopes,
                  }.format_query()
                ).do_request().as(auth, auth.StatusCode == 200 ?
                  auth.Body.decode_json()
                :
                  {
                    "events": {
                      "error": {
                        "code": string(auth.StatusCode),
                        "id": string(auth.Status),
                        "message": "POST /oauth2/v2.0/token :" +(
                          size(auth.Body) != 0 ?
                            string(auth.Body)
                          :
                            string(auth.Status) + ' (' + string(auth.StatusCode) + ')'
                        ),
                      },
                    },
                    "want_more": false,
                  }
                ).as(token, !has(token.access_token) ? token :
                  request(
                    "GET",
                    state.url.trim_right("/") + "/api/machines/SoftwareVulnerabilitiesExport?" + {
                      "sasValidHours": [string(duration(state.sas_valid_hours).getHours())],
                    }.format_query()
                  ).with({
                    "Header":{
                      "Authorization": ["Bearer " + string(token.access_token)],
                    }
                  }).do_request().as(resp, resp.StatusCode == 200 ?
                    resp.Body.decode_json().as(exportBody, exportBody.?exportFiles.orValue([]).size() == 0 ?
                      // Nothing to download. Don't poll again.
                      {
                        "events": [],
                        "want_more": false,
                      }
                    :
                      // Return new work_list to download.
                      {
                        "events": [{"message":"retry"}],
                        "work_list": exportBody.exportFiles,
                        "want_more": true,
                      }
                    )
                  :
                    {
                      "events": {
                        "error": {
                          "code": string(resp.StatusCode),
                          "id": string(resp.Status),
                          "message": "GET /api/machines/SoftwareVulnerabilitiesExport :" + (
                            size(resp.Body) != 0 ?
                              string(resp.Body)
                            :
                              string(resp.Status) + ' (' + string(resp.StatusCode) + ')'
                          ),
                        },
                      },
                      "want_more": false,
                    }
                  )
                )
            )
          publisher_pipeline.disable_host: true
          redact:
            fields:
                - client_id
                - client_secret
                - token.access_token
          resource.ssl: null
          resource.timeout: 30s
          resource.tracer:
            enabled: false
            filename: ../../logs/cel/http-request-trace-*.ndjson
            maxbackups: 5
          resource.url: http://host.tld
          state:
            client_id: xxxx
            client_secret: ${SECRET_0}
            sas_valid_hours: 1h
            token_scopes:
                - https://securitycenter.onmicrosoft.com/windowsatpservice/.default
            token_url: https://login.microsoftonline.com/efgh/oauth2/v2.0/token
          tags:
            - preserve_original_event
            - preserve_duplicate_custom_fields
            - forwarded
            - m365_defender-vulnerability
            - test-policy
      type: cel
      use_output: default
output_permissions:
    default:
        _elastic_agent_checks:
            cluster:
                - monitor
        _elastic_agent_monitoring:
            indices: []
        uuid-for-permissions-on-related-indices:
            indices:
                - names:
                    - logs-m365_defender.vulnerability-ep
                  privileges:
                    - auto_configure
                    - create_doc
secret_references:
    - {}
