---
description: Pipeline for processing Kubernetes audit logs.
processors:
  - rename:
      field: message
      target_field: event.original
      ignore_missing: true
      if: ctx.event?.original == null
  - json:
      field: event.original
      target_field: kubernetes.audit
      if: ctx.event?.original != null && ctx.kubernetes?.audit == null
  - remove:
      field: message
      if: ctx.event?.original != null
      ignore_missing: true
  - remove:
      if: "ctx.kubernetes?.audit?.responseObject != null"
      field: ["kubernetes.audit.responseObject.metadata"]
      ignore_missing: true
  - remove:
      if: "ctx.kubernetes?.audit?.requestObject != null"
      field: ["kubernetes.audit.requestObject.metadata"]
      ignore_missing: true
  - set:
      field: event.kind
      value: event
  - set:
      if: ctx.kubernetes?.audit?.verb != null
      field: event.action
      copy_from: kubernetes.audit.verb
      ignore_empty_value: true
  - rename:
      field: kubernetes.audit.insertId
      target_field: kubernetes.audit.auditID
      ignore_missing: true
      if: ctx.audit?.auditID == null
      tag: rename_audit_id
  - rename:
      field: kubernetes.audit.receiveTimestamp
      target_field: kubernetes.audit.requestReceivedTimestamp
      ignore_missing: true
      if: ctx.audit?.requestReceivedTimestamp == null
      tag: rename_requestReceivedTimestamp
  - rename:
      field: kubernetes.audit.timestamp
      target_field: kubernetes.audit.stageTimestamp
      ignore_missing: true
      if: ctx.audit?.stageTimestamp == null
      tag: rename_stageTimestamp
  - rename:
      field: kubernetes.audit.protoPayload.status.code
      target_field: kubernetes.audit.responseStatus.code
      ignore_missing: true
      if: ctx.audit?.responseStatus?.code == null
      tag: rename_responseStatusCode
  - rename:
      field: kubernetes.audit.labels
      target_field: kubernetes.audit.annotations
      ignore_missing: true
      if: ctx.audit?.annotations == null
      tag: rename_labels
  - script:
      lang: painless
      if: ctx.kubernetes?.audit?.annotations != null
      source: >-
        Map annotations = ctx['kubernetes']['audit']['annotations'];
        Map updatedAnnotation = new HashMap();
        for (String key: annotations.keySet()) {
            updatedAnnotation[key.replace('.', '_')] = annotations[key];
            if (key == 'authorization.k8s.io/decision') {
                if (annotations['authorization.k8s.io/decision'] == 'allow') {
                    ctx.event.outcome = 'success';
                } else if (annotations['authorization.k8s.io/decision'] == 'forbid') {
                    ctx.event.outcome = 'failure';
                }
            }
        }
        ctx['kubernetes']['audit']['annotations'] = updatedAnnotation
  - set:
      if: ctx.kubernetes?.audit?.user?.username != null
      field: user.name
      copy_from: kubernetes.audit.user.username
      ignore_empty_value: true
  - set:
      if: ctx.kubernetes?.audit?.user?.uid != null
      field: user.id
      copy_from: kubernetes.audit.user.uid
      ignore_empty_value: true
  - set:
      if: ctx.kubernetes?.audit?.userAgent != null
      field: user_agent.original
      copy_from: kubernetes.audit.userAgent
      ignore_empty_value: true
  - convert:
      if: ctx.kubernetes?.audit?.sourceIPs != null
      field: kubernetes.audit.sourceIPs
      target_field: source.ip
      type: ip
      ignore_failure: true
      ignore_missing: true
  - set:
      if: ctx.source?.ip != null
      field: client.ip
      copy_from: source.ip
      ignore_empty_value: true

  # Orchestrator fields
  - set:
      field: orchestrator.type
      value: kubernetes
  # For EKS and AKS logs
  - set:
      if: ctx.kubernetes?.audit?.apiVersion != null
      field: orchestrator.api_version
      copy_from: kubernetes.audit.apiVersion
      ignore_empty_value: true
  - set:
      if: ctx.kubernetes?.audit?.objectRef?.resource != null
      field: orchestrator.cluster.name
      copy_from: kubernetes.audit.objectRef.resource
      ignore_empty_value: true
  - set:
      if: ctx.kubernetes?.audit?.objectRef?.namespace != null
      field: orchestrator.namespace
      copy_from: kubernetes.audit.objectRef.namespace
      ignore_empty_value: true
  - set:
      if: ctx.kubernetes?.audit?.objectRef?.name != null
      field: orchestrator.resource.name
      copy_from: kubernetes.audit.objectRef.name
      ignore_empty_value: true
  # For GKE logs
  - set:
      if: ctx.kubernetes?.audit?.protoPayload?.resourceName != null
      field: orchestrator.resource.name
      copy_from: kubernetes.audit.protoPayload.resourceName
      ignore_empty_value: true
      override: false
  - set:
      if: ctx.kubernetes?.audit?.resource?.type != null
      field: orchestrator.resource.type
      copy_from: kubernetes.audit.resource.type
      ignore_empty_value: true
  - set:
      if: ctx.kubernetes?.audit?.resource?.labels?.cluster_name != null
      field: orchestrator.cluster.name
      copy_from: kubernetes.audit.resource.labels.cluster_name
      ignore_empty_value: true
  - set:
      if: ctx.kubernetes?.audit?.resource?.labels?.project_id != null
      field: orchestrator.cluster.id
      copy_from: kubernetes.audit.resource.labels.project_id
      ignore_empty_value: true

  - append:
      tag: append_related_user_uid
      field: related.user
      value: "{{{kubernetes.audit.user.uid}}}"
      allow_duplicates: false
      if: ctx.kubernetes?.audit?.user?.uid != null
  - append:
      tag: append_related_user_name
      field: related.user
      value: "{{{kubernetes.audit.user.username}}}"
      allow_duplicates: false
      if: ctx.kubernetes?.audit?.user?.username != null
  - foreach:
      field: source.ip
      if: ctx.source?.ip != null && ctx.source.ip instanceof List
      processor:
        append:
          tag: append_related_source_ip
          field: related.ip
          value: '{{{_ingest._value}}}'
          allow_duplicates: false

  - script:
      description: Drops null/empty values recursively
      tag: script_to_drop_empty_values
      lang: painless
      ignore_failure: true
      source: |
        void handleMap(Map map) {
          map.values().removeIf(v -> {
            if (v instanceof Map) {
                handleMap(v);
            } else if (v instanceof List) {
                handleList(v);
            }
            return v == null || v == '' || (v instanceof Map && v.size() == 0) || (v instanceof List && v.size() == 0)
          });
        }
        void handleList(List list) {
          list.removeIf(v -> {
            if (v instanceof Map) {
                handleMap(v);
            } else if (v instanceof List) {
                handleList(v);
            }
            return v == null || v == '' || (v instanceof Map && v.size() == 0) || (v instanceof List && v.size() == 0)
          });
        }
        handleMap(ctx);
on_failure:
  - set:
      field: event.kind
      value: pipeline_error
  - append:
      field: tags
      value: preserve_original_event
      allow_duplicates: false
  - append:
      field: error.message
      value: >-
        Processor '{{{ _ingest.on_failure_processor_type }}}'
        {{{#_ingest.on_failure_processor_tag}}}with tag '{{{ _ingest.on_failure_processor_tag }}}'
        {{{/_ingest.on_failure_processor_tag}}}failed with message '{{{ _ingest.on_failure_message }}}
