---
description: Pipeline for processing Kubernetes audit logs.
processors:
  - rename:
      field: message
      target_field: event.original
      ignore_missing: true
      if: ctx.event?.original == null
  - json:
      field: event.original
      target_field: kubernetes.audit
      if: ctx.event?.original != null && ctx.kubernetes?.audit == null
  - remove:
      field: message
      if: ctx.event?.original != null
      ignore_missing: true
  - remove:
      if: "ctx.kubernetes?.audit?.responseObject != null"
      field: ["kubernetes.audit.responseObject.metadata"]
      ignore_missing: true
  - remove:
      if: "ctx.kubernetes?.audit?.requestObject != null"
      field: ["kubernetes.audit.requestObject.metadata"]
      ignore_missing: true
  - set:
      field: event.kind
      value: event
  - set:
      if: ctx.kubernetes?.audit?.verb != null
      field: event.action
      copy_from: kubernetes.audit.verb
      ignore_empty_value: true
  - rename:
      field: kubernetes.audit.insertId
      target_field: kubernetes.audit.auditID
      ignore_missing: true
      if: ctx.audit?.auditID == null
      tag: rename_audit_id
  - rename:
      field: kubernetes.audit.receiveTimestamp
      target_field: kubernetes.audit.requestReceivedTimestamp
      ignore_missing: true
      if: ctx.audit?.requestReceivedTimestamp == null
      tag: rename_requestReceivedTimestamp
  - rename:
      field: kubernetes.audit.timestamp
      target_field: kubernetes.audit.stageTimestamp
      ignore_missing: true
      if: ctx.audit?.stageTimestamp == null
      tag: rename_stageTimestamp
  - rename:
      field: kubernetes.audit.protoPayload.status.code
      target_field: kubernetes.audit.responseStatus.code
      ignore_missing: true
      if: ctx.audit?.responseStatus?.code == null
      tag: rename_responseStatusCode
  - rename:
      field: kubernetes.audit.labels
      target_field: kubernetes.audit.annotations
      ignore_missing: true
      if: ctx.audit?.annotations == null
      tag: rename_labels
  - script:
      lang: painless
      if: ctx.kubernetes?.audit?.annotations != null
      source: >-
        Map annotations = ctx['kubernetes']['audit']['annotations'];
        Map updatedAnnotation = new HashMap();
        for (String key: annotations.keySet()) {
            updatedAnnotation[key.replace('.', '_')] = annotations[key];
            if (key == 'authorization.k8s.io/decision') {
                if (annotations['authorization.k8s.io/decision'] == 'allow') {
                    ctx.event.outcome = 'success';
                } else if (annotations['authorization.k8s.io/decision'] == 'forbid') {
                    ctx.event.outcome = 'failure';
                }
            }
        }
        ctx['kubernetes']['audit']['annotations'] = updatedAnnotation
  - set:
      if: ctx.kubernetes?.audit?.user?.username != null
      field: user.name
      copy_from: kubernetes.audit.user.username
      ignore_empty_value: true
  - set:
      if: ctx.kubernetes?.audit?.user?.uid != null
      field: user.id
      copy_from: kubernetes.audit.user.uid
      ignore_empty_value: true
  - set:
      if: ctx.kubernetes?.audit?.userAgent != null
      field: user_agent.original
      copy_from: kubernetes.audit.userAgent
      ignore_empty_value: true
  - convert:
      if: ctx.kubernetes?.audit?.sourceIPs != null
      field: kubernetes.audit.sourceIPs
      target_field: source.ip
      type: ip
      ignore_failure: true
      ignore_missing: true
  - set:
      if: ctx.source?.ip != null
      field: client.ip
      copy_from: source.ip
      ignore_empty_value: true

  - append:
      tag: append_related_user_uid
      field: related.user
      value: "{{{kubernetes.audit.user.uid}}}"
      allow_duplicates: false
      if: ctx.kubernetes?.audit?.user?.uid != null
  - append:
      tag: append_related_user_name
      field: related.user
      value: "{{{kubernetes.audit.user.username}}}"
      allow_duplicates: false
      if: ctx.kubernetes?.audit?.user?.username != null
  - foreach:
      field: source.ip
      if: ctx.source?.ip != null && ctx.source.ip instanceof List
      processor:
        append:
          tag: append_related_source_ip
          field: related.ip
          value: '{{{_ingest._value}}}'
          allow_duplicates: false

  - script:
      lang: painless
      description: Drops null/empty values recursively.
      tag: drop_null_empty_values
      source: >
        boolean drop(Object o) {
          if (o == null || o == '') {
            return true;
          } else if (o instanceof Map) {
            ((Map) o).values().removeIf(v -> drop(v));
            return (((Map) o).size() == 0);
          } else if (o instanceof List) {
            ((List) o).removeIf(v -> drop(v));
            return (((List) o).length == 0);
          }
          return false;
        }
        drop(ctx);
on_failure:
  - set:
      field: event.kind
      value: pipeline_error
  - append:
      field: tags
      value: preserve_original_event
      allow_duplicates: false
  - append:
      field: error.message
      value: >-
        Processor '{{{ _ingest.on_failure_processor_type }}}'
        {{{#_ingest.on_failure_processor_tag}}}with tag '{{{ _ingest.on_failure_processor_tag }}}'
        {{{/_ingest.on_failure_processor_tag}}}failed with message '{{{ _ingest.on_failure_message }}}
