inputs:
    - data_stream:
        namespace: ep
      meta:
        package:
            name: trend_micro_vision_one
      name: test-all-trend_micro_vision_one
      streams:
        - config_version: 2
          data_stream:
            dataset: trend_micro_vision_one.telemetry
          fields_under_root: true
          interval: 15m
          keep_null: true
          processors:
            - add_fields:
                fields:
                    test: policy-test
                target: ""
          program: |4
            // The following assumptions are made regarding package listings:
            //
            // - **They are ordered by `createdDateTime ASC`.**
            //
            //   The API documentation example data is ordered by
            //   `createdDateTime ASC, id ASC` within a page. That is assumed to be the
            //   case across pages.
            //
            // - **The `startDateTime` condition is inclusive.**
            //
            //   The documentation calls it "the start of the data retrieval time range".
            //
            // - **The `endDateTime` condition is exclusive, _or_
            //   a package having `createdDateTime == endDateTime` will be rare.**
            //
            //   The documentation calls it "the end of the data retrieval time range".
            //   It also says that "The data pipeline ingests data at least every 2
            //   minutes." If a package is created every minute on average, there's a
            //   1.7% chance it's creation time will fall on the last second of a given
            //   15 minute window.
            //   If the condition is inclusive and a package falls on the `endDateTime`,
            //   it will be received again on the following page and ingested twice.
            //
            // - **Full pages of identical `createdDateTime` values will never happen.**
            //
            //   This would only happen if >= 500 packages are created in one second.
            //   If it did happen, the integration would get stuck in a loop until those
            //   packages become unavailable.
            //
            // Documentation: [Trend Vision One Public API (v3.0) - Datalake Pipeline][1]
            //
            // [1]: https://automation.trendmicro.com/xdr/api-v3/#tag/Datalake-Pipeline

            (state.?cursor.packages_to_get[0].hasValue()) ?

              //--------------------------------------------------------------------------
              // have a package to get -> get the package
              //--------------------------------------------------------------------------

              request("GET", [
                state.url.trim_suffix("/"),
                "/v3.0/datalake/dataPipelines/", state.cursor.packages_to_get[0].pipeline_id,
                "/packages/", state.cursor.packages_to_get[0].package_id,
              ].join("")).with({
                "Header": { "Authorization": ["Bearer " + state.api_token] }
              }).do_request().as(resp,
                (resp.StatusCode != 200 && resp.StatusCode != 404) ? // Other error - log it, skip this package and continue after interval
                  state.with({
                    "events": {
                      "error": {
                        "code": string(resp.StatusCode),
                        "id": string(resp.Status),
                        "message": "GET fetch a package: "+(
                          size(resp.Body) != 0 ? string(resp.Body) : string(resp.Status) + ' (' + string(resp.StatusCode) + ')'
                        ),
                      },
                    },
                    "want_more": false,
                    "cursor": state.cursor.with({
                      "packages_to_get": tail(state.cursor.packages_to_get),
                    }),
                  })
                : (resp.StatusCode == 404) ? // Not Found - skip this package and continue immediately
                  state.with({
                    "events": [{"event": {"reason": "want_more"}}],
                    "want_more": true,
                    "cursor": state.cursor.with({
                      "packages_to_get": tail(state.cursor.packages_to_get),
                    }),
                  })
                :
                  state.with({
                    "events": string(resp.Body).split("\n").filter(i, i.size() > 0).map(i, dyn({ "message": i })).as(dataEvents,
                      (dataEvents.size() > 0) ? dataEvents : [{"event": {"reason": "want_more"}}]
                    ),
                    "want_more": (
                      // continue immediately if there's another package to get
                      state.cursor.packages_to_get.size() > 1 ||
                      // continue immediately if the next check for packages would cover the minimum time range
                      (now - duration(state.max_recency) - state.cursor.newStartDateTime.parse_time(time_layout.RFC3339) >= duration(state.min_time_range))
                    ),
                    "cursor": state.cursor.with({
                      "packages_to_get": tail(state.cursor.packages_to_get),
                    }),
                  })
              )

            :

              //--------------------------------------------------------------------------
              // no package to get -> check or setup
              //--------------------------------------------------------------------------

              has(state.?cursor.pipeline_id) ?

                //------------------------------------------------------------------------
                // have pipeline id -> check for packages, update list of packages to get
                //------------------------------------------------------------------------

                {
                  "startDateTime": [
                    state.?cursor.newStartDateTime.optMap(t, t.parse_time(time_layout.RFC3339)).orValue(now - duration(state.initial_interval)),
                    now - duration(string(7*24)+"h1m"), // now-7d is the oldest allowed start
                  ].max().format(time_layout.RFC3339),
                  "maxEndDateTime": (now-duration(state.max_recency)).format(time_layout.RFC3339),
                }.as(t, t.with({
                  "endDateTime": [
                    (t.startDateTime.parse_time(time_layout.RFC3339) + duration(state.max_time_range)).format(time_layout.RFC3339),
                    t.maxEndDateTime,
                  ].min(),
                })).as(t,
                  request("GET",
                    state.url.trim_suffix("/") +
                    "/v3.0/datalake/dataPipelines/" + state.cursor.pipeline_id + "/packages?" +
                    {
                       "startDateTime": [t.startDateTime],
                       "endDateTime": [t.endDateTime],
                       "top": [string(state.top)],
                    }.format_query()
                  ).with({ "Header": { "Authorization": ["Bearer " + state.api_token] } }).do_request().as(resp,
                    (resp.StatusCode != 200) ?
                      state.with({
                        "events": {
                          "error": {
                            "code": string(resp.StatusCode),
                            "id": string(resp.Status),
                            "message": "GET list available packages: "+(
                              size(resp.Body) != 0 ? string(resp.Body) : string(resp.Status) + ' (' + string(resp.StatusCode) + ')'
                            ),
                          },
                        },
                        "cursor": (resp.StatusCode == 404) ? state.cursor.drop("pipeline_id") : state.cursor,
                        "want_more": false,
                      })
                    :
                      resp.Body.decode_json().as(body,
                        state.with({
                          "events": [{"event": {"reason": "want_more"}}],
                          "cursor": state.cursor.with({
                            "packages_to_get": state.?cursor.packages_to_get.orValue([]) + body.items.map(i, {
                              "pipeline_id": state.cursor.pipeline_id,
                              "package_id": i.id,
                            }),
                            "newStartDateTime": (body.items.size() == int(state.top)) ? body.items.map(i, i.createdDateTime).max() : t.endDateTime,
                          }),
                          "want_more": body.items.size() > 0 || t.endDateTime < t.maxEndDateTime, // continue if there's data or we're not up to date
                        })
                      )
                  )
                )

              :

                //------------------------------------------------------------------------
                // no pipeline id -> setup: try to get the pipeline id
                //------------------------------------------------------------------------

                has(state.hard_coded_pipeline_id) ?

                  //----------------------------------------------------------------------
                  // a hard-coded pipeline id was provided -> return it in the cursor
                  //----------------------------------------------------------------------

                  state.with({
                    "events": [{"event": {"reason": "want_more"}}],
                    "cursor": state.?cursor.orValue({}).with({ "pipeline_id": state.hard_coded_pipeline_id }),
                    "want_more": true, // use hard-coded pipeline id immediately
                  })

                :

                  //----------------------------------------------------------------------
                  // no hard-coded pipeline id was provided -> list existing pipelines
                  //----------------------------------------------------------------------

                  request("GET", state.url.trim_suffix("/") + "/v3.0/datalake/dataPipelines").with({
                    "Header": { "Authorization": ["Bearer " + state.api_token] }
                  }).do_request().as(resp,
                    (resp.StatusCode != 200) ?
                      state.with({
                        "events": {
                          "error": {
                            "code": string(resp.StatusCode),
                            "id": string(resp.Status),
                            "message": "GET list pipelines: "+(
                              size(resp.Body) != 0 ? string(resp.Body) : string(resp.Status) + ' (' + string(resp.StatusCode) + ')'
                            ),
                          },
                        },
                        "want_more": false,
                      })
                    :
                      resp.Body.decode_json().as(body,
                        body.items.filter(i, i.description == state.managed_pipeline_description)[?0].id.as(id,
                          id.hasValue() ?

                            //------------------------------------------------------------
                            // got the pipeline id -> return it in the cursor
                            //------------------------------------------------------------

                            state.with({
                              "events": [{"event": {"reason": "want_more"}}],
                              "cursor": state.?cursor.orValue({}).with({ "pipeline_id": id.value() }),
                              "want_more": true, // use the fetched pipeline id immediately
                            })

                          :

                            //------------------------------------------------------------
                            // no pipeline id found -> register a new pipeline
                            //------------------------------------------------------------

                            request("POST", state.url.trim_suffix("/") + "/v3.0/datalake/dataPipelines").with({
                              "Header": {
                                "Content-Type": ["application/json;charset=utf-8"],
                                "Authorization": ["Bearer " + state.api_token],
                              },
                              "Body": {
                                "type": "telemetry",
                                "subType": ["all"],
                                "description": state.managed_pipeline_description,
                              }.encode_json(),
                            }).do_request().as(resp,
                              (resp.StatusCode != 201) ?
                                state.with({
                                  "events": {
                                    "error": {
                                      "code": string(resp.StatusCode),
                                      "id": string(resp.Status),
                                      "message": "POST register a new pipeline: "+(
                                        size(resp.Body) != 0 ? string(resp.Body) : string(resp.Status) + ' (' + string(resp.StatusCode) + ')'
                                      ),
                                    },
                                  },
                                  "want_more": false,
                                })
                              :
                                // no pipeline id is returned, but it will be found next time
                                state.with({
                                  "events": [{"event": {"reason": "want_more"}}],
                                  "want_more": int(state.registration_count) == 0, // avoid a busy loop by waiting if the registration was previously attempted
                                  "registration_count": int(state.registration_count) + 1,
                                })
                            )

                        )
                      )
                  )
          publisher_pipeline.disable_host: true
          redact:
            fields:
                - api_token
          resource.proxy_url: https://user:pass@proxy.example.com:8080
          resource.ssl:
            certificate_authorities:
                - |
                  -----BEGIN CERTIFICATE-----
                  MIIDCjCCAfKgAwIBAgITJ706Mu2wJlKckpIvkWxEHvEyijANBgkqhkiG9w0BAQsF
                  ADAUMRIwEAYDVQQDDAlsb2NhbGhvc3QwIBcNMTkwNzIyMTkyOTA0WhgPMjExOTA2
                  MjgxOTI5MDRaMBQxEjAQBgNVBAMMCWxvY2FsaG9zdDCCASIwDQYJKoZIhvcNAQEB
                  BQADggEPADCCAQoCggEBANce58Y/JykI58iyOXpxGfw0/gMvF0hUQAcUrSMxEO6n
                  fZRA49b4OV4SwWmA3395uL2eB2NB8y8qdQ9muXUdPBWE4l9rMZ6gmfu90N5B5uEl
                  94NcfBfYOKi1fJQ9i7WKhTjlRkMCgBkWPkUokvBZFRt8RtF7zI77BSEorHGQCk9t
                  /D7BS0GJyfVEhftbWcFEAG3VRcoMhF7kUzYwp+qESoriFRYLeDWv68ZOvG7eoWnP
                  PsvZStEVEimjvK5NSESEQa9xWyJOmlOKXhkdymtcUd/nXnx6UTCFgnkgzSdTWV41
                  CI6B6aJ9svCTI2QuoIq2HxX/ix7OvW1huVmcyHVxyUECAwEAAaNTMFEwHQYDVR0O
                  BBYEFPwN1OceFGm9v6ux8G+DZ3TUDYxqMB8GA1UdIwQYMBaAFPwN1OceFGm9v6ux
                  8G+DZ3TUDYxqMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBAG5D
                  874A4YI7YUwOVsVAdbWtgp1d0zKcPRR+r2OdSbTAV5/gcS3jgBJ3i1BN34JuDVFw
                  3DeJSYT3nxy2Y56lLnxDeF8CUTUtVQx3CuGkRg1ouGAHpO/6OqOhwLLorEmxi7tA
                  H2O8mtT0poX5AnOAhzVy7QW0D/k4WaoLyckM5hUa6RtvgvLxOwA0U+VGurCDoctu
                  8F4QOgTAWyh8EZIwaKCliFRSynDpv3JTUwtfZkxo6K6nce1RhCWFAsMvDZL8Dgc0
                  yvgJ38BRsFOtkRuAGSf6ZUwTO8JJRRIFnpUzXflAnGivK9M13D5GEQMmIl6U9Pvk
                  sxSmbIUfc2SGJGCJD4I=
                  -----END CERTIFICATE-----
          resource.timeout: 60s
          resource.tracer:
            enabled: true
            filename: ../../logs/cel/http-request-trace-*.ndjson
            maxbackups: 5
          resource.url: https://example.visionone.trendmicro.com
          state:
            api_token: ${SECRET_0}
            initial_interval: 24h
            managed_pipeline_description: managed-by-elastic-integrations-trend_micro_vision_one-telemetry
            max_recency: 30s
            max_time_range: 1h
            min_time_range: 1m
            registration_count: 0
            top: 500
            want_more: false
          tags:
            - preserve_original_event
            - preserve_duplicate_custom_fields
            - forwarded
            - trend_micro_vision_one-telemetry
            - test-policy
      type: cel
      use_output: default
output_permissions:
    default:
        _elastic_agent_checks:
            cluster:
                - monitor
        _elastic_agent_monitoring:
            indices: []
        uuid-for-permissions-on-related-indices:
            indices:
                - names:
                    - logs-trend_micro_vision_one.telemetry-ep
                  privileges:
                    - auto_configure
                    - create_doc
secret_references:
    - {}
