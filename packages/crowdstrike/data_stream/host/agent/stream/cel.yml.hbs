config_version: 2
interval: {{interval}}
resource.tracer:
  enabled: {{enable_request_tracer}}
  filename: "../../logs/cel/http-request-trace-*.ndjson"
  maxbackups: 5
{{#if proxy_url}}
resource.proxy_url: {{proxy_url}}
{{/if}}
{{#if proxy_headers}}
resource.proxy_headers: {{proxy_headers}}
{{/if}}
{{#if ssl}}
resource.ssl: {{ssl}}
{{/if}}
{{#if http_client_timeout}}
resource.timeout: {{http_client_timeout}}
{{/if}}
resource.url: {{url}}
auth.oauth2:
  client.id: {{client_id}}
  client.secret: {{client_secret}}
  token_url: {{token_url}}
state:
  initial_interval: {{initial_interval}}
  batch_size: {{batch_size}}
  select_fields: {{select_fields}}
  offset: 0
  want_more: false
  gov_cloud: {{gov_cloud}}
{{#if query}}
  query: {{query}}
{{/if}}
redact:
  fields: ~
program: |-
  // This logic determines which CrowdStrike devices endpoint to call. The
  // "/devices/combined/devices/v1" endpoint is not supported in GovCloud
  // environments, so we must fall back to the "/devices/entities/devices/v2"
  // endpoint when running in GovCloud.
  //
  // The selection works in two stages:
  // 1. If the "gov_cloud" flag is explicitly enabled in the data stream manifest,
  //    we always use the "/devices/entities/devices/v2" endpoint.
  //
  // 2. If the flag is disabled, the program inspects the base URL to infer
  //    whether the integration is pointed at a GovCloud environment. If the
  //    URL matches a known GovCloud domain, we avoid calling the unsupported
  //    combined endpoint and instead use "/devices/entities/devices/v2".
  //
  // This dual-check mechanism ensures that GovCloud users do not encounter errors
  // even if they forget to enable the "gov_cloud" flag in the manifest.
  (
    state.gov_cloud || state.url.trim_right("/") in ["https://api.laggar.gcw.crowdstrike.com", "https://api.us-gov-2.crowdstrike.mil"] ?
      (
        state.want_more ?
          state.?page.start
        :
          optional.of(state.?cursor.last_timestamp.orValue((now - duration(state.initial_interval)).format(time_layout.RFC3339)))
      ).as(filter,
        state.with(
          get_request(
            state.url.trim_right("/") + "/devices/queries/devices/v1?" + {
              "sort": ["modified_timestamp.asc"],
              "offset": [string(state.offset)],
              "limit": [string(state.batch_size)],
              ?"filter": (filter.hasValue() || state.?query.orValue("") != "") ?
                optional.of(
                  [
                    [
                      ?filter.optMap(f, "modified_timestamp:>\"" + f + "\""),
                      ?state.?query.optMap(q, "(" + q + ")"),
                    ].join("+"),
                  ]
                )
              :
                optional.none(),
            }.format_query()
          ).do_request().as(get_resp, (get_resp.StatusCode == 200) ?
            bytes(get_resp.Body).decode_json().as(body,
              (int(state.offset) + body.resources.size() < body.meta.pagination.total).as(want_more,
                {
                  "next": {
                    ?"resources": (body.resources.size() > 0) ? optional.of(body.resources) : optional.none(),
                  },
                  "filter": filter,
                  "events": [],
                  "offset": want_more ? (int(state.offset) + body.resources.size()) : 0,
                  "want_more": want_more,
                }
              )
            )
          :
            {
              "events": {
                "error": {
                  "code": string(get_resp.StatusCode),
                  "id": string(get_resp.Status),
                  "message": "GET:" + (
                    (size(get_resp.Body) != 0) ?
                      string(get_resp.Body)
                    :
                      string(get_resp.Status) + " (" + string(get_resp.StatusCode) + ")"
                  ),
                },
              },
              "want_more": false,
              "next": {},
            }
          )
        ).as(state,
          state.with(
            !has(state.?next.resources) ? // Exit early due to GET failure or no resources to collect.
              state
            :
              post_request(
                state.url + "/devices/entities/devices/v2",
                "application/json",
                {"ids": state.next.resources}.encode_json()
              ).do_request().as(post_resp, (post_resp.StatusCode == 200) ?
                bytes(post_resp.Body).decode_json().as(inner_body,
                  {
                    "events": inner_body.resources.map(e,
                      {
                        "message": e.encode_json(),
                      }
                    ),
                    "cursor": {
                      ?"last_timestamp": (has(inner_body.resources) && inner_body.resources.size() > 0) ?
                        optional.of(inner_body.resources.map(e, timestamp(e.modified_timestamp)).max().format(time_layout.RFC3339))
                      :
                        state.?cursor.last_timestamp,
                    },
                    "page": {
                      "start": state.filter,
                    },
                    "next": {},
                  }
                )
              :
                {
                  "events": {
                    "error": {
                      "code": string(post_resp.StatusCode),
                      "id": string(post_resp.Status),
                      "message": "POST:" + (
                        (size(post_resp.Body) != 0) ?
                          string(post_resp.Body)
                        :
                          string(post_resp.Status) + " (" + string(post_resp.StatusCode) + ")"
                      ),
                    },
                  },
                  "want_more": false,
                  "next": {},
                }
              )
          )
        )
      )
    :
      state.with(
        (
          state.?want_more.orValue(false) ?
            state.start_time
          :
            state.?cursor.last_timestamp.orValue(
              (now - duration(state.initial_interval)).format(time_layout.RFC3339)
            )
        ).as(start_time,
          request(
            "GET",
            state.url.trim_right("/") + "/devices/combined/devices/v1?" + {
              ?"offset": state.?next.page_token.optMap(v, [v]),
              "limit": [string(state.batch_size)],
              "sort": ["modified_timestamp|asc"],
              "filter": [
                [
                  "modified_timestamp:>'" + start_time + "'",
                  ?state.?query.optMap(q, "(" + q + ")"),
                ].join("+"),
              ],
              ?"fields": state.?select_fields.optMap(v, [v.trim_right(",")+",modified_timestamp"]),
            }.format_query()
          ).do_request().as(resp, (resp.StatusCode == 200) ?
            resp.Body.decode_json().as(body,
              (size(body.?errors.orValue([])) > 0) ?
                {
                  "events": body.errors.map(error,
                    {
                      "error": {
                        "code": string(error.code),
                        "message": string(error.message),
                      },
                    }
                  ),
                  "next": {},
                  "want_more": false,
                }
              :
                {
                  "events": has(body.resources) ?
                    body.resources.map(e,
                      {
                        "message": e.encode_json(),
                      }
                    )
                  :
                    [],
                  "start_time": start_time,
                  "next": {
                    ?"page_token": body.?meta.pagination.next,
                  },
                  "cursor": {
                    // The records are sorted in ascending order, based on value of modified_timestamp.
                    // In the next interval we start from the last event (newest) time.
                    ?"last_timestamp": (has(body.resources) && body.resources.size() > 0) ?
                      optional.of(timestamp(body.resources[size(body.resources) - 1].modified_timestamp).format(time_layout.RFC3339))
                    :
                      state.?cursor.last_timestamp,
                  },
                  "want_more": has(body.?meta.pagination.next),
                }
            )
          :
            {
              "events": {
                "error": {
                  "code": string(resp.StatusCode),
                  "id": string(resp.Status),
                  "message": "GET " + state.url.trim_right("/") + "/devices/combined/devices/v1:" + (
                    (size(resp.Body) != 0) ?
                      string(resp.Body)
                    :
                      string(resp.Status) + " (" + string(resp.StatusCode) + ")"
                  ),
                },
              },
              "next": {},
              "want_more": false,
            }
          )
        )
      )
  )
tags:
{{#if preserve_original_event}}
  - preserve_original_event
{{/if}}
{{#if preserve_duplicate_custom_fields}}
  - preserve_duplicate_custom_fields
{{/if}}
{{#each tags as |tag|}}
  - {{tag}}
{{/each}}
{{#contains "forwarded" tags}}
publisher_pipeline.disable_host: true
{{/contains}}
{{#if processors}}
processors:
{{processors}}
{{/if}}
