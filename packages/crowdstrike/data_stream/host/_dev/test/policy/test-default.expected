inputs:
    - data_stream:
        namespace: ep
      meta:
        package:
            name: crowdstrike
      name: test-default-crowdstrike
      streams:
        - auth.oauth2:
            client.id: test_client_id
            client.secret: ${SECRET_0}
            token_url: http://host.tld/oauth2/token
          config_version: 2
          data_stream:
            dataset: crowdstrike.host
          interval: 24h
          program: |-
            // This logic determines which CrowdStrike devices endpoint to call. The
            // "/devices/combined/devices/v1" endpoint is not supported in GovCloud
            // environments, so we must fall back to the "/devices/entities/devices/v2"
            // endpoint when running in GovCloud.
            //
            // The selection works in two stages:
            // 1. If the "gov_cloud" flag is explicitly enabled in the data stream manifest,
            //    we always use the "/devices/entities/devices/v2" endpoint.
            //
            // 2. If the flag is disabled, the program inspects the base URL to infer
            //    whether the integration is pointed at a GovCloud environment. If the
            //    URL matches a known GovCloud domain, we avoid calling the unsupported
            //    combined endpoint and instead use "/devices/entities/devices/v2".
            //
            // This dual-check mechanism ensures that GovCloud users do not encounter errors
            // even if they forget to enable the "gov_cloud" flag in the manifest.
            (
              state.gov_cloud || state.url.trim_right("/") in ["https://api.laggar.gcw.crowdstrike.com", "https://api.us-gov-2.crowdstrike.mil"] ?
                (
                  state.want_more ?
                    state.?page.start
                  :
                    optional.of(state.?cursor.last_timestamp.orValue((now - duration(state.initial_interval)).format(time_layout.RFC3339)))
                ).as(filter,
                  state.with(
                    get_request(
                      state.url.trim_right("/") + "/devices/queries/devices/v1?" + {
                        "sort": ["modified_timestamp.asc"],
                        "offset": [string(state.offset)],
                        "limit": [string(state.batch_size)],
                        ?"filter": (filter.hasValue() || state.?query.orValue("") != "") ?
                          optional.of(
                            [
                              [
                                ?filter.optMap(f, "modified_timestamp:>\"" + f + "\""),
                                ?state.?query.optMap(q, "(" + q + ")"),
                              ].join("+"),
                            ]
                          )
                        :
                          optional.none(),
                      }.format_query()
                    ).do_request().as(get_resp, (get_resp.StatusCode == 200) ?
                      bytes(get_resp.Body).decode_json().as(body,
                        (int(state.offset) + body.resources.size() < body.meta.pagination.total).as(want_more,
                          {
                            "next": {
                              ?"resources": (body.resources.size() > 0) ? optional.of(body.resources) : optional.none(),
                            },
                            "filter": filter,
                            "events": [],
                            "offset": want_more ? (int(state.offset) + body.resources.size()) : 0,
                            "want_more": want_more,
                          }
                        )
                      )
                    :
                      {
                        "events": {
                          "error": {
                            "code": string(get_resp.StatusCode),
                            "id": string(get_resp.Status),
                            "message": "GET:" + (
                              (size(get_resp.Body) != 0) ?
                                string(get_resp.Body)
                              :
                                string(get_resp.Status) + " (" + string(get_resp.StatusCode) + ")"
                            ),
                          },
                        },
                        "want_more": false,
                        "next": {},
                      }
                    )
                  ).as(state,
                    state.with(
                      !has(state.?next.resources) ? // Exit early due to GET failure or no resources to collect.
                        state
                      :
                        post_request(
                          state.url + "/devices/entities/devices/v2",
                          "application/json",
                          {"ids": state.next.resources}.encode_json()
                        ).do_request().as(post_resp, (post_resp.StatusCode == 200) ?
                          bytes(post_resp.Body).decode_json().as(inner_body,
                            {
                              "events": inner_body.resources.map(e,
                                {
                                  "message": e.encode_json(),
                                }
                              ),
                              "cursor": {
                                ?"last_timestamp": (has(inner_body.resources) && inner_body.resources.size() > 0) ?
                                  optional.of(inner_body.resources.map(e, timestamp(e.modified_timestamp)).max().format(time_layout.RFC3339))
                                :
                                  state.?cursor.last_timestamp,
                              },
                              "page": {
                                "start": state.filter,
                              },
                              "next": {},
                            }
                          )
                        :
                          {
                            "events": {
                              "error": {
                                "code": string(post_resp.StatusCode),
                                "id": string(post_resp.Status),
                                "message": "POST:" + (
                                  (size(post_resp.Body) != 0) ?
                                    string(post_resp.Body)
                                  :
                                    string(post_resp.Status) + " (" + string(post_resp.StatusCode) + ")"
                                ),
                              },
                            },
                            "want_more": false,
                            "next": {},
                          }
                        )
                    )
                  )
                )
              :
                state.with(
                  (
                    state.?want_more.orValue(false) ?
                      state.start_time
                    :
                      state.?cursor.last_timestamp.orValue(
                        (now - duration(state.initial_interval)).format(time_layout.RFC3339)
                      )
                  ).as(start_time,
                    request(
                      "GET",
                      state.url.trim_right("/") + "/devices/combined/devices/v1?" + {
                        ?"offset": state.?next.page_token.optMap(v, [v]),
                        "limit": [string(state.batch_size)],
                        "sort": ["modified_timestamp|asc"],
                        "filter": [
                          [
                            "modified_timestamp:>'" + start_time + "'",
                            ?state.?query.optMap(q, "(" + q + ")"),
                          ].join("+"),
                        ],
                        ?"fields": state.?select_fields.optMap(v, [v.trim_right(",")+",modified_timestamp"]),
                      }.format_query()
                    ).do_request().as(resp, (resp.StatusCode == 200) ?
                      resp.Body.decode_json().as(body,
                        (size(body.?errors.orValue([])) > 0) ?
                          {
                            "events": body.errors.map(error,
                              {
                                "error": {
                                  "code": string(error.code),
                                  "message": string(error.message),
                                },
                              }
                            ),
                            "next": {},
                            "want_more": false,
                          }
                        :
                          {
                            "events": has(body.resources) ?
                              body.resources.map(e,
                                {
                                  "message": e.encode_json(),
                                }
                              )
                            :
                              [],
                            "start_time": start_time,
                            "next": {
                              ?"page_token": body.?meta.pagination.next,
                            },
                            "cursor": {
                              // The records are sorted in ascending order, based on value of modified_timestamp.
                              // In the next interval we start from the last event (newest) time.
                              ?"last_timestamp": (has(body.resources) && body.resources.size() > 0) ?
                                optional.of(timestamp(body.resources[size(body.resources) - 1].modified_timestamp).format(time_layout.RFC3339))
                              :
                                state.?cursor.last_timestamp,
                            },
                            "want_more": has(body.?meta.pagination.next),
                          }
                      )
                    :
                      {
                        "events": {
                          "error": {
                            "code": string(resp.StatusCode),
                            "id": string(resp.Status),
                            "message": "GET " + state.url.trim_right("/") + "/devices/combined/devices/v1:" + (
                              (size(resp.Body) != 0) ?
                                string(resp.Body)
                              :
                                string(resp.Status) + " (" + string(resp.StatusCode) + ")"
                            ),
                          },
                        },
                        "next": {},
                        "want_more": false,
                      }
                    )
                  )
                )
            )
          publisher_pipeline.disable_host: true
          redact:
            fields: null
          resource.ssl: null
          resource.timeout: 30s
          resource.tracer:
            enabled: false
            filename: ../../logs/cel/http-request-trace-*.ndjson
            maxbackups: 5
          resource.url: http://host.tld
          state:
            batch_size: 5000
            gov_cloud: false
            initial_interval: 24h
            offset: 0
            select_fields: null
            want_more: false
          tags:
            - preserve_original_event
            - preserve_duplicate_custom_fields
            - forwarded
            - crowdstrike-host
      type: cel
      use_output: default
output_permissions:
    default:
        _elastic_agent_checks:
            cluster:
                - monitor
        _elastic_agent_monitoring:
            indices: []
        uuid-for-permissions-on-related-indices:
            indices:
                - names:
                    - logs-crowdstrike.host-ep
                  privileges:
                    - auto_configure
                    - create_doc
secret_references:
    - {}
