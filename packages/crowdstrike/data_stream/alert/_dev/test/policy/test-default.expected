inputs:
    - data_stream:
        namespace: ep
      meta:
        package:
            name: crowdstrike
      name: test-default-crowdstrike
      streams:
        - auth.oauth2:
            client.id: test_client_id
            client.secret: ${SECRET_0}
            token_url: http://host.tld/oauth2/token
          config_version: 2
          data_stream:
            dataset: crowdstrike.alert
            type: logs
          interval: 5m
          program: |-
            (
              state.want_more ?
                state.?page.start
              :
                optional.of(state.?cursor.last_timestamp.orValue((now - duration(state.initial_interval)).format(time_layout.RFC3339)))
            ).as(filter,
              state.with(
                get_request(
                  state.url.trim_right("/") + "/alerts/queries/alerts/v2?" + {
                    "sort": ["timestamp|asc"],
                    "offset": [string(state.offset)],
                    "limit": [string(state.batch_size)],
                    ?"filter": (filter.hasValue() || state.?query.orValue("") != "") ?
                      optional.of(
                        [
                          [
                            ?filter.optMap(f, "timestamp:>\"" + f + "\""),
                            ?state.?query.optMap(q, "(" + q + ")"),
                          ].join("+"),
                        ]
                      )
                    :
                      optional.none(),
                  }.format_query()
                ).do_request().as(get_resp, (get_resp.StatusCode == 200) ?
                  bytes(get_resp.Body).decode_json().as(body,
                    (int(state.offset) + body.resources.size() < body.meta.pagination.total).as(want_more,
                      {
                        ?"resources": (body.resources.size() > 0) ? optional.of(body.resources) : optional.none(),
                        "events": [],
                        "offset": want_more ? (int(state.offset) + body.resources.size()) : 0,
                        "want_more": want_more,
                      }
                    )
                  )
                :
                  {
                    "events": {
                      "error": {
                        "code": string(get_resp.StatusCode),
                        "id": string(get_resp.Status),
                        "message": "GET:" + (
                          (size(get_resp.Body) != 0) ?
                            string(get_resp.Body)
                          :
                            string(get_resp.Status) + " (" + string(get_resp.StatusCode) + ")"
                        ),
                      },
                    },
                    "want_more": false,
                  }
                )
              ).as(state,
                state.with(
                  !has(state.resources) ? // Exit early due to GET failure or no resources to collect.
                    state
                  :
                    post_request(
                      state.url.trim_right("/") + "/alerts/entities/alerts/v2",
                      "application/json",
                      {"composite_ids": state.resources}.encode_json()
                    ).do_request().as(post_resp, (post_resp.StatusCode == 200) ?
                      bytes(post_resp.Body).decode_json().as(inner_body,
                        {
                          "events": inner_body.resources.map(e,
                            {
                              "message": e.encode_json(),
                            }
                          ),
                          "cursor": {
                            ?"last_timestamp": (has(inner_body.resources) && inner_body.resources.size() > 0) ?
                              optional.of(inner_body.resources.map(e, timestamp(e.timestamp)).max().format(time_layout.RFC3339))
                            :
                              state.?cursor.last_timestamp,
                          },
                          "page": {
                            "start": has(state.?cursor.start) ?
                              (state.want_more ? state.cursor.start : state.cursor.last_timestamp)
                            :
                              now.format(time_layout.RFC3339),
                          },
                        }
                      )
                    :
                      {
                        "events": {
                          "error": {
                            "code": string(post_resp.StatusCode),
                            "id": string(post_resp.Status),
                            "message": "POST:" + (
                              (size(post_resp.Body) != 0) ?
                                string(post_resp.Body)
                              :
                                string(post_resp.Status) + " (" + string(post_resp.StatusCode) + ")"
                            ),
                          },
                        },
                        "want_more": false,
                      }
                    )
                )
              )
            )
          publisher_pipeline.disable_host: true
          redact:
            fields: null
          resource.ssl: null
          resource.timeout: 30s
          resource.tracer:
            enabled: false
            filename: ../../logs/cel/http-request-trace-*.ndjson
            maxbackups: 5
          resource.url: http://host.tld
          state:
            batch_size: 1000
            initial_interval: 24h
            offset: 0
            want_more: false
          tags:
            - preserve_original_event
            - preserve_duplicate_custom_fields
            - forwarded
            - crowdstrike-alert
      type: cel
      use_output: default
output_permissions:
    default:
        _elastic_agent_checks:
            cluster:
                - monitor
        _elastic_agent_monitoring:
            indices: []
        uuid-for-permissions-on-related-indices:
            indices:
                - names:
                    - logs-crowdstrike.alert-ep
                  privileges:
                    - auto_configure
                    - create_doc
secret_references:
    - {}
