---
description: Pipeline for parsing checkpoint firewall logs
processors:
  - set:
      field: ecs.version
      value: '8.11.0'
  - set:
      tag: set_event_original
      field: event.original
      copy_from: message
  - remove:
      tag: remove_message
      field: message
      ignore_missing: true
  - grok:
      field: event.original
      tag: "grok_syslog_line"
      patterns:
        - '%{SYSLOG5424PRI}%{NONNEGINT:syslog5424_ver} +(?:%{TIMESTAMP}|-)
          +(?:%{IPORHOST:syslog5424_host}|-) +(-|%{SYSLOG5424PRINTASCII:syslog5424_app})
          +(-|%{SYSLOG5424PRINTASCII:syslog5424_proc}) +(?::-|%{SYSLOG5424PRINTASCII:syslog5424_msgid})
          +\[%{GREEDYDATA:syslog5424_sd}\]'
      pattern_definitions:
        TIMESTAMP: "%{TIMESTAMP_ISO8601:syslog5424_ts}(?:-?%{ISO8601_TIMEZONE:_temp_.tz})?"
        TIMESTAMP_ISO8601: "%{YEAR}-%{MONTHNUM}-%{MONTHDAY}[T ]%{HOUR}:?%{MINUTE}(?::?%{SECOND})?"
      on_failure:
        - append:
            field: error.message
            value: "fail-{{{ _ingest.on_failure_processor_tag }}}"
        - fail:
            message: "Processor {{ _ingest.on_failure_processor_type }} with tag {{ _ingest.on_failure_processor_tag }} in pipeline {{ _ingest.on_failure_pipeline }} failed with message: {{ _ingest.on_failure_message }}"
  - kv:
      tag: "kv_syslog_structured_semicolon_colon"
      field: syslog5424_sd
      field_split: '(?<="); '
      value_split: '(?i)(?<=[a-z]):{1,2}(?=")'
      trim_key: " "
      trim_value: " "
      prefix: checkpoint.
      strip_brackets: true
      ignore_failure: true
      exclude_keys:
        - flags
        - layer_uuid
        - __policy_id_tag
        - version
        - rounded_bytes
        - db_tag
        - update_service
      on_failure:
        - append:
            field: error.message
            value: "fail-{{{ _ingest.on_failure_processor_tag }}}"
        - fail:
            message: "Processor {{ _ingest.on_failure_processor_type }} with tag {{ _ingest.on_failure_processor_tag }} in pipeline {{ _ingest.on_failure_pipeline }} failed with message: {{ _ingest.on_failure_message }}"
  - grok:
      field: syslog5424_sd
      if: ctx.checkpoint == null
      patterns:
        - '(?:%{NOTSPACE} +)?%{GREEDYDATA:syslog5424_sd}'
  - kv:
      tag: "kv_syslog_structured_space_equals"
      if: ctx.checkpoint == null
      field: syslog5424_sd
      field_split: '(?<=") '
      value_split: '(?i)(?<=[a-z])=(?=")'
      trim_key: " "
      trim_value: " "
      prefix: checkpoint.
      strip_brackets: true
      ignore_failure: true
      exclude_keys:
        - flags
        - layer_uuid
        - __policy_id_tag
        - version
        - rounded_bytes
        - db_tag
        - update_service
        - ProductName
        - ProductFamily
        - UP_match_table
        - ROW_END
      on_failure:
        - append:
            field: error.message
            value: "fail-{{{ _ingest.on_failure_processor_tag }}}"
        - fail:
            message: "Processor {{ _ingest.on_failure_processor_type }} with tag {{ _ingest.on_failure_processor_tag }} in pipeline {{ _ingest.on_failure_pipeline }} failed with message: {{ _ingest.on_failure_message }}"
  - foreach:
      field: checkpoint
      ignore_missing: true
      ignore_failure: true
      processor:
        lowercase:
          field: "_ingest._key"
  - remove:
      field:
        - syslog5424_sd
        - syslog5424_app
        - syslog5424_host
        - syslog5424_msgid
        - syslog5424_pri
        - syslog5424_proc
        - syslog5424_ver
        - host
      ignore_missing: true
  - rename:
      field: "@timestamp"
      target_field: "event.created"
      ignore_missing: true
  # Time zone can come from three sources, choose in order: log, config, locale, default to UTC.
  - set:
      field: _temp_.tz
      value: UTC
      if: ctx._temp_?.tz == 'Z'
  - set:
      field: _temp_.tz
      copy_from: _conf.tz_offset
      override: false
      if: ctx._conf?.tz_offset != null && ctx._conf?.tz_offset != 'local'
  - set:
      field: _temp_.tz
      copy_from: event.timezone
      override: false
      if: ctx.event?.timezone != null
  - set:
      field: _temp_.tz
      value: UTC
      override: false
  - set:
      field: event.timezone
      copy_from: _temp_.tz
  - gsub:
      field: event.timezone
      pattern: '([+-][0-9]{2})([0-9]{2})'
      replacement: '$1:$2'
      ignore_missing: true
  - gsub:
      field: event.timezone
      pattern: '([+-])([0-9]):?([0-9]{2})'
      replacement: '$10$2:$3'
      ignore_missing: true
  - date:
      field: "syslog5424_ts"
      timezone: "{{{ event.timezone }}}"
      formats: ["ISO8601", "UNIX"]
      if: "ctx.checkpoint?.time == null"
      on_failure:
        - remove:
            field: event.timezone
            ignore_missing: true
        # Try to re-parse as UTC to catch when TZ is invalid or unknown.
        - date:
            tag: "date_utc_fallback"
            field: "syslog5424_ts"
            formats: ["ISO8601", "UNIX"]
            on_failure:
              - append:
                  field: error.message
                  value: "fail-{{{ _ingest.on_failure_processor_tag }}}"
              - fail:
                  message: "Processor {{ _ingest.on_failure_processor_type }} with tag {{ _ingest.on_failure_processor_tag }} in pipeline {{ _ingest.on_failure_pipeline }} failed with message: {{ _ingest.on_failure_message }}"
  # Some log events lack loguid and time, so to avoid potential
  # collisions hash the complete line in those rare cases.
  - fingerprint:
      if: ctx.checkpoint?.loguid == null && ctx.checkpoint?.time == null
      fields:
        - event.original
      target_field: "_id"
      ignore_missing: true
  - fingerprint:
      if: ctx._id == null
      fields:
        - '@timestamp'
        - checkpoint.loguid
        - checkpoint.time
        - checkpoint.segment_time
      target_field: "_id"
      ignore_missing: true
  - append:
      field: event.category
      value: network
      if: "!['Log In','Log Out'].contains(ctx.checkpoint?.operation) && !['Log In','Log Out'].contains(ctx.checkpoint?.action)"
      allow_duplicates: false
  - set:
      field: observer.vendor
      value: Checkpoint
  - set:
      field: observer.type
      value: firewall
      if: ctx.checkpoint?.type == null
  - set:
      field: observer.product
      value: "{{checkpoint.product}}"
      ignore_empty_value: true
  - rename:
      field: checkpoint.src
      target_field: source.ip
      ignore_missing: true
  - rename:
      field: checkpoint.client_ip
      target_field: source.ip
      ignore_missing: true
      if: ctx.source?.ip == null
  - rename:
      field: checkpoint.xlatesrc
      target_field: source.nat.ip
      if: "ctx.checkpoint?.xlatesrc != '0.0.0.0' && ctx.checkpoint?.xlatesrc != ''"
      ignore_missing: true
  - rename:
      field: checkpoint.dst
      target_field: destination.ip
      ignore_missing: true
  - rename:
      field: checkpoint.xlatedst
      target_field: destination.nat.ip
      if: "ctx.checkpoint?.xlatedst != '0.0.0.0' && ctx.checkpoint?.xlatedst != ''"
      ignore_missing: true
  - rename:
      field: checkpoint.uid
      target_field: source.user.id
      ignore_missing: true
  - rename:
      field: checkpoint.administrator
      target_field: source.user.name
      ignore_missing: true
  - rename:
      field: checkpoint.src_user_name
      target_field: source.user.name
      if: ctx.source?.user?.name == null
      ignore_missing: true
  - convert:
      field: checkpoint.client_outbound_packets
      target_field: source.packets
      type: long
      ignore_failure: true
      ignore_missing: true
  - convert:
      field: checkpoint.server_outbound_packets
      target_field: destination.packets
      type: long
      ignore_failure: true
      ignore_missing: true
  - convert:
      field: checkpoint.client_outbound_bytes
      target_field: source.bytes
      type: long
      ignore_failure: true
      ignore_missing: true
  - convert:
      field: checkpoint.sent_byte
      target_field: source.bytes
      type: long
      ignore_failure: true
      ignore_missing: true
      if: ctx.source?.bytes == null
  - convert:
      field: checkpoint.server_outbound_bytes
      target_field: destination.bytes
      type: long
      ignore_failure: true
      ignore_missing: true
  - convert:
      field: checkpoint.received_bytes
      target_field: destination.bytes
      type: long
      ignore_failure: true
      ignore_missing: true
      if: ctx.destination?.bytes == null
  - convert:
      field: checkpoint.service
      target_field: destination.port
      type: long
      ignore_failure: true
      ignore_missing: true
  - convert:
      field: checkpoint.xlatedport
      target_field: destination.nat.port
      type: long
      ignore_failure: true
      ignore_missing: true
      if: "ctx.checkpoint?.xlatedport != '0'"
  - convert:
      field: checkpoint.s_port
      target_field: source.port
      type: long
      ignore_failure: true
      ignore_missing: true
  - convert:
      field: checkpoint.xlatesport
      target_field: source.nat.port
      type: long
      ignore_failure: true
      ignore_missing: true
      if: "ctx.checkpoint?.xlatesport != '0'"
  - rename:
      field: checkpoint.mac_source_address
      target_field: source.mac
      ignore_missing: true
  - rename:
      field: checkpoint.src_machine_name
      target_field: source.domain
      ignore_missing: true
  - rename:
      field: checkpoint.destination_dns_hostname
      target_field: destination.domain
      ignore_missing: true
  - rename:
      field: checkpoint.dst_machine_name
      target_field: destination.domain
      if: ctx.server?.domain == null
      ignore_missing: true
  - rename:
      field: checkpoint.dst_user_name
      target_field: destination.user.name
      ignore_missing: true
  - rename:
      field: checkpoint.dst_user_dn
      target_field: destination.user.domain
      ignore_missing: true
  - rename:
      field: checkpoint.src_user_group
      target_field: source.user.group.name
      ignore_missing: true
  - append:
      field: event.category
      value: authentication
      if: ctx.checkpoint?.operation == 'Log In' || ctx.checkpoint?.operation == 'Log Out'
      allow_duplicates: false
  - rename:
      field: checkpoint.originsicname
      target_field: checkpoint.origin_sic_name
      ignore_missing: true
  - set:
      field: event.kind
      value: alert
      if: "['Prevent', 'Detect', 'Quarantine'].contains(ctx.checkpoint?.rule_action)"
  - set:
      field: event.kind
      value: event
      if: ctx.event?.kind == null
  - set:
      field: event.outcome
      value: success
      if: "['Accept', 'Allow'].contains(ctx.checkpoint?.rule_action)"
  - append:
      field: event.type
      value:
        - allowed
        - connection
      if: "['Accept', 'Allow'].contains(ctx.checkpoint?.rule_action) && (ctx.checkpoint?.operation != 'Log In' && ctx.checkpoint?.operation != 'Log Out')"
  - set:
      field: event.outcome
      value: success
      if: ctx.checkpoint?.audit_status == 'Success'
  - set:
      field: event.outcome
      value: failure
      if: ctx.checkpoint?.audit_status == 'Failure'
  - set:
      field: event.outcome
      value: success
      if: "['Drop', 'Reject', 'Block', 'Prevent'].contains(ctx.checkpoint?.rule_action)"
  - append:
      field: event.type
      value:
        - connection
        - denied
      if: "['Drop', 'Reject', 'Block', 'Prevent'].contains(ctx.checkpoint?.rule_action)"
  - append:
      field: event.category
      value: malware
      if: ctx.checkpoint?.malware_action != null
      allow_duplicates: false
  - append:
      field: event.category
      value: intrusion_detection
      if: "['Detect', 'Prevent'].contains(ctx.checkpoint?.rule_action)"
      allow_duplicates: false
  - set:
      field: event.outcome
      value: success
      if: ctx.checkpoint?.action == 'Log In'
  - set:
      field: event.outcome
      value: failure
      if: ctx.checkpoint?.action == 'Failed Log In'
  - set:
      field: event.outcome
      value: success
      if: ctx.checkpoint?.operation == 'Log Out'
      override: true
      description: "Set 'success' outcome for logoff activity."
  - set:
      field: event.outcome
      value: success
      if: ctx.checkpoint?.operation == 'Log In' && (ctx.checkpoint?.audit_status == 'Success' || ctx.checkpoint?.audit_status == null)
      override: true
      description: "Set 'success' outcome by default for logon events without audit outcome set."
  - append:
      field: event.category
      value: authentication
      if: "['Log In', 'Failed Log In'].contains(ctx.checkpoint?.action)"
      allow_duplicates: false
  - append:
      field: event.type
      value:  
        - start
      allow_duplicates: false
      if: ctx.checkpoint?.action == 'Log In' || ctx.checkpoint?.operation == 'Log In'
  - append:
      field: event.type
      value: end
      allow_duplicates: false
      if: ctx.checkpoint?.action == 'Log Out' || ctx.checkpoint?.operation == 'Log Out'
      description: "Add 'end' categorization type for events related to log out activities."
  - set:
      field: checkpoint.action
      value: logged-in
      if: ctx.checkpoint?.action == 'Log In'
  - append:
      field: event.type
      value: denied
      allow_duplicates: false
      if: ctx.checkpoint?.action == 'Failed Log In'
  - set:
      field: checkpoint.action
      value: logon-failed
      if: ctx.checkpoint?.action == 'Failed Log In'
  - append:
      field: related.ip
      value: "{{source.ip}}"
      allow_duplicates: false
      if: ctx.source?.ip != null
  - append:
      field: related.ip
      value: "{{source.nat.ip}}"
      allow_duplicates: false
      if: ctx.source?.nat?.ip != null
  - append:
      field: related.ip
      value: "{{destination.ip}}"
      allow_duplicates: false
      if: ctx.destination?.ip != null
  - append:
      field: related.ip
      value: "{{destination.nat.ip}}"
      allow_duplicates: false
      if: ctx.destination?.nat?.ip != null
  - append:
      field: related.hash
      value: "{{checkpoint.file_md5}}"
      allow_duplicates: false
      if: ctx.checkpoint?.file_md5 != null
  - append:
      field: related.hash
      value: "{{checkpoint.file_sha1}}"
      allow_duplicates: false
      if: ctx.checkpoint?.file_sha1 != null
  - append:
      field: related.hash
      value: "{{checkpoint.file_sha256}}"
      allow_duplicates: false
      if: ctx.checkpoint?.file_sha256 != null
  - rename:
      field: checkpoint.from
      target_field: source.user.email
      ignore_missing: true
  - rename:
      field: checkpoint.to
      target_field: destination.user.email
      ignore_missing: true
  - set:
      field: email.from.address
      value: ["{{{destination.user.email}}}"]
      if: "ctx?.destination?.user?.email != null"
  - set:
      field: email.to.address
      value: ["{{{destination.user.email}}}"]
      if: "ctx?.destination?.user?.email != null"
  - append:
      field: email.from.address
      value: "{{{checkpoint.mime_from}}}"
      if: "ctx?.checkpoint?.mime_from != null"
  - append:
      field: email.to.address
      value: "{{{checkpoint.mime_to}}}"
      if: "ctx?.checkpoint?.mime_to != null"
  - set:
      field: email.subject
      copy_from: checkpoint.email_subject
      if: "ctx?.checkpoint?.email_subject != null"
  - append:
      field: email.bcc.address
      value: "{{{checkpoint.bcc}}}"
      if: "ctx?.checkpoint?.bcc != null"
  - append:
      field: email.cc.address
      value: "{{{checkpoint.cc}}}"
      if: "ctx?.checkpoint?.cc != null"
  - set:
      field: email.delivery_timestamp
      copy_from: checkpoint.delivery_time
      if: "ctx?.checkpoint?.delivery_time != null"
  - set:
      field: email.message_id
      copy_from: checkpoint.email_message_id
      if: "ctx?.checkpoint?.email_message_id != null"
  - set:
      field: email.local_id
      copy_from: checkpoint.email_queue_id
      if: "ctx?.checkpoint?.email_queue_id != null"
  - rename:
      field: checkpoint.usercheck_incident_uid
      target_field: destination.user.id
      ignore_missing: true
  - rename:
      field: checkpoint.service_name
      target_field: destination.service.name
      ignore_missing: true
  - rename:
      field: checkpoint.mac_destination_address
      target_field: destination.mac
      ignore_missing: true
  - rename:
      field: checkpoint.dns_type
      target_field: dns.question.type
      ignore_missing: true
  - rename:
      field: checkpoint.domain_name
      target_field: dns.question.name
      ignore_missing: true
  - rename:
      field: dns.question.name
      target_field: source.user.domain
      ignore_missing: true
      if: ctx.checkpoint?.operation == 'Log Out' && ctx.source?.user?.domain == null
  - dissect:
      field: checkpoint.additional_info
      pattern: 'Administrator failed to log in: %{event.reason}'
      ignore_missing: true
      ignore_failure: true
      if: ctx.checkpoint?.operation == 'Log In' && ctx.checkpoint.audit_status == 'Failure' && (ctx.event?.reason == null || ctx.event?.reason == "")
  - rename:
      field: checkpoint.dns_message_type
      target_field: dns.type
      ignore_missing: true
  - rename:
      field: checkpoint.tid
      target_field: dns.id
      ignore_missing: true
  - rename:
      field: checkpoint.loguid
      target_field: event.id
      ignore_missing: true
  - convert:
      field: checkpoint.sequencenum
      target_field: event.sequence
      type: long
      ignore_failure: true
      ignore_missing: true
  - convert:
      field: checkpoint.severity
      target_field: event.severity
      type: long
      ignore_failure: true
      ignore_missing: true
  - rename:
      field: checkpoint.action
      target_field: event.action
      ignore_missing: true
  - set:
      field: event.action
      value: logon-failed
      override: true
      if: ctx.checkpoint?.operation == 'Log In' && ctx.checkpoint.audit_status == 'Failure'
      description: "Set 'logon-failed' action categorization for failed logon attempts."
  - set:
      field: event.action
      value: logged-in
      override: true
      if: ctx.checkpoint?.operation == 'Log In' && (ctx.checkpoint.audit_status == 'Success' || ctx.checkpoint.audit_status == null)
      description: "Set 'logged-in' action categorization for events related to successful logons."
  - set:
      field: event.action
      value: logged-out
      override: true
      if: ctx.checkpoint?.operation == 'Log Out'
      description: "Set 'logged-out' action categorization for logoff events."
  - set:
      field: host.name
      value: '{{{ checkpoint.device_name }}}'
      override: false
      ignore_empty_value: true
      if: ctx.checkpoint?.operation == 'Log In' && ctx.observer?.product == 'Expert Shell'
      description: "Copy the device name to the host.name field for logon events in Checkpoint expert shells."
  - set:
      field: host.type
      value: '{{{ checkpoint.device_type }}}'
      override: false
      ignore_empty_value: true
      if: ctx.checkpoint?.operation == 'Log In' && ctx.observer?.product == 'Expert Shell'
      description: "Copy the device type to the host.type field for logon events in Checkpoint expert shells."
  - set:
      field: source.domain
      value: '{{{ checkpoint.machine }}}'
      override: false
      ignore_empty_value: true
      if: "['Log In', 'Log Out'].contains(ctx.checkpoint?.operation) && ctx.checkpoint.machine != 'localhost'"
      description: "Copy the device type to the host.type field for logon events in Checkpoint expert shells."
  - set:
      field: network.protocol
      value: ssh
      override: false
      if: ctx.checkpoint?.operation == 'Log In' && ctx.observer?.product == 'Expert Shell'
      description: "Set network protocol to SSH for logon activities made with Checkpoint expert shells."
  - set:
      field: user.name
      value: '{{{ source.user.name }}}'
      override: false
      ignore_empty_value: true
  - set:
      field: user.id
      value: '{{{ source.user.id }}}'
      override: false
      ignore_empty_value: true
  - set:
      field: user.group.name
      value: '{{{ source.user.group.name }}}'
      override: false
      ignore_empty_value: true
  - set:
      field: user.email
      value: '{{{ source.user.email }}}'
      override: false
      ignore_empty_value: true
  - set:
      field: user.domain
      value: '{{{ source.user.domain }}}'
      override: false
      ignore_empty_value: true
  - append:
      field: user.roles
      value: administrator
      allow_duplicates: false
      if: ctx.message == 'Administrator Login' || ctx.message == 'Administrator Logout' || ctx.message == 'Administrator Expert Shell login'
      description: "Add administrator label to the user.role field for all events related to administrator logon / logoff activities."
  - set:
      field: event.code
      value: '{{{ checkpoint.operation_number }}}'
      override: false
      ignore_empty_value: true
  - lowercase:
      field: user.name
      ignore_missing: true
  - lowercase:
      field: user.id
      ignore_missing: true
  - lowercase:
      field: user.email
      ignore_missing: true
  - lowercase:
      field: user.domain
      ignore_missing: true
  - lowercase:
      field: user.group.name
      ignore_missing: true
  - rename:
      field: checkpoint.packet_capture
      target_field: event.url
      ignore_missing: true
  - rename:
      field: checkpoint.start_time
      target_field: event.start
      ignore_missing: true
  - rename:
      field: checkpoint.first_detection
      target_field: event.start
      ignore_missing: true
      if: ctx.event?.start == null
  - rename:
      field: checkpoint.last_detection
      target_field: event.end
      ignore_missing: true
  - rename:
      field: checkpoint.app_risk
      target_field: event.risk_score
      ignore_missing: true
  - rename:
      field: checkpoint.file_id
      target_field: file.inode
      ignore_missing: true
  - rename:
      field: checkpoint.file_type
      target_field: file.type
      ignore_missing: true
  - rename:
      field: checkpoint.file_name
      target_field: file.name
      ignore_missing: true
  - convert:
      field: checkpoint.file_size
      target_field: file.size
      type: long
      ignore_failure: true
      ignore_missing: true
  - rename:
      field: checkpoint.file_md5
      target_field: file.hash.md5
      ignore_missing: true
  - rename:
      field: checkpoint.file_sha1
      target_field: file.hash.sha1
      ignore_missing: true
  - rename:
      field: checkpoint.file_sha256
      target_field: file.hash.sha256
      ignore_missing: true
  - rename:
      field: checkpoint.dlp_file_name
      target_field: file.name
      ignore_missing: true
  - rename:
      field: checkpoint.user_group
      target_field: group.name
      ignore_missing: true
  - rename:
      field: checkpoint.os_version
      target_field: host.os.version
      ignore_missing: true
  - rename:
      field: checkpoint.os_name
      target_field: host.os.name
      ignore_missing: true
  - rename:
      field: checkpoint.method
      target_field: http.request.method
      ignore_missing: true
  - rename:
      field: checkpoint.referrer
      target_field: http.request.referrer
      ignore_missing: true
  - rename:
      field: checkpoint.service_id
      target_field: network.application
      ignore_missing: true
  - rename:
      field: checkpoint.ifdir
      target_field: network.direction
      ignore_missing: true
  - convert:
      field: checkpoint.bytes
      type: long
      ignore_missing: true
  - convert:
      field: checkpoint.icmp_code
      type: long
      ignore_missing: true
      ignore_failure: true
  - convert:
      field: checkpoint.icmp_type
      type: long
      ignore_missing: true
      ignore_failure: true
  - rename:
      field: checkpoint.bytes
      target_field: network.bytes
      ignore_missing: true
  - rename:
      field: checkpoint.proto
      target_field: network.iana_number
      ignore_missing: true
  - script:
      lang: painless
      ignore_failure: true
      if: ctx?.network?.iana_number != null
      source: |
        def iana_number = ctx.network.iana_number;
        if (iana_number == '0') {
            ctx.network.transport = 'hopopt';
        } else if (iana_number == '1') {
            ctx.network.transport = 'icmp';
        } else if (iana_number == '2') {
            ctx.network.transport = 'igmp';
        } else if (iana_number == '6') {
            ctx.network.transport = 'tcp';
        } else if (iana_number == '8') {
            ctx.network.transport = 'egp';
        } else if (iana_number == '17') {
            ctx.network.transport = 'udp';
        } else if (iana_number == '47') {
            ctx.network.transport = 'gre';
        } else if (iana_number == '50') {
            ctx.network.transport = 'esp';
        } else if (iana_number == '58') {
            ctx.network.transport = 'ipv6-icmp';
        } else if (iana_number == '112') {
            ctx.network.transport = 'vrrp';
        } else if (iana_number == '132') {
            ctx.network.transport = 'sctp';
        }
  - date:
      field: checkpoint.subs_exp
      target_field: checkpoint.subs_exp
      timezone: "{{{ event.timezone }}}"
      formats:
        - 'EEE MMM dd HH:mm:ss yyyy'
        - 'EEE MMM  d HH:mm:ss yyyy'
        - 'EEE MMM d HH:mm:ss yyyy'
        - ISO8601
        - UNIX
      if: "ctx.checkpoint?.subs_exp != null"
      on_failure:
        # Try to re-parse as UTC to catch when TZ is invalid or unknown.
        - date:
            tag: "date_utc_fallback"
            field: checkpoint.subs_exp
            target_field: checkpoint.subs_exp
            formats:
              - 'EEE MMM dd HH:mm:ss yyyy'
              - 'EEE MMM  d HH:mm:ss yyyy'
              - 'EEE MMM d HH:mm:ss yyyy'
              - ISO8601
              - UNIX
            on_failure:
              - remove:
                  field: checkpoint.subs_exp
                  ignore_missing: true
  - convert:
      field: checkpoint.packets
      type: long
      ignore_missing: true
  - rename:
      field: checkpoint.packets
      target_field: network.packets
      ignore_missing: true
  - rename:
      field: checkpoint.layer_name
      target_field: network.name
      ignore_missing: true
  - rename:
      field: checkpoint.app_name
      target_field: network.application
      ignore_missing: true
  - rename:
      field: checkpoint.client_inbound_interface
      target_field: observer.ingress.interface.name
      ignore_missing: true
  - rename:
      field: checkpoint.client_outbound_interface
      target_field: observer.egress.interface.name
      ignore_missing: true
  - rename:
      field: checkpoint.ifname
      target_field: observer.ingress.interface.name
      ignore_missing: true
      if: ctx.observer?.ingress?.interface?.name == null && ctx.network?.direction == 'inbound'
  - rename:
      field: checkpoint.ifname
      target_field: observer.egress.interface.name
      ignore_missing: true
      if: ctx.observer?.egress?.interface?.name == null && ctx.network?.direction == 'outbound'
  - rename:
      field: checkpoint.type
      target_field: observer.type
      ignore_missing: true
  - rename:
      field: checkpoint.origin
      target_field: observer.name
      ignore_missing: true
  - rename:
      field: checkpoint.mac_address
      target_field: _temp_.observer.mac
      ignore_missing: true
  - gsub:
      field: _temp_.observer.mac
      ignore_missing: true
      pattern: '[:]'
      replacement: '-'
  - uppercase:
      field: _temp_.observer.mac
      ignore_missing: true
  - append:
      value: "{{{_temp_.observer.mac}}}"
      field: observer.mac
      if: ctx._temp_?.observer?.mac != null
  - append:
      value: "{{{checkpoint.origin_ip}}}"
      field: observer.ip
      if: ctx.checkpoint?.origin_ip != null
  - append:
      value: "{{{checkpoint.endpoint_ip}}}"
      field: observer.ip
      if: ctx.checkpoint?.endpoint_ip != null && ctx.observer?.ip == null
  - rename:
      field: checkpoint.outzone
      target_field: observer.egress.zone
      ignore_missing: true
  - rename:
      field: checkpoint.inzone
      target_field: observer.ingress.zone
      ignore_missing: true
  - rename:
      field: checkpoint.security_outzone
      target_field: observer.egress.zone
      ignore_missing: true
      if: ctx.observer?.egress?.zone == null
  - rename:
      field: checkpoint.security_inzone
      target_field: observer.ingress.zone
      ignore_missing: true
      if: ctx.observer?.ingress?.zone == null
  - rename:
      field: checkpoint.update_version
      target_field: observer.version
      ignore_missing: true
  - rename:
      field: checkpoint.process_md5
      target_field: process.hash.md5
      ignore_missing: true
  - rename:
      field: checkpoint.process_name
      target_field: process.name
      ignore_missing: true
  - rename:
      field: checkpoint.parent_process_md5
      target_field: process.parent.hash.md5
      ignore_missing: true
  - rename:
      field: checkpoint.parent_process_name
      target_field: process.parent.name
      ignore_missing: true
  - rename:
      field: checkpoint.matched_category
      target_field: rule.category
      ignore_missing: true
  - rename:
      field: checkpoint.categories
      target_field: rule.category
      ignore_missing: true
      if: ctx.rule?.category == null
  - rename:
      field: checkpoint.malware_action
      target_field: rule.description
      ignore_missing: true
  - rename:
      field: checkpoint.malware_rule_id
      target_field: rule.id
      ignore_missing: true
  - rename:
      field: checkpoint.app_rule_id
      target_field: rule.id
      ignore_missing: true
      if: ctx.rule?.id == null
  - rename:
      field: checkpoint.objectname
      target_field: rule.name
      ignore_missing: true
  - rename:
      field: checkpoint.rule_name
      target_field: rule.name
      ignore_missing: true
      if: ctx.rule?.name == null
  - rename:
      field: checkpoint.malware_rule_name
      target_field: rule.name
      ignore_missing: true
      if: ctx.rule?.name == null
  - rename:
      field: checkpoint.app_rule_name
      target_field: rule.name
      ignore_missing: true
      if: ctx.rule?.name == null
  - rename:
      field: checkpoint.dlp_rule_name
      target_field: rule.name
      ignore_missing: true
      if: ctx.rule?.name == null
  - rename:
      field: checkpoint.smartdefence_profile
      target_field: rule.ruleset
      ignore_missing: true
  - rename:
      field: checkpoint.policy
      target_field: rule.ruleset
      ignore_missing: true
      if: ctx.rule?.ruleset == null
  - rename:
      field: checkpoint.rule_uid
      target_field: rule.uuid
      ignore_missing: true
  - rename:
      field: checkpoint.dlp_rule_uid
      target_field: rule.uuid
      ignore_missing: true
      if: ctx.rule?.uuid == null
  - rename:
      field: checkpoint.url
      target_field: url.original
      ignore_missing: true
  - rename:
      field: checkpoint.resource
      target_field: url.original
      ignore_missing: true
      if: ctx.url?.original == null
  - rename:
      field: checkpoint.http_host
      target_field: url.domain
      ignore_missing: true
  - rename:
      field: checkpoint.web_client_type
      target_field: user_agent.name
      ignore_missing: true
  - rename:
      field: checkpoint.user_agent
      target_field: user_agent.original
      ignore_missing: true
  - rename:
      field: checkpoint.industry_reference
      target_field: vulnerability.id
      ignore_missing: true
  - script:
      lang: painless
      tag: "checkpoint_time_conversion_script"
      if: "ctx.checkpoint?.time != null && (ctx.checkpoint.time instanceof String || ctx.checkpoint.time instanceof List)"
      source: |
        ZonedDateTime convert(String time) {
          ZonedDateTime zdt;
          try {
            Instant instant;
            long temp_time = Long.parseLong(time);
            if (String.valueOf(temp_time).length() > 10) {
              instant = Instant.ofEpochMilli(temp_time);
            } else {
              instant = Instant.ofEpochMilli(temp_time * 1000L);
            }
            zdt = ZonedDateTime.ofInstant(instant, ZoneId.of('Z'));
          }
          catch (NumberFormatException nfe) {
            zdt = ZonedDateTime.parse(time);
          }
          return zdt
        }

        // Handle single time field.
        if (ctx.checkpoint.time instanceof String) {
          ctx.checkpoint._temp_unixms = convert(ctx.checkpoint.time);
          return;
        }

        // Some log lines have more than one time. Pick the earliest and retain all.
        List zdt = new ArrayList();
        for (def time: ctx.checkpoint.time) {
          zdt.add(convert(time));
        }
        ctx.checkpoint.times = zdt;
        ctx.checkpoint._temp_unixms = Collections.min(zdt);
      on_failure:
        - append:
            field: error.message
            value: "fail-{{{ _ingest.on_failure_processor_tag }}}"
        - fail:
            message: "Processor {{ _ingest.on_failure_processor_type }} with tag {{ _ingest.on_failure_processor_tag }} in pipeline {{ _ingest.on_failure_pipeline }} failed with message: {{ _ingest.on_failure_message }}"
  - rename:
      field: checkpoint._temp_unixms
      target_field: "@timestamp"
      ignore_missing: true
  - date:
      field: checkpoint.lastupdatetime
      formats: ["ISO8601", "UNIX"]
      target_field: event.end
      if: "ctx.checkpoint?.lastupdatetime != null"
  - rename:
      field: checkpoint.message
      target_field: message
      ignore_missing: true
  - rename:
      field: checkpoint.reason
      target_field: message
      ignore_missing: true
      if: ctx.message == null
  - rename:
      field: checkpoint.subject
      target_field: message
      ignore_missing: true
      if: ctx.message == null
  - gsub:
      field: checkpoint.sys_message
      pattern: ^:"
      replacement: ""
      if: ctx.checkpoint?.sys_message != null
  - append:
      field: related.user
      value: "{{source.user.name}}"
      allow_duplicates: false
      if: ctx.source?.user?.name != null
  - append:
      field: related.user
      value: "{{destination.user.name}}"
      allow_duplicates: false
      if: ctx.destination?.user?.name != null
  - script:
      lang: painless
      source: "ctx.network.bytes = ctx.source.bytes + ctx.destination.bytes"
      if: ctx?.source?.bytes != null && ctx?.destination?.bytes != null && ctx?.network?.bytes == null
      ignore_failure: true
  - script:
      lang: painless
      source: "ctx.network.packets = ctx.source.packets + ctx.destination.packets"
      if: ctx?.source?.packets != null && ctx?.destination?.packets != null && ctx?.network?.packets == null
      ignore_failure: true
  - rename:
      field: checkpoint.action_reason
      target_field: checkpoint.action_reason_msg
      if: ctx.checkpoint?.action_reason != null && ctx.checkpoint?.action_reason.contains(" ")
      ignore_missing: true
  - geoip:
      field: source.ip
      target_field: source.geo
      ignore_missing: true
      if: ctx.source?.geo == null
  - geoip:
      field: destination.ip
      target_field: destination.geo
      ignore_missing: true
      if: ctx.destination?.geo == null
  - geoip:
      database_file: GeoLite2-ASN.mmdb
      field: source.ip
      target_field: source.as
      properties:
        - asn
        - organization_name
      ignore_missing: true
  - geoip:
      database_file: GeoLite2-ASN.mmdb
      field: destination.ip
      target_field: destination.as
      properties:
        - asn
        - organization_name
      ignore_missing: true
  - rename:
      field: source.as.asn
      target_field: source.as.number
      ignore_missing: true
  - rename:
      field: source.as.organization_name
      target_field: source.as.organization.name
      ignore_missing: true
  - rename:
      field: destination.as.asn
      target_field: destination.as.number
      ignore_missing: true
  - rename:
      field: destination.as.organization_name
      target_field: destination.as.organization.name
      ignore_missing: true
  # Handle zone-based network directionality
  - set:
      field: network.direction
      value: inbound
      if: >
        ctx?._temp_?.external_zones != null &&
        ctx?._temp_?.internal_zones != null &&
        ctx?.observer?.ingress?.zone != null &&
        ctx?.observer?.egress?.zone != null &&
        ctx._temp_.external_zones.contains(ctx.observer.ingress.zone) &&
        ctx._temp_.internal_zones.contains(ctx.observer.egress.zone)
  - set:
      field: network.direction
      value: outbound
      if: >
        ctx?._temp_?.external_zones != null &&
        ctx?._temp_?.internal_zones != null &&
        ctx?.observer?.ingress?.zone != null &&
        ctx?.observer?.egress?.zone != null &&
        ctx._temp_.external_zones.contains(ctx.observer.egress.zone) &&
        ctx._temp_.internal_zones.contains(ctx.observer.ingress.zone)
  - set:
      field: network.direction
      value: internal
      if: >
        ctx?._temp_?.external_zones != null &&
        ctx?._temp_?.internal_zones != null &&
        ctx?.observer?.ingress?.zone != null &&
        ctx?.observer?.egress?.zone != null &&
        ctx._temp_.internal_zones.contains(ctx.observer.egress.zone) &&
        ctx._temp_.internal_zones.contains(ctx.observer.ingress.zone)
  - set:
      field: network.direction
      value: external
      if: >
        ctx?._temp_?.external_zones != null &&
        ctx?._temp_?.internal_zones != null &&
        ctx?.observer?.ingress?.zone != null &&
        ctx?.observer?.egress?.zone != null &&
        ctx._temp_.external_zones.contains(ctx.observer.egress.zone) &&
        ctx._temp_.external_zones.contains(ctx.observer.ingress.zone)
  - set:
      field: network.direction
      value: unknown
      if: >
        ctx?._temp_?.external_zones != null &&
        ctx?._temp_?.internal_zones != null &&
        ctx?.observer?.ingress?.zone != null &&
        ctx?.observer?.egress?.zone != null &&
        (
          (
            !ctx._temp_.external_zones.contains(ctx.observer.egress.zone) &&
            !ctx._temp_.internal_zones.contains(ctx.observer.egress.zone)
          ) ||
          (
            !ctx._temp_.external_zones.contains(ctx.observer.ingress.zone) &&
            !ctx._temp_.internal_zones.contains(ctx.observer.ingress.zone)
          )
        )
  - remove:
      field:
        - checkpoint.ifname
        - checkpoint.server_outbound_interface
        - checkpoint.client_outbound_packets
        - checkpoint.server_outbound_packets
        - checkpoint.client_outbound_bytes
        - checkpoint.server_outbound_bytes
        - checkpoint.client_inbound_packets
        - checkpoint.server_inbound_packets
        - checkpoint.client_inbound_bytes
        - checkpoint.server_inbound_bytes
        - checkpoint.sent_byte
        - checkpoint.received_bytes
        - checkpoint.service
        - checkpoint.xlatedport
        - checkpoint.s_port
        - checkpoint.xlatesport
        - checkpoint.contextnum
        - checkpoint.sequencenum
        - checkpoint.file_size
        - checkpoint.product
        - checkpoint.severity
        - checkpoint.xlatesrc
        - checkpoint.xlatedst
        - checkpoint.uid
        - checkpoint.time
        - checkpoint.__nsons
        - checkpoint.__p_dport
        - checkpoint.__pos
        - checkpoint.hll_key
        - checkpoint.segment_time
        - checkpoint.lastupdatetime
        - checkpoint.endpoint_ip
        - checkpoint.origin_ip
        - syslog5424_ts
        - _temp_
        - _conf
      ignore_missing: true
  - rename:
      field: checkpoint.times
      target_field: checkpoint.time
      ignore_missing: true
  - date:
      if: ctx.checkpoint?.time != null
      field: checkpoint.time
      target_field: checkpoint.time
      formats: ["UNIX"]
      ignore_failure: true
  - script:
      description: Drops null/empty values recursively.
      lang: painless
      source:
        boolean dropEmptyFields(Object object) {
          if (object == null || object == '') {
            return true;
          } else if (object instanceof Map) {
            ((Map) object).values().removeIf(value -> dropEmptyFields(value));
            return (((Map) object).size() == 0);
          } else if (object instanceof List) {
            ((List) object).removeIf(value -> dropEmptyFields(value));
            return (((List) object).length == 0);
          }
          return false;
        }
        dropEmptyFields(ctx);
  - remove:
      field: event.original
      if: "ctx?.tags == null || !(ctx.tags.contains('preserve_original_event'))"
      ignore_failure: true
      ignore_missing: true
on_failure:
  - set:
      field: event.kind
      value: pipeline_error
  - append:
      field: error.message
      value: "{{ _ingest.on_failure_message }}"
