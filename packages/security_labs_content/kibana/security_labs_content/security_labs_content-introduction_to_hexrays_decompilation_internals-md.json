{
  "attributes": {
    "raw": {
      "document": "---\ntitle: \"Introduction to Hex-Rays decompilation internals\"\nslug: \"introduction-to-hexrays-decompilation-internals\"\ndate: \"2024-02-14\"\ndescription: \"In this publication, we delve into Hex-Rays microcode and explore techniques for manipulating the generated CTree to deobfuscate and annotate decompiled code.\"\nauthor:\n  - slug: salim-bitam\nimage: \"photo-edited-05.png\"\ncategory:\n  - slug: malware-analysis\ntags:\n  - malware-analysis\n---\n\n## Introduction\n\nIn this publication, we delve into Hex-Rays microcode and explore techniques for manipulating the generated CTree to deobfuscate and annotate decompiled code. The final section includes a practical example demonstrating how to annotate a custom import table for malware analysis.\n\nThis guide is meant to help reverse engineers and malware analysts better understand the internal structures used during IDA's function decompilation. We advise keeping an eye on the [Hex-Rays SDK](https://hex-rays.com/products/decompiler/manual/sdk/index.shtml) that can be found under IDA PRO’s plugins directory, all the structures discussed below are sourced from it.\n\n## Architecture\n\nHex-Rays decompiles a function through a multistage process starting with the disassembled code of a function:\n 1. Assembly code to microcode:  \n  It does a conversion of the assembly instructions that are stored in an [`insn_t`](https://hex-rays.com/products/ida/support/sdkdoc/classinsn__t.html) structure to microcode instructions represented by a [`minsn_t`](https://hex-rays.com/products/decompiler/manual/sdk/classminsn__t.shtml) structure\n\n 2. CTree generation:  \n  From the optimized microcode, Hex-Rays generates the Abstract Syntax Tree(AST), its nodes are either statements ([`cinsn_t`](https://hex-rays.com/products/decompiler/manual/sdk/structcinsn__t.shtml)) or expressions ([`cexpr_t`](https://hex-rays.com/products/decompiler/manual/sdk/structcexpr__t.shtml)); note that both `cinsn_t` and `cexpr_t` inherit from the [`citem_t`](https://hex-rays.com/products/decompiler/manual/sdk/structcitem__t.shtml) structure\n\n## Microcode\n\nMicrocode is an intermediate language (IL) used by Hex-Rays, generated by lifting the assembly code of a binary. This has multiple advantages, one of which is that it is processor-independent.\n\nThe following screenshot displays the assembly and decompiled code, alongside its microcode extracted using [Lucid](https://github.com/gaasedelen/lucid), a tool that facilitates microcode visualization.\n\n![A view of the assembly code, decompiled code, and microcode](/assets/images/introduction-to-hexrays-decompilation-internals/image5.png)\n\nWe can access the MBA (microcode block array) through the `cfunc_t` structure of a decompiled function with the MBA field.\n\n_Tip:_ we get the `cfunc_t` of a decompiled function with the `ida_hexrays.decompile`.\n\n[`mba_t`](https://hex-rays.com/products/decompiler/manual/sdk/classmba__t.shtml) is an array of micro blocks [`mblock_t`](https://hex-rays.com/products/decompiler/manual/sdk/classmblock__t.shtml), the first block represents the entry point of the function and the last one represents the end. Micro blocks (`mblock_t`) are structured in a double linked list, we can access the next / previous block with `nextb`/`prevb` fields respectively. Each `mblock_t` includes a double linked list of microcode instructions `minsn_t`, accessed by the field `head` for the first instruction of the block and `tail` for the last instruction of the block. The `mblock_t` structure is depicted in the following code snippet.\n\n```C\nclass mblock_t\n{\n//...\npublic:\n  mblock_t *nextb;              ///< next block in the doubly linked list\n  mblock_t *prevb;              ///< previous block in the doubly linked list\n  uint32 flags;                 ///< combination of \\ref MBL_ bits\n  ea_t start;                   ///< start address\n  ea_t end;                     ///< end address\n  minsn_t *head;                ///< pointer to the first instruction of the block\n  minsn_t *tail;                ///< pointer to the last instruction of the block\n  mba_t *mba;  \n```\n  \nA microcode instruction `minsn_t` is a double linked list, each microcode instruction contains 3 operands: left, right, and destination. We can access the next/previous microcode instruction of the same block with `next`/`prev` fields; the opcode field is an enumeration ([`mcode_t`](https://hex-rays.com/products/decompiler/manual/sdk/hexrays_8hpp.shtml#:~:text=enum-,mcode_t,-%7B%0A%C2%A0%C2%A0m_nop)) of all the microinstruction opcodes, for example, the `m_mov` enum represents the `mov` opcode.\n\n```C\nclass minsn_t\n{\n//...\npublic:\n  mcode_t opcode;       ///< instruction opcode enumeration\n  int iprops;           ///< combination of \\ref IPROP_ bits\n  minsn_t *next;        ///< next insn in doubly linked list. check also nexti()\n  minsn_t *prev;        ///< prev insn in doubly linked list. check also previ()\n  ea_t ea;              ///< instruction address\n  mop_t l;              ///< left operand\n  mop_t r;              ///< right operand\n  mop_t d;              ///< destination operand\n //...\n\nenum mcode_t\n{\n  m_nop    = 0x00, // nop                       // no operation\n  m_stx    = 0x01, // stx  l,    {r=sel, d=off} // store register to memory     \n  m_ldx    = 0x02, // ldx  {l=sel,r=off}, d     // load register from memory    \n  m_ldc    = 0x03, // ldc  l=const,     d       // load constant\n  m_mov    = 0x04, // mov  l,           d       // move                        \n  m_neg    = 0x05, // neg  l,           d       // negate\n  m_lnot   = 0x06, // lnot l,           d       // logical not\n//...\n};\n```\n\nEach operand is of type [`mop_t`](https://hex-rays.com/products/decompiler/manual/sdk/classmop__t.shtml), depending on the type (accessed with the `t` field) it can hold registers, immediate values, and even nested microcode instructions. As an example, the following is the microcode of a function with multiple nested instructions:\n\n![Nested microcode instructions](/assets/images/introduction-to-hexrays-decompilation-internals/image3.png)\n\n```C\nclass mop_t\n{\n\tpublic:\n\t  /// Operand type.\n\t  mopt_t t;\n\tunion\n\t  {\n\t    mreg_t r;           // mop_r   register number\n\t    mnumber_t *nnn;     // mop_n   immediate value\n\t    minsn_t *d;         // mop_d   result (destination) of another instruction\n\t    stkvar_ref_t *s;    // mop_S   stack variable\n\t    ea_t g;             // mop_v   global variable (its linear address)\n\t    int b;              // mop_b   block number (used in jmp,call instructions)\n\t    mcallinfo_t *f;     // mop_f   function call information\n\t    lvar_ref_t *l;      // mop_l   local variable\n\t    mop_addr_t *a;      // mop_a   variable whose address is taken\n\t    char *helper;       // mop_h   helper function name\n\t    char *cstr;         // mop_str utf8 string constant, user representation\n\t    mcases_t *c;        // mop_c   cases\n\t    fnumber_t *fpc;     // mop_fn  floating point constant\n\t    mop_pair_t *pair;   // mop_p   operand pair\n\t    scif_t *scif;       // mop_sc  scattered operand info\n\t  };\n\t#...\n}\n\n/// Instruction operand types\ntypedef uint8 mopt_t;\nconst mopt_t\n  mop_z   = 0,  ///< none\n  mop_r   = 1,  ///< register (they exist until MMAT_LVARS)\n  mop_n   = 2,  ///< immediate number constant\n  mop_str = 3,  ///< immediate string constant (user representation)\n  #...\n```\n\nThe microcode generation progresses through various maturity levels, also referred to as optimization levels. The initial level, `MMAT_GENERATED`, involves the direct translation of assembly code into microcode. The final optimization level before generating the CTree is `MMAT_LVARS`.\n\n```C\nenum mba_maturity_t\n{\n  MMAT_ZERO,         ///< microcode does not exist\n  MMAT_GENERATED,    ///< generated microcode\n  MMAT_PREOPTIMIZED, ///< preoptimized pass is complete\n  MMAT_LOCOPT,       ///< local optimization of each basic block is complete.\n                     ///< control flow graph is ready too.\n  MMAT_CALLS,        ///< detected call arguments\n  MMAT_GLBOPT1,      ///< performed the first pass of global optimization\n  MMAT_GLBOPT2,      ///< most global optimization passes are done\n  MMAT_GLBOPT3,      ///< completed all global optimization. microcode is fixed now.\n  MMAT_LVARS,        ///< allocated local variables\n};\n```\n\n### Microcode traversal example\n\nThe following Python code is used as an example of how to traverse and print the microcode instructions of a function, it traverses the microcode generated at the first maturity level (`MMAT_GENERATED`).\n\n```Python\nimport idaapi\nimport ida_hexrays\nimport ida_lines\n\n\nMCODE = sorted([(getattr(ida_hexrays, x), x) for x in filter(lambda y: y.startswith('m_'), dir(ida_hexrays))])\n\ndef get_mcode_name(mcode):\n    \"\"\"\n    Return the name of the given mcode_t.\n    \"\"\"\n    for value, name in MCODE:\n        if mcode == value:\n            return name\n    return None\n\n\ndef parse_mop_t(mop):\n    if mop.t != ida_hexrays.mop_z:\n        return ida_lines.tag_remove(mop._print())\n    return ''\n\n\ndef parse_minsn_t(minsn):\n    opcode = get_mcode_name(minsn.opcode)\n    ea = minsn.ea\n    \n    text = hex(ea) + \" \" + opcode\n    for mop in [minsn.l, minsn.r, minsn.d]:\n        text += ' ' + parse_mop_t(mop)\n    print(text)\n    \n    \ndef parse_mblock_t(mblock):\n    minsn = mblock.head\n    while minsn and minsn != mblock.tail:\n        parse_minsn_t(minsn)\n        minsn = minsn.next\n    \n\ndef parse_mba_t(mba):\n    for i in range(0, mba.qty):\n        mblock_n = mba.get_mblock(i)\n        parse_mblock_t(mblock_n)\n\n\ndef main():\n    func = idaapi.get_func(here()) # Gets the function at the current cursor\n    maturity = ida_hexrays.MMAT_GENERATED\n    mbr = ida_hexrays.mba_ranges_t(func)\n    hf = ida_hexrays.hexrays_failure_t()\n    ida_hexrays.mark_cfunc_dirty(func.start_ea)\n    mba = ida_hexrays.gen_microcode(mbr, hf, None, ida_hexrays.DECOMP_NO_WAIT, maturity)\n    parse_mba_t(mba)\n\n\nif __name__ == '__main__':\n    main()\n```\n\nThe script's output is presented below: on the left, the printed microcode in the console, and on the right, the assembly code by IDA:\n\n![Microcode traversal script’s output, assembly code](/assets/images/introduction-to-hexrays-decompilation-internals/image10.png)\n\n### CTree\n\nIn this section, we'll dive into the core elements of Hex-Rays CTree structure, then proceed to a practical example demonstrating how to annotate a custom import table of malware that loads APIs dynamically.\n\nFor a better understanding, we will be leveraging the following plugin ([hrdevhelper](https://github.com/patois/HRDevHelper)) that allows us to view the CTree nodes in IDA as a graph.\n\n![CTree graph of a function generated using hrdevhelper](/assets/images/introduction-to-hexrays-decompilation-internals/image7.png)\n\n[`citem_t`](https://hex-rays.com/products/decompiler/manual/sdk/structcitem__t.shtml) is an abstract class that is the base for both [`cinsn_t`](https://hex-rays.com/products/decompiler/manual/sdk/structcinsn__t.shtml) and [`cexpr_t`](https://hex-rays.com/products/decompiler/manual/sdk/structcexpr__t.shtml), it holds common info like the address, item type and label while also featuring constants like `is_expr`, `contains_expr` that can be used to know the type of the object:\n\n```C\nstruct citem_t\n{\n  ea_t ea = BADADDR;      ///< address that corresponds to the item. may be BADADDR\n  ctype_t op = cot_empty; ///< item type\n  int label_num = -1;     ///< label number. -1 means no label. items of the expression\n                          ///< types (cot_...) should not have labels at the final maturity\n                          ///< level, but at the intermediate levels any ctree item\n                          ///< may have a label. Labels must be unique. Usually\n                          ///< they correspond to the basic block numbers.\n  mutable int index = -1; ///< an index in cfunc_t::treeitems.\n                          ///< meaningful only after print_func()\n//...\n```\n\nThe item type accessed with the `op` field indicates the type of the node, expression nodes are prefixed with `cot_` and the statements nodes are prefixed with `cit_`, example `cot_asg` indicates that the node is an assignment expression while `cit_if` indicates that the node is a condition (if) statement.\n\nDepending on the type of the statement node, a `cinsn_t` can have a different attribute for example if the item type is `cit_if` we can access the detail of the condition node through the `cif` field, as seen in the below snippet, `cinsn_t` is implemented using a union. Note that a [`cblock_t`](https://hex-rays.com/products/decompiler/manual/sdk/structcblock__t.shtml) is a block statement which is a list of `cinsn_t` statements, we can find this type for example at the beginning of a function or after a conditional statement.\n\n```C\nstruct cinsn_t : public citem_t\n{\n  union\n  {\n    cblock_t *cblock;   ///< details of block-statement\n    cexpr_t *cexpr;     ///< details of expression-statement\n    cif_t *cif;         ///< details of if-statement\n    cfor_t *cfor;       ///< details of for-statement\n    cwhile_t *cwhile;   ///< details of while-statement\n    cdo_t *cdo;         ///< details of do-statement\n    cswitch_t *cswitch; ///< details of switch-statement\n    creturn_t *creturn; ///< details of return-statement\n    cgoto_t *cgoto;     ///< details of goto-statement\n    casm_t *casm;       ///< details of asm-statement\n  };\n//...\n```\n\nIn the example below, the condition node of type `cit_if` has two child nodes: the left one is of type `cit_block` which represents the \"True\" branch and the right is the condition to evaluate, which is a call to a function, a third child is missing as the condition does not have a \"False\" branch.\n\nThe following is a graph showcasing the statement node cit_if\n\n![A graph showcasing the statement node cit_if](/assets/images/introduction-to-hexrays-decompilation-internals/image1.png)\n\nFind the associated decompilation for the above CTree:\n\n![The associated decompilation for the above CTree](/assets/images/introduction-to-hexrays-decompilation-internals/image8.png)\n\nThe same logic applies to expressions nodes `cexpr_t`, depending on the node type, different attributes are available, as an example, a node of type `cot_asg` has children nodes accessible with the fields `x` and `y`.\n\n![A graph showcasing the expression node cot_asg](/assets/images/introduction-to-hexrays-decompilation-internals/image2.png)\n\n```C\nstruct cexpr_t : public citem_t\n{\n  union\n  {\n    cnumber_t *n;     ///< used for \\ref cot_num\n    fnumber_t *fpc;   ///< used for \\ref cot_fnum\n    struct\n    {\n      union\n      {\n        var_ref_t v;  ///< used for \\ref cot_var\n        ea_t obj_ea;  ///< used for \\ref cot_obj\n      };\n      int refwidth;   ///< how many bytes are accessed? (-1: none)\n    };\n    struct\n    {\n      cexpr_t *x;     ///< the first operand of the expression\n      union\n      {\n        cexpr_t *y;   ///< the second operand of the expression\n        carglist_t *a;///< argument list (used for \\ref cot_call)\n        uint32 m;     ///< member offset (used for \\ref cot_memptr, \\ref cot_memref)\n                      ///< for unions, the member number\n      };\n      union\n      {\n        cexpr_t *z;   ///< the third operand of the expression\n        int ptrsize;  ///< memory access size (used for \\ref cot_ptr, \\ref cot_memptr)\n      };\n    };\n//...\n```\n\nFinally the [`cfunc_t`](https://hex-rays.com/products/decompiler/manual/sdk/structcfunc__t.shtml) structure holds information related to the decompiled function, the function address, the microcode block array, and the CTree accessed with the `entry_ea`, `mba` and `body` fields respectively.\n\n```C\nstruct cfunc_t\n{\n  ea_t entry_ea;             ///< function entry address\n  mba_t *mba;                   ///< underlying microcode\n  cinsn_t body;              ///< function body, must be a block\n//...\n```\n\n### CTree traversal example\n\nThe provided Python code serves as a mini recursive visitor of a CTree, note that it does not handle all node types, the last section will describe how to use the Hex-Rays built-in visitor class [`ctree_visitor_t`](https://hex-rays.com/products/decompiler/manual/sdk/structctree__visitor__t.shtml). To begin, we obtain the `cfunc` of the function using `ida_hexrays.decompile` and access its CTree via the `body` field.\n\nNext, we check if the node(item) is an expression or a statement. Finally, we can parse the type through the `op` field and explore its child nodes.\n\n```Python\nimport idaapi\nimport ida_hexrays\n\nOP_TYPE = sorted([(getattr(ida_hexrays, x), x) for x in filter(lambda y: y.startswith('cit_') or y.startswith('cot_'), dir(ida_hexrays))])\n\n\ndef get_op_name(op):\n    \"\"\"\n    Return the name of the given mcode_t.\n    \"\"\"\n    for value, name in OP_TYPE:\n        if op == value:\n            return name\n    return None\n\n\ndef explore_ctree(item):\n        print(f\"item address: {hex(item.ea)}, item opname: {item.opname}, item op: {get_op_name(item.op)}\")\n        if item.is_expr():\n            if item.op == ida_hexrays.cot_asg:\n                explore_ctree(item.x) # left side\n                explore_ctree(item.y) # right side\n\n            elif item.op == ida_hexrays.cot_call:\n                explore_ctree(item.x)\n                for a_item in item.a: # call parameters\n                    explore_ctree(a_item)\n\n            elif item.op == ida_hexrays.cot_memptr:\n                explore_ctree(item.x)\n        else:\n            if item.op == ida_hexrays.cit_block:\n                for i_item in item.cblock: # list of statement nodes\n                    explore_ctree(i_item)\n\n            elif item.op == ida_hexrays.cit_expr:\n                explore_ctree(item.cexpr)\n                \n            elif item.op == ida_hexrays.cit_return:\n                explore_ctree(item.creturn.expr)\n            \n\ndef main():\n    cfunc = ida_hexrays.decompile(here())\n    ctree = cfunc.body\n    explore_ctree(ctree)\n\n\nif __name__ == '__main__':\n    main()\n```\n\nDisplayed below is the output of the traversal script executed on the `start` function of a [BLISTER](https://www.elastic.co/security-labs/revisiting-blister-new-developments-of-the-blister-loader) [sample](https://www.virustotal.com/gui/file/c98137e064bc0cd32ed0415e19daf16ed451fe1289bc41e7251dd79326206d53):\n\n![CTree traversal script’s output, decompiled function, CTree graph](/assets/images/introduction-to-hexrays-decompilation-internals/image9.png)\n\n### Practical example: annotating the custom import table of a malware sample\n\nNow that we've gained insights into the architecture and structures of the generated CTree, let's delve into a practical application and explore how to automate the annotation of a custom import table of malware.\n\n![Annotation of a custom import table of a malware](/assets/images/introduction-to-hexrays-decompilation-internals/image4.png)\n\nHex-Rays provides a utility class [`ctree_visitor_t`](https://hex-rays.com/products/decompiler/manual/sdk/structctree__visitor__t.shtml) that can be used to traverse and modify the CTree, two important virtual methods to know are:\n - `visit_insn`: to visit a statement\n - `visit_expr`: to visit an expression\n\nFor this example, the same BLISTER sample is used; after locating the function that gets Windows APIs addresses by hash at address 0x7FF8CC3B0926(in the .rsrc section), adding the enumeration to the IDB and applying the enum type to its parameter, we create a class that inherits from `ctree_visitor_t`, as we are interested in expressions, we will be overriding `visit_expr` only.\n\n![CTree graph of a function at address 0x7FF8CC3B7637 generated using hrdevhelper](/assets/images/introduction-to-hexrays-decompilation-internals/image6.png)\n\nThe idea is to locate a `cot_call` node(1) of the function that resolves APIs by passing the `obj_ea` address of node’s first child to the function `idc.get_name` which will return the function name.\n\n```Python\n   if expr.op == idaapi.cot_call:\n            if idc.get_name(expr.x.obj_ea) == self.func_name:\n\t\t#...\n```\n\nNext retrieve the enum of the hash by accessing the right parameter of the call node(2), in our case parameter 3.\n\n```Python\n    carg_1 = expr.a[HASH_ENUM_INDEX]\n    api_name = ida_lines.tag_remove(carg_1.cexpr.print1(None))  # Get API name\n```\n\nThe next step is to locate the variable that has been assigned the address value of the WinAPI function. To do that we first need to locate the `cot_asg` node(3), parent of the call node by using the `find_parent_of` method under `cfunc.body` of the decompiled function.\n\n```Python\n    asg_expr = self.cfunc.body.find_parent_of(expr)  # Get node parent\n```\n\nFinally, we can access the first child node(4) under the `cot_asg` node, which is of type `cot_var` and get the current variable name, the Hex-Rays API [`ida_hexrays.rename_lvar`](https://hex-rays.com/products/decompiler/manual/sdk/hexrays_8hpp.shtml#ab719cfcfa884c57284cd946ac90b3c17) is used to rename the new variable with the Windows API name taken from the enum parameter.\n\nThis process can ultimately save a significant amount of time for an analyst. Instead of spending time on relabeling variables, they can direct their attention to the core functionality. An understanding of how CTrees work can contribute to the development of more effective plugins, enabling the handling of more complex obfuscations.\n\nFor a complete understanding and context of the example, please find the entire code below:\n\n```Python\nimport idaapi\nimport ida_hexrays\nimport idc\nimport ida_lines\nimport random\nimport string\n\nHASH_ENUM_INDEX = 2\n\n\ndef generate_random_string(length):\n    letters = string.ascii_letters\n    return \"\".join(random.choice(letters) for _ in range(length))\n\n\nclass ctree_visitor(ida_hexrays.ctree_visitor_t):\n    def __init__(self, cfunc):\n        ida_hexrays.ctree_visitor_t.__init__(self, ida_hexrays.CV_FAST)\n        self.cfunc = cfunc\n        self.func_name = \"sub_7FF8CC3B0926\"# API resolution function name\n\n    def visit_expr(self, expr):\n        if expr.op == idaapi.cot_call:\n            if idc.get_name(expr.x.obj_ea) == self.func_name:\n                carg_1 = expr.a[HASH_ENUM_INDEX]\n                api_name = ida_lines.tag_remove(\n                    carg_1.cexpr.print1(None)\n                )  # Get API name\n                expr_parent = self.cfunc.body.find_parent_of(expr)  # Get node parent\n\n                # find asg node\n                while expr_parent.op != idaapi.cot_asg:\n                    expr_parent = self.cfunc.body.find_parent_of(expr_parent)\n\n                if expr_parent.cexpr.x.op == idaapi.cot_var:\n                    lvariable_old_name = (\n                        expr_parent.cexpr.x.v.getv().name\n                    )  # get name of variable\n                    ida_hexrays.rename_lvar(\n                        self.cfunc.entry_ea, lvariable_old_name, api_name\n                    ) # rename variable\n        return 0\n\n\ndef main():\n    cfunc = idaapi.decompile(idc.here())\n    v = ctree_visitor(cfunc)\n    v.apply_to(cfunc.body, None)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Conclusion\n\nConcluding our exploration into Hex-Rays microcode and CTree generation, we've gained practical techniques for navigating the complexities of malware obfuscation. The ability to modify Hex-Rays pseudo code allows us to cut through obfuscation like Control Flow Obfuscation, remove dead code, and many more. The Hex-Rays C++ SDK emerges as a valuable resource, offering well-documented guidance for future reference. \n\nWe hope that this guide will be helpful to fellow researchers and any avid learner, please find all the scripts in our [research repository](https://github.com/elastic/labs-releases/tree/main/tools/ida_scripts).\n\n## Resources\n\n - [Ilfak Guilfanov's Decompiler Internals: Microcode presentation](https://i.blackhat.com/us-18/Thu-August-9/us-18-Guilfanov-Decompiler-Internals-Microcode-wp.pdf)\n - [Hex-Rays decompiler primer](https://hex-rays.com/blog/hex-rays-decompiler-primer)\n - [HRDevHelper](https://github.com/patois/HRDevHelper/)\n - [lucid utility](https://github.com/gaasedelen/lucid)\n - [Hex-Rays SDK](https://hex-rays.com/products/decompiler/manual/sdk/)\n - [Elastic Security Labs enablement tools](https://github.com/elastic/labs-releases)\n"
    },
    "title": "Introduction to Hex-Rays decompilation internals",
    "slug": "introduction-to-hexrays-decompilation-internals",
    "date": "2024-02-14",
    "description": "In this publication, we delve into Hex-Rays microcode and explore techniques for manipulating the generated CTree to deobfuscate and annotate decompiled code.",
    "author": [
      {
        "slug": "salim-bitam"
      }
    ],
    "image": "photo-edited-05.png",
    "category": [
      {
        "slug": "malware-analysis"
      }
    ],
    "tags": [
      "malware-analysis"
    ]
  },
  "id": "security_labs_content-introduction_to_hexrays_decompilation_internals-md",
  "type": "security_labs_content"
}
