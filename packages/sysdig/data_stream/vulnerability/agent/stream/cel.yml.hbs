config_version: 2
interval: {{interval}}
resource.tracer:
  enabled: {{enable_request_tracer}}
  filename: "../../logs/cel/http-request-trace-*.ndjson"
  maxbackups: 5
{{#if proxy_url}}
resource.proxy_url: {{proxy_url}}
{{/if}}
{{#if ssl}}
resource.ssl: {{ssl}}
{{/if}}
{{#if http_client_timeout}}
resource.timeout: {{http_client_timeout}}
{{/if}}
{{#if max_executions}}
max_executions: {{max_executions}}
{{/if}}
resource.url: {{url}}
state:
  batch_size: {{batch_size}}
  api_token: {{api_token}}
  stage: {{stage}}
  keep_policy_evaluation_details: {{keep_policy_evaluation_details}}
redact:
  fields:
    - api_token
program: |
  (
    (state.?worklist.data[0].hasValue()) ?
      state.worklist
    :
      request("GET",
        state.url.trim_right("/") + "/secure/vulnerability/v1/" + state.stage + "-results?" + {
          "limit": [string(state.batch_size)],
          ?"cursor": state.?next.page.optMap(v, [v]),
        }.format_query()
      ).with({
        "Header":{
          "Authorization": ["Bearer " + state.api_token],
        },
      }).do_request().as(resp, resp.StatusCode == 200 ?
        bytes(resp.Body).decode_json()
      :
        {
          "events": {
            "error": {
              "code": string(resp.StatusCode),
              "id": string(resp.Status),
              "message": "GET " + state.url.trim_right("/") + "/secure/vulnerability/v1/" + state.stage + "-results?" + (
                size(resp.Body) != 0 ?
                  string(resp.Body)
                :
                  string(resp.Status) + ' (' + string(resp.StatusCode) + ')'
              ),
            },
          },
          "batch_size": state.batch_size,
          "api_token": state.api_token,
          "stage": state.stage,
          "keep_policy_evaluation_details": state.keep_policy_evaluation_details,
          "want_more": false,
        }
      )
  ).as(worklist,
    has(worklist.events) ? state : // Exit early due to GET failure.
      (worklist.?data[0].hasValue()) ?
        request("GET",
          state.url.trim_right("/") + "/secure/vulnerability/v1/results/" + worklist.data[0].resultId
        ).with({
          "Header":{
            "Authorization": ["Bearer " + state.api_token],
          },
        }).do_request().as(resp, resp.StatusCode == 200 ?
          bytes(resp.Body).decode_json().as(body, {

            // Scan results are broken down into separate events for each package-vulnerability pair.
            // If no vulnerability is found for a package, then only the package details will be included in the published event.
            // If the scans contain no package information, then only the scan details will be included in the published event.
            //
            // In detail, a package is included in one layer, which can be built upon several base images.
            // Furthermore, a package can have multiple vulnerabilities, each of which can have multiple risk accepts.

            "events": (
              state.keep_policy_evaluation_details ?
                // Eliminate the low-level information large object. Removing `failures[]` from `policies.evaluations[].bundles[].rules[]`.
                body.drop("policies.evaluations.bundles.rules.failures")
              :
                body.drop("policies")
            ).as(body,
              {
                // resolve baseImagesRef in layers
                "updated_layers": has(body.layers) ?
                  body.layers.map(layer_id, {
                    "key": layer_id,
                    "value": body.layers[layer_id].with({
                      "baseImages": body.layers[layer_id].baseImagesRef.map(image_id,
                        body.baseImages[image_id].with({"baseImagesRef": image_id})
                      )
                    }).drop("baseImagesRef")
                  }).as(result, zip(
                    result.map(e, e.key),
                    result.map(e, e.value)
                  ))
                :
                  {},
                // resolve riskAcceptRefs in vulnerabilities
                "updated_vulnerabilities": body.vulnerabilities.map(vulnerability_id, {
                  "key": vulnerability_id,
                  "value": body.vulnerabilities[vulnerability_id].with({
                    "riskAccepts": body.vulnerabilities[vulnerability_id].riskAcceptRefs != null ?
                      body.vulnerabilities[vulnerability_id].riskAcceptRefs.map(risk_id,
                        body.riskAccepts[risk_id].with({"riskAcceptRefs": risk_id})
                      )
                    :
                      []
                  }).drop("riskAcceptRefs")
                }).as(result, zip(
                  result.map(e, e.key),
                  result.map(e, e.value)
                ))
              }.as(result, {
                // resolve vulnerabilitiesRefs and layerRef in package
                "updated_packages": body.packages.map(package_id, {
                  "key": package_id,
                  "value": body.packages[package_id].with({
                    ?"layers":  has(body.packages[package_id].layerRef) ?
                      optional.of(result.updated_layers[body.packages[package_id].layerRef].with({"layerRef":
                        body.packages[package_id].layerRef}))
                    :
                      optional.none(),
                    "vulnerability": body.packages[package_id].vulnerabilitiesRefs != null ?
                      body.packages[package_id].vulnerabilitiesRefs.map(vulnerability_id,
                        result.updated_vulnerabilities[vulnerability_id].with({"vulnerabilitiesRef": vulnerability_id})
                      )
                    :
                      [{}],
                    "packageRef": package_id
                  }).drop(["layerRef", "vulnerabilitiesRefs"])
                }).as(result, zip(
                  result.map(e, e.key),
                  result.map(e, e.value)
                ))
              }).as(result,
                // Create final object
                result.updated_packages.map(package_id,
                  result.updated_packages[package_id].vulnerability.map(vuln_data, {
                    "message": {
                      "package" :
                        vuln_data != {} ?
                          result.updated_packages[package_id].with({"vulnerability": vuln_data})
                        :
                          result.updated_packages[package_id].with({"vulnerability": null}),
                      "assetType": body.assetType,
                      "metadata": body.metadata,
                      "producer": body.producer,
                      ?"policies": body.?policies,
                      "stage": body.stage
                    }.with(worklist.data[0]).encode_json()
                  })
                )
              ).flatten().as(result,
                // handle the case when there is no package present
                size(result) == 0 ?
                  [{
                    "message": {
                      "assetType": body.assetType,
                      "metadata": body.metadata,
                      "producer": body.producer,
                      ?"policies": body.?policies,
                      "stage": body.stage
                    }.with(worklist.data[0]).encode_json()
                  }]
                :
                  dyn(result)
              )
            ),
            "batch_size": state.batch_size,
            "api_token": state.api_token,
            "stage": state.stage,
            "keep_policy_evaluation_details": state.keep_policy_evaluation_details,
            ?"worklist": (tail(worklist.data)[?0].hasValue()) ? optional.of(worklist.with({ "data": tail(worklist.data) })) : optional.none(),
            "want_more": (tail(worklist.data)[?0].hasValue()) || has(worklist.page.next),
            "next": {
              ?"page": worklist.?page.next
            }
          })
        :
          {
            "events": {
              "error": {
                "code": string(resp.StatusCode),
                "id": string(resp.Status),
                "message": "GET " + state.url.trim_right("/") + "/secure/vulnerability/v1/results/" + worklist.data[0].resultId + (
                  size(resp.Body) != 0 ?
                    string(resp.Body)
                  :
                    string(resp.Status) + ' (' + string(resp.StatusCode) + ')'
                ),
              },
            },
            "batch_size": state.batch_size,
            "api_token": state.api_token,
            "stage": state.stage,
            "keep_policy_evaluation_details": state.keep_policy_evaluation_details,
            "want_more": false,
            "next": {}
          }
        )
      :
        {
          "events": [],
          "batch_size": state.batch_size,
          "api_token": state.api_token,
          "stage": state.stage,
          "keep_policy_evaluation_details": state.keep_policy_evaluation_details,
          "want_more": false,
          "next": {}
        }
  )
tags:
{{#if preserve_original_event}}
  - preserve_original_event
{{/if}}
{{#if preserve_duplicate_custom_fields}}
  - preserve_duplicate_custom_fields
{{/if}}
{{#each tags as |tag|}}
  - {{tag}}
{{/each}}
{{#contains "forwarded" tags}}
publisher_pipeline.disable_host: true
{{/contains}}
{{#if processors}}
processors:
{{processors}}
{{/if}}
