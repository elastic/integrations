---
description: "Pipeline for ELB logs"

processors:
  - set:
      field: ecs.version
      value: '8.4.0'
  - rename:
      field: message
      target_field: event.original
      ignore_missing: true
      if: 'ctx.event?.original == null'
      description: 'Renames the original `message` field to `event.original` to store a copy of the original message. The `event.original` field is not touched if the document already has one; it may happen when Logstash sends the document.'
  - remove:
      field: message
      ignore_missing: true
      if: 'ctx.event?.original != null'
      description: 'The `message` field is no longer required if the document has an `event.original` field.'
  - json:
      field: event.original
      target_field: json
  - set:
      field: event.kind
      value: event
  - set:
      field: event.category
      value: web
  - set:
      field: cloud.provider
      value: aws
  - set:
      field: cloud.service.name
      value: apigateway
  - rename:
      field: json.accountId
      target_field: cloud.account.id
      ignore_missing: true
  - date:
      field: json.requestTimeEpoch
      formats:
        - UNIX_MS
      if: 'ctx.json?.requestTimeEpoch != null && (ctx.json?.requestTimeEpoch).length() > 11'
  - date:
      field: json.requestTimeEpoch
      formats:
        - UNIX
      if: 'ctx.json?.requestTimeEpoch != null && (ctx.json?.requestTimeEpoch).length() <= 11'
  - grok:
      field: json.domainName
      ignore_missing: true
      ignore_failure: true
      patterns:
        - ^%{DATA}\.execute-api\.%{DATA:cloud.region}\.%{DATA}$  
  - set:
      field: url.full
      value: "https://{{{json.domainName}}}{{{json.path}}}"
      ignore_failure: true
  - uri_parts:
      field: url.full
      ignore_failure: true
      if: 'ctx?.url?.full != null'
  - set:
      field: destination.domain
      copy_from: url.domain
      ignore_empty_value: true
  - user_agent:
      field: json.userAgent
      ignore_missing: true 
  - convert:
      field: json.status
      target_field: http.response.status_code
      type: long
      ignore_missing: true
  - set:
      field: event.outcome
      value: success
      if: 'ctx?.http?.response?.status_code != null && ctx.http.response.status_code < 400'
  - set:
      field: event.outcome
      value: failure
      if: 'ctx?.http?.response?.status_code != null && ctx.http.response.status_code >= 400'
  - rename:
      field: json.extendedRequestId
      target_field: http.request.id
      ignore_missing: true   
  - rename:
      field: json.httpMethod
      target_field: http.request.method
      ignore_missing: true  
  - convert:
      field: json.responseLength
      target_field: http.response.body.bytes
      type: long
      ignore_missing: true
  - dissect:
      field: json.protocol
      pattern: "%{}/%{http.version}"
      ignore_failure: true
  - grok:
      field: json.userArn
      ignore_missing: true
      ignore_failure: true
      patterns:
        - ^arn:%{DATA}:iam::%{NUMBER}:(user/)?%{DATA:user.name}$
  - rename:
      field: json.userArn
      target_field: user.id
      ignore_missing: true
  - rename:
      field: json.user
      target_field: aws.api_gateway.principal_id
      ignore_missing: true
  - rename:
      field: json.clientCertPem
      target_field: tls.client.certificate
      ignore_missing: true
  - rename:
      field: json.clientsubjectDN
      target_field: tls.client.x509.subject.distinguished_name
      ignore_missing: true
  - rename:
      field: json.clientissuerDN
      target_field: tls.client.x509.issuer.distinguished_name
      ignore_missing: true
  - rename:
      field: json.clientserialNumber
      target_field: tls.client.x509.serial_number
      ignore_missing: true
  - date:
      field: json.clientnotBefore
      target_field: tls.client.x509.not_before
      formats:
        - ISO8601
      if: ctx.json?.clientnotBefore != null && ctx.json?.clientnotBefore != '-'
  - date:
      field: json.clientnotAfter
      target_field: tls.client.x509.not_after
      formats:
        - ISO8601
      if: ctx.json?.clientnotAfter != null && ctx.json?.clientnotAfter != '-'
  - rename:
      field: json.user
      target_field: aws.api_gateway.principal_id
      ignore_missing: true
  - rename:
      field: json.apiId
      target_field: aws.api_gateway.api_id
      ignore_missing: true
  - rename:
      field: json.stage
      target_field: aws.api_gateway.stage
      ignore_missing: true
  - rename:
      field: json.ip
      target_field: source.address
      ignore_missing: true
  - convert:
      field: source.address
      target_field: source.ip
      type: ip
      ignore_failure: true
  - geoip:
      field: source.ip
      target_field: source.geo
      ignore_missing: true
  - geoip:
      database_file: GeoLite2-ASN.mmdb
      field: source.ip
      target_field: source.as
      properties:
        - asn
        - organization_name
      ignore_missing: true
  - rename:
      field: source.as.asn
      target_field: source.as.number
      ignore_missing: true
  - rename:
      field: source.as.organization_name
      target_field: source.as.organization.name
      ignore_missing: true
  - remove:
      field:
        - json
      ignore_missing: true
  - script:
      lang: painless
      description: This script processor iterates over the whole document to remove fields with null values.
      source: |
        void handleMap(Map map) {
          for (def x : map.values()) {
            if (x instanceof Map) {
                handleMap(x);
            } else if (x instanceof List) {
                handleList(x);
            }
          }
          map.values().removeIf(v -> v == null || v == '' || v == '-' || (v instanceof Map && v.size() == 0) || (v instanceof List && v.size() == 0));
        }
        void handleList(List list) {
          for (def x : list) {
              if (x instanceof Map) {
                  handleMap(x);
              } else if (x instanceof List) {
                  handleList(x);
              }
          }
          list.removeIf(v -> v == null || v == '' || v == '-' || (v instanceof Map && v.size() == 0) || (v instanceof List && v.size() == 0));
        }
        handleMap(ctx);
  - remove:
      field: event.original
      if: "ctx?.tags == null || !(ctx.tags.contains('preserve_original_event'))"
      ignore_failure: true
      ignore_missing: true
on_failure:
  - set:
      field: 'error.message'
      value: '{{ _ingest.on_failure_message }}'
