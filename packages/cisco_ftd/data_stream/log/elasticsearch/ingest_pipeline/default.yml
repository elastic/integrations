---
description: "Pipeline for Cisco FTD logs"
processors:
  - rename:
      tag: rename_message_to_event_original_56a77271
      field: message
      target_field: event.original
      ignore_missing: true
      if: ctx.event?.original == null
  - set:
      tag: set_ecs_version_f5923549
      field: ecs.version
      value: '8.17.0'
  #
  # Parse the syslog header
  #
  # This populates the host.hostname, process.name, timestamp and other fields
  # from the header and stores the message contents in _temp_.full_message.
  - grok:
      tag: grok_event_original_4a3f54eb
      field: event.original
      patterns:
        - "(?:%{SYSLOG_HEADER})?\\s*%{GREEDYDATA:_temp_.full_message}"
      pattern_definitions:
        SYSLOG_HEADER: "(?:%{SYSPRIORITY}\\s*)?(?:%{FTD_DATE:_temp_.raw_date}:?\\s+)?(?:%{PROCESS_HOST}|%{HOST_PROCESS})(?:{DATA})?%{SYSLOG_END}?"
        SYSPRIORITY: "<%{NONNEGINT:log.syslog.priority:int}>"
        # Beginning with version 6.3, Firepower Threat Defense provides the option to enable timestamp as per RFC 5424.
        FTD_DATE: "(?:%{TIMESTAMP_ISO8601}|%{ASA_DATE})"
        ASA_DATE: "(?:%{DAY} )?%{MONTH}  *%{MONTHDAY}(?: %{YEAR})? %{TIME}(?: %{TZ:_temp_.tz})?"
        TZ: "(?:[APMCE][SD]T|UTC)"
        TIMESTAMP_ISO8601: "%{YEAR}-%{MONTHNUM}-%{MONTHDAY}[T ]%{HOUR}:?%{MINUTE}(?::?%{SECOND})?%{ISO8601_TIMEZONE:_temp_.tz}?"
        ISO8601_TIMEZONE: "(?:Z|[+-]%{HOUR}(?::?%{MINUTE}))"
        PROCESS: "(?:[^%\\s:\\[]+)"
        SYSLOG_END: "(?:(:|\\s)\\s+)"
        # exactly match the syntax for firepower management logs
        PROCESS_HOST: "(?:%{PROCESS:process.name}:\\s%{SYSLOGHOST:host.name})"
        HOST_PROCESS: "(?:%{SYSLOGHOST:host.hostname}:?\\s+)?(?:%{PROCESS:process.name}?(?:\\[%{POSINT:process.pid:long}\\])?)?"
  - script:
      tag: script_4a9d0c10
      lang: painless
      source: |
        if (ctx.log?.syslog?.priority != null) {
          def severity = new HashMap();
          severity['code'] = ctx.log.syslog.priority&0x7;
          ctx.log.syslog['severity'] = severity;
          def facility = new HashMap();
          facility['code'] = ctx.log.syslog.priority>>3;
          ctx.log.syslog['facility'] = facility;
        }

  #
  # Parse FTD/ASA style message
  #
  # This parses the header of an EMBLEM-style message for FTD and ASA prefixes.
  - grok:
      tag: grok__temp__full_message_a8459d95
      field: _temp_.full_message
      patterns:
        - "%{FTD_PREFIX}-(?:%{FTD_SUFFIX:_temp_.cisco.suffix}?-)?%{NONNEGINT:event.severity:int}-%{POSINT:_temp_.cisco.message_id}?:?\\s*%{GREEDYDATA:message}"
        # Before version 6.3, messages for connection, security intelligence, and intrusion events didn't include an event type ID in the message header.
        - "%{GREEDYDATA:message}"
      pattern_definitions:
        FTD_SUFFIX: "[^0-9-]+"
        # Before version 6.3, FTD used ASA prefix in syslog messages
        FTD_PREFIX: "%{DATA}%(?:[A-Z]+)"

  #
  # Create missing fields when no %FTD label is present
  #
  # message_id is needed in order for some processors below to work.
  - set:
      tag: set__temp__cisco_message_id_b6b42d05
      field: _temp_.cisco.message_id
      value: ""
      if: "ctx._temp_?.cisco?.message_id == null"

  #
  # set default event.severity to 7 (debug):
  #
  # This value is read from the EMBLEM header and won't be present if this is not
  # an emblem message (firewalls can be configured to report other kinds of events)
  - set:
      tag: set_event_severity_d06c3fd7
      field: event.severity
      value: 7
      if: "ctx.event?.severity == null"

  # Time zone can come from three sources, choose in order: log, config, locale, default to UTC.
  - set:
      tag: set__temp__tz_aad5b1e3
      field: _temp_.tz
      value: UTC
      if: ctx._temp_?.tz == 'Z'
  - set:
      tag: set__temp__tz_f9f73f5a
      field: _temp_.tz
      copy_from: _conf.tz_offset
      override: false
      if: ctx._conf?.tz_offset != null && ctx._conf?.tz_offset != 'local'
  - set:
      tag: set__temp__tz_c02c1420
      field: _temp_.tz
      copy_from: event.timezone
      override: false
      if: ctx.event?.timezone != null
  - set:
      tag: set__temp__tz_11a55a67
      field: _temp_.tz
      value: UTC
      override: false
  - set:
      tag: set_event_timezone_035b9b5e
      field: event.timezone
      copy_from: _temp_.tz
  #
  # Parse the date included in FTD logs
  #
  - date:
      tag: date__temp__raw_date_a2ad7d0e
      if: ctx._temp_?.raw_date != null
      timezone: "{{{ event.timezone }}}"
      field: "_temp_.raw_date"
      formats:
        - "ISO8601"
        - "MMM  d HH:mm:ss"
        - "MMM dd HH:mm:ss"
        - "EEE MMM  d HH:mm:ss"
        - "EEE MMM dd HH:mm:ss"
        - "MMM  d HH:mm:ss z"
        - "MMM dd HH:mm:ss z"
        - "EEE MMM  d HH:mm:ss z"
        - "EEE MMM dd HH:mm:ss z"
        - "MMM  d yyyy HH:mm:ss"
        - "MMM dd yyyy HH:mm:ss"
        - "EEE MMM  d yyyy HH:mm:ss"
        - "EEE MMM dd yyyy HH:mm:ss"
        - "MMM  d yyyy HH:mm:ss z"
        - "MMM dd yyyy HH:mm:ss z"
        - "EEE MMM  d yyyy HH:mm:ss z"
        - "EEE MMM dd yyyy HH:mm:ss z"
      on_failure:
        # Try to re-parse as UTC to catch when TZ is invalid or unknown.
        - remove:
            tag: remove_event_timezone_2dc4f03e
            field: event.timezone
            ignore_missing: true
        - date:
            tag: date__temp__raw_date_4577a3bd
            if: ctx._temp_?.raw_date != null
            field: "_temp_.raw_date"
            formats:
              - "ISO8601"
              - "MMM  d HH:mm:ss"
              - "MMM dd HH:mm:ss"
              - "EEE MMM  d HH:mm:ss"
              - "EEE MMM dd HH:mm:ss"
              - "MMM  d HH:mm:ss z"
              - "MMM dd HH:mm:ss z"
              - "EEE MMM  d HH:mm:ss z"
              - "EEE MMM dd HH:mm:ss z"
              - "MMM  d yyyy HH:mm:ss"
              - "MMM dd yyyy HH:mm:ss"
              - "EEE MMM  d yyyy HH:mm:ss"
              - "EEE MMM dd yyyy HH:mm:ss"
              - "MMM  d yyyy HH:mm:ss z"
              - "MMM dd yyyy HH:mm:ss z"
              - "EEE MMM  d yyyy HH:mm:ss z"
              - "EEE MMM dd yyyy HH:mm:ss z"
            on_failure:
              - append:
                  tag: append_error_message_18c59fb1
                  field: error.message
                  value: "{{{ _ingest.on_failure_message }}}"

  #
  # Set log.level
  #
  - set:
      tag: set_log_level_c724d929
      field: "log.level"
      if: "ctx.event.severity == 0"
      value: unknown
  - set:
      tag: set_log_level_e663c8d8
      field: "log.level"
      if: "ctx.event.severity == 1"
      value: alert
  - set:
      tag: set_log_level_0f36429c
      field: "log.level"
      if: "ctx.event.severity == 2"
      value: critical
  - set:
      tag: set_log_level_201bba1e
      field: "log.level"
      if: "ctx.event.severity == 3"
      value: error
  - set:
      tag: set_log_level_4f08a3cf
      field: "log.level"
      if: "ctx.event.severity == 4"
      value: warning
  - set:
      tag: set_log_level_1f2f675b
      field: "log.level"
      if: "ctx.event.severity == 5"
      value: notification
  - set:
      tag: set_log_level_f5ee75b0
      field: "log.level"
      if: "ctx.event.severity == 6"
      value: informational
  - set:
      tag: set_log_level_da9bfdc1
      field: "log.level"
      if: "ctx.event.severity == 7"
      value: debug

  #
  # Firewall messages
  #
  # This set of messages is shared between FTD and ASA.
  - set:
      tag: set_event_action_11ddfe29
      if: 'ctx._temp_.cisco.message_id != ""'
      field: "event.action"
      value: "firewall-rule"
  - script:
      tag: "script_preserve_message"
      if: 'ctx._temp_.cisco.message_id != ""'
      lang: painless
      source: |-
        def messageID = Long.parseLong(ctx._temp_.cisco.message_id);
        if (messageID >= 101001 && messageID <= 105052) {
         ctx.event["reason"] = ctx.message;
        }
  - dissect:
      tag: dissect_message_63e3e8b9
      if: "ctx._temp_.cisco.message_id == '106001'"
      field: "message"
      description: "106001"
      pattern: "%{} %{network.transport} connection %{event.outcome} from %{source.address}/%{source.port} to %{destination.address}/%{destination.port} flags %{} on interface %{_temp_.cisco.source_interface}"
  - dissect:
      tag: dissect_message_196de5f3
      if: "ctx._temp_.cisco.message_id == '106002'"
      field: "message"
      description: "106002"
      pattern: "%{network.transport} Connection %{event.outcome} by %{} list %{_temp_.cisco.list_id} src %{source.address} dest %{destination.address}"
  - dissect:
      tag: dissect_message_288491c9
      if: "ctx._temp_.cisco.message_id == '106006'"
      field: "message"
      description: "106006"
      pattern: "%{event.outcome} %{} %{network.transport} from %{source.address}/%{source.port} to %{destination.address}/%{destination.port} on interface %{_temp_.cisco.source_interface}"
  - dissect:
      tag: dissect_message_f4364b93
      if: "ctx._temp_.cisco.message_id == '106007'"
      field: "message"
      description: "106007"
      pattern: "%{event.outcome} %{} %{network.transport} from %{source.address}/%{source.port} to %{destination.address}/%{destination.port} due to %{network.protocol} %{}"
  - grok:
      tag: grok_message_4d916db9
      if: "ctx._temp_.cisco.message_id == '106010'"
      field: "message"
      description: "106010"
      patterns:
        - "%{NOTSPACE:event.outcome} %{NOTSPACE} %{NOTSPACE:network.transport} src %{NOTSPACE:_temp_.cisco.source_interface}:%{NOTSPACE:source.address}/%{POSINT:source.port} (%{DATA})?dst %{NOTSPACE:_temp_.cisco.destination_interface}:%{NOTSPACE:destination.address}/%{POSINT:destination.port}(%{GREEDYDATA})?"
  - dissect:
      tag: dissect_message_6a3adcc1
      if: "ctx._temp_.cisco.message_id == '106013'"
      field: "message"
      description: "106013"
      pattern: "Dropping echo request from %{source.address} to PAT address %{destination.address}"
  - set:
      tag: set_network_transport_2b0f59d0
      if: "ctx._temp_.cisco.message_id == '106013'"
      field: "network.transport"
      description: "106013"
      value: icmp
  - set:
      tag: set_network_direction_434b13fa
      if: "ctx._temp_.cisco.message_id == '106013'"
      field: "network.direction"
      description: "106013"
      value: inbound
  - grok:
      tag: grok_message_709b7fea
      if: "ctx._temp_.cisco.message_id == '106014'"
      field: "message"
      description: "106014"
      patterns:
        - "%{NOTSPACE:event.outcome} %{NOTSPACE} %{NOTSPACE:network.transport} src %{NOTSPACE:_temp_.cisco.source_interface}:%{NOTSPACE:source.address} (%{DATA})?dst %{NOTSPACE:_temp_.cisco.destination_interface}:(?<destination.address>[^ (]*)(%{GREEDYDATA})?"
  - grok:
      tag: grok_message_2bec282f
      if: "ctx._temp_.cisco.message_id == '106015'"
      field: "message"
      description: "106015"
      patterns:
        - "%{NOTSPACE:event.outcome} %{NOTSPACE:network.transport} %{NOTSPACE} %{NOTSPACE} from %{IP:source.address}/%{POSINT:source.port} to %{IPORHOST:destination.address}/%{POSINT:destination.port} flags %{DATA} on interface %{NOTSPACE:_temp_.cisco.source_interface}"
  - dissect:
      tag: dissect_message_9c5c1a8e
      if: "ctx._temp_.cisco.message_id == '106016'"
      field: "message"
      pattern: "%{event.outcome} IP spoof from (%{source.address}) to %{destination.address} on interface %{_temp_.cisco.source_interface}"
      description: "106016"
  - dissect:
      tag: dissect_message_c25ee54b
      if: "ctx._temp_.cisco.message_id == '106017'"
      field: "message"
      pattern: "%{event.outcome} IP due to Land Attack from %{source.address} to %{destination.address}"
      description: "106017"
  - dissect:
      tag: dissect_message_275189bd
      if: "ctx._temp_.cisco.message_id == '106018'"
      field: "message"
      pattern: "%{network.transport} packet type %{_temp_.cisco.icmp_type} %{event.outcome} by %{} list %{_temp_.cisco.list_id} src %{source.address} dest %{destination.address}"
      description: "106018"
  - dissect:
      tag: dissect_message_ef1d1927
      if: "ctx._temp_.cisco.message_id == '106020'"
      field: "message"
      pattern: "%{event.outcome} IP teardrop fragment (size = %{}, offset = %{}) from %{source.address} to %{destination.address}"
      description: "106020"
  - dissect:
      tag: dissect_message_85ce0632
      if: "ctx._temp_.cisco.message_id == '106021'"
      field: "message"
      pattern: "%{event.outcome} %{network.transport} reverse path check from %{source.address} to %{destination.address} on interface %{_temp_.cisco.source_interface}"
      description: "106021"
  - dissect:
      tag: dissect_message_900f0b52
      if: "ctx._temp_.cisco.message_id == '106022'"
      field: "message"
      pattern: "%{event.outcome} %{network.transport} connection spoof from %{source.address} to %{destination.address} on interface %{_temp_.cisco.source_interface}"
      description: "106022"
  - grok:
      tag: grok_message_f79236ca
      if: "ctx._temp_.cisco.message_id == '106023'"
      field: "message"
      description: "106023"
      patterns:
        - ^%{NOTSPACE:event.outcome} ((protocol %{POSINT:network.iana_number})|%{NOTSPACE:network.transport}) src %{NOTCOLON:_temp_.cisco.source_interface}:%{IPORHOST:source.address}(/%{POSINT:source.port})?\s*(\(%{CISCO_USER:_temp_.cisco.source_username}\) )?dst %{NOTCOLON:_temp_.cisco.destination_interface}:%{IPORHOST:destination.address}(/%{POSINT:destination.port})?%{DATA}by access-group "%{NOTSPACE:_temp_.cisco.list_id}"
      pattern_definitions:
        HOSTNAME: "\\b(?:[0-9A-Za-z][0-9A-Za-z_-]{0,62})(?:\\.(?:[0-9A-Za-z][0-9A-Za-z_-]{0,62}))*(\\.?|\\b)"
        IPORHOST: "(?:%{IP}|%{HOSTNAME})"
        NOTCOLON: "[^:]*"
        CISCO_USER: ((LOCAL\\)?(%{HOSTNAME}\\)?%{USERNAME}(@%{HOSTNAME})?(, *%{NUMBER})?)
  - dissect:
      tag: dissect_message_7bde9ea6
      if: "ctx._temp_.cisco.message_id == '106027'"
      field: "message"
      description: "106027"
      pattern: '%{} %{event.outcome} src %{source.address} dst %{destination.address} by access-group "%{_temp_.cisco.list_id}"'
  - dissect:
      tag: dissect_message_9f66c8c2
      if: "ctx._temp_.cisco.message_id == '106100'"
      field: "message"
      description: "106100"
      pattern: "access-list %{_temp_.cisco.list_id} %{event.outcome} %{network.transport} %{_temp_.cisco.source_interface}/%{source.address}(%{source.port})%{}-> %{_temp_.cisco.destination_interface}/%{destination.address}(%{destination.port})%{}"
  - dissect:
      tag: dissect_message_d115e824
      if: "ctx._temp_.cisco.message_id == '106102' || ctx._temp_.cisco.message_id == '106103'"
      field: "message"
      description: "106102, 106103"
      pattern: "access-list %{_temp_.cisco.list_id} %{event.outcome} %{network.transport} for user %{user.name} %{_temp_.cisco.source_interface}/%{source.address}(%{source.port})%{}-> %{_temp_.cisco.destination_interface}/%{destination.address}(%{destination.port})%{}"
  - grok:
      tag: grok_message_020b3d94
      if: "['109201', '109202', '109204', '109207', '109210'].contains(ctx._temp_.cisco.message_id)"
      field: "message"
      description: "109201, 109202, 109204, 109207, 109210"
      patterns:
        - "UAUTH: Session(=| )%{DATA}, User(=| )%{NOTCOMMA:user.name}, Assigned IP(=| )%{IP:source.address}, Succe%{GREEDYDATA}"
      pattern_definitions:
        NOTCOMMA: "[^,]+"
  - dissect:
      tag: dissect_message_352ad1bf
      if: "ctx._temp_.cisco.message_id == '111004'"
      field: "message"
      description: "111004"
      pattern: "%{source.address} end configuration: %{_temp_.cisco.cli_outcome}"
  - set:
      tag: set_event_outcome_56243ee0
      field: event.outcome
      description: "111004"
      value: "success"
      if: "ctx._temp_.cisco.message_id == '111004' && ctx._temp_.cisco.cli_outcome == 'OK'"
  - set:
      tag: set_event_outcome_968833ec
      field: event.outcome
      description: "111004"
      value: "failure"
      if: "ctx._temp_.cisco.message_id == '111004' && ctx._temp_.cisco.cli_outcome == 'FAILED'"
  - remove:
      tag: remove__temp__cisco_cli_outcome_a4760a74
      field: _temp_.cisco.cli_outcome
      ignore_missing: true
  - append:
      tag: append_event_type_7d5f7cb6
      field: event.type
      description: "111004"
      value: "change"
      if: "ctx._temp_.cisco.message_id == '111004'"
  # Note: This one does not in any way adhere to the documentation on cisco's site for these message ids
  - grok:
      tag: grok_message_e6caac62
      if: '["111008", "111009"].contains(ctx._temp_.cisco.message_id)'
      description: "111008, 111009"
      field: "message"
      patterns:
        - "^%{NOTSPACE} '%{NOTSPACE:server.user.name}' executed %{NOTSPACE} %{GREEDYDATA:_temp_.cisco.command_line_arguments}"
        - "^%{NOTSPACE} '%{NOTSPACE:server.user.name}' executed the '%{DATA}' command"
  - grok:
      tag: grok_message_5ccd264e
      if: "ctx._temp_.cisco.message_id == '111010'"
      field: "message"
      description: "111010"
      patterns:
        - "User '%{NOTSPACE:server.user.name}', running %{QUOTEDSTRING} from IP %{IP:source.address}, executed %{QUOTEDSTRING:_temp_.cisco.command_line_arguments}"
  - grok:
      tag: grok_message_6379a243
      if: "ctx._temp_.cisco.message_id == '113004'"
      field: "message"
      description: "113004"
      patterns:
      - "AAA user %{DATA:_temp_.cisco.aaa_type} Successful(%{SPACE})?: server =(%{SPACE})?%{IP:destination.address} [:,] [Uu]ser = %{CISCO_USER:source.user.name}"
      pattern_definitions:
        CISCO_USER: ((LOCAL\\)?(%{HOSTNAME}\\)?%{USERNAME}(@%{HOSTNAME})?(, *%{NUMBER})?)
  - grok:
      tag: grok_message_800e7540
      if: "ctx._temp_.cisco.message_id == '113005'"
      description: "113005"
      field: "message"
      patterns:
        - "AAA user authentication Rejected(%{SPACE})?: reason = %{REASON}(%{SPACE})?: server = %{IP:destination.address}(%{SPACE})?: user = ?(%{CISCO_USER:source.user.name}|\\*+)(%{SPACE})?: user IP = %{IP:source.address}"
      pattern_definitions:
        REASON: (AAA failure|Account has been disabled)
        CISCO_USER: ((LOCAL\\)?(%{HOSTNAME}\\)?%{USERNAME}(@%{HOSTNAME})?(, *%{NUMBER})?)
  - grok:
      tag: grok_message_9e29df82
      if: "ctx._temp_.cisco.message_id == '113008'"
      description: "113008"
      field: "message"
      patterns:
        - "AAA transaction status ACCEPT(%{SPACE})?: user = ?(%{CISCO_USER:source.user.name}|\\*+)(%{SPACE})?"
      pattern_definitions:
        CISCO_USER: ((LOCAL\\+)?(%{HOSTNAME}\\+)?%{USERNAME}(@%{HOSTNAME})?(, *%{NUMBER})?)
  - grok:
      tag: grok_message_b789aebe
      if: "ctx._temp_.cisco.message_id == '113009'"
      description: "113009"
      field: "message"
      patterns:
        - "AAA retrieved default group policy \\(%{DATA:source.user.group.name}\\) for user = ?(%{CISCO_USER:source.user.name}|\\*+)(%{SPACE})?"
      pattern_definitions:
        CISCO_USER: ((LOCAL\\+)?(%{HOSTNAME}\\+)?%{USERNAME}(@%{HOSTNAME})?(, *%{NUMBER})?)
  - grok:
      tag: grok_message_f9399ca9
      if: "ctx._temp_.cisco.message_id == '113012'"
      field: "message"
      description: "113012"
      patterns:
      - "AAA user authentication Successful(%{SPACE})?: local database(%{SPACE})?: [Uu]ser = %{CISCO_USER:source.user.name}"
      pattern_definitions:
        CISCO_USER: ((LOCAL\\+)?(%{HOSTNAME}\\+)?%{USERNAME}(@%{HOSTNAME})?(, *%{NUMBER})?)
  - grok:
      tag: grok_message_3209842c
      if: "ctx._temp_.cisco.message_id == '113014'"
      description: "113014"
      field: "message"
      patterns:
          - "AAA authentication server not accessible(%{SPACE})?: server =(%{SPACE})?%{IP:destination.address}(%{SPACE})?: [Uu]ser = (%{CISCO_USER:source.user.name}|\\*+)(%{SPACE})?"
      pattern_definitions:
        CISCO_USER: ((LOCAL\\+)?(%{HOSTNAME}\\+)?%{USERNAME}(@%{HOSTNAME})?(, *%{NUMBER})?)
  - dissect:
      tag: dissect_message_d28b0b6c
      if: "ctx._temp_.cisco.message_id == '113019'"
      field: "message"
      description: "113019"
      pattern: "Group = %{source.user.group.name}, Username = %{source.user.name}, IP = %{destination.address}, Session disconnected. Session Type: %{_temp_.cisco.session_type}, Duration: %{_temp_.duration_hms}, Bytes xmt: %{source.bytes}, Bytes rcv: %{destination.bytes}, Reason: %{event.reason}"
  - dissect:
      tag: dissect_message_90c0d9c4
      if: "ctx._temp_.cisco.message_id == '113021'"
      field: "message"
      description: "113021"
      pattern: "Attempted console login failed. User %{source.user.name} did NOT have appropriate Admin Rights."
  - dissect:
      tag: dissect_message_c629e5d9
      if: "ctx._temp_.cisco.message_id == '113040'"
      field: "message"
      description: "113040"
      pattern: "Terminating the VPN connection attempt from %{source.user.group.name}. Reason: This connection is group locked to %{}."
  - grok:
      if: '["113029","113030","113031","113032","113033","113034","113035","113036","113038","113039"].contains(ctx._temp_.cisco.message_id)'
      field: "message"
      description: "113029, 113030, 113031, 113032, 113033, 113034, 113035, 113036, 113038, 113039"
      tag: "113039_group_user_ip"
      patterns:
        - '^Group <%{NOTBRACKET:source.user.group.name}> User <%{NOTBRACKET:source.user.name}> IP <%{NOTBRACKET:source.address}>'
        - '^Group %{NOTSPACE:source.user.group.name} User %{NOTSPACE:source.user.name} IP %{NOTSPACE:source.address}'
      pattern_definitions:
        NOTBRACKET: "[^<>]+"
  - grok:
      if: "ctx._temp_.cisco.message_id == '113042'"
      field: "message"
      description: "113042"
      tag: "113042"
      patterns:
        - "^Non-HTTP connection from %{NOTCOLON:_temp_.cisco.source_interface}:%{IPORHOST:source.address}/%{NUMBER:source.port} to %{NOTCOLON:_temp_.cisco.destination_interface}:%{IPORHOST:destination.address}/%{NUMBER:destination.port} denied by redirect filter; only HTTP connections are supported for redirection.$"
      pattern_definitions:
        NOTCOLON: "[^:]*"
        IPORHOST: "(?:%{IP}|%{HOSTNAME})"
  - grok:
      if: "ctx._temp_.cisco.message_id == '210007'"
      field: "message"
      description: "210007"
      tag: "210007"
      patterns:
        - "^LU allocate xlate failed for %{TYPE:_temp_.cisco.translation_type} %{WORD:network.protocol} translation from %{NOTCOLON:_temp_.cisco.source_interface}:%{IPORHOST:source.address}/%{NUMBER:source.port} \\(%{IPORHOST:_temp_.cisco.mapped_source_ip}/%{NUMBER:_temp_.cisco.mapped_source_port}\\) to %{NOTCOLON:_temp_.cisco.destination_interface}:%{IPORHOST:destination.address}/%{NUMBER:destination.port} \\(%{IPORHOST:_temp_.cisco.mapped_destination_ip}/%{NUMBER:_temp_.cisco.mapped_destination_port}\\)"
      pattern_definitions:
        NOTCOLON: "[^:]*"
        IPORHOST: "(?:%{IP}|%{HOSTNAME})"
        TYPE: "%{WORD}-%{WORD}"
  - dissect:
      if: "ctx._temp_.cisco.message_id == '210022'"
      field: "message"
      description: "210022"
      tag: "210022"
      pattern: "LU missed %{_temp_.cisco.missed_updates_count} updates"

  - convert:
      if: ctx._temp_?.cisco?.missed_updates_count != null
      field: _temp_.cisco.missed_updates_count
      target_field: _temp_.cisco.missed_updates_count
      tag: convert-missed_updates_to_integer
      type: integer
  - grok:
      tag: grok_message_a804d0ae
      if: '["302013", "302015"].contains(ctx._temp_.cisco.message_id)'
      field: "message"
      description: "302013, 302015"
      patterns:
        - Built %{NOTSPACE} (?:Probe )?%{NOTSPACE:network.transport} connection %{NUMBER:_temp_.cisco.connection_id} for %{NOTCOLON:_temp_.cisco.source_interface}:%{IPORHOST:source.address}/%{NUMBER:source.port} \(%{IPORHOST:_temp_.natsrcip}/%{NUMBER:_temp_.cisco.mapped_source_port}\)(\(%{CISCO_USER:_temp_.cisco.source_username}\))? to %{NOTCOLON:_temp_.cisco.destination_interface}:%{NOTSPACE:destination.address}/%{NUMBER:destination.port} \(%{NOTSPACE:_temp_.natdstip}/%{NUMBER:_temp_.cisco.mapped_destination_port}\)(\(%{CISCO_USER:_temp_.cisco.destination_username}\))?( \(%{CISCO_USER:_temp_.cisco.termination_user}\))?%{GREEDYDATA}
      pattern_definitions:
        HOSTNAME: "\\b(?:[0-9A-Za-z][0-9A-Za-z_-]{0,62})(?:\\.(?:[0-9A-Za-z][0-9A-Za-z_-]{0,62}))*(\\.?|\\b)"
        IPORHOST: "(?:%{IP}|%{HOSTNAME})"
        NOTCOLON: "[^:]*"
        CISCO_USER: ((LOCAL\\)?(%{HOSTNAME}\\)?%{USERNAME}(@%{HOSTNAME})?(, *%{NUMBER})?)
  - dissect:
      tag: dissect_message_bc91ddc4
      if: "ctx._temp_.cisco.message_id == '303002'"
      field: "message"
      description: "303002"
      pattern: "%{network.protocol} connection from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port}, user %{client.user.name} %{} file %{file.path}"
  - grok:
      if: "ctx._temp_.cisco.message_id == '305006'"
      field: "message"
      description: "305006"
      tag: "305006"
      patterns:
        - '^%{NOTSPACE:_temp_.cisco.translation_type} translation creation failed for %{NOTSPACE:network.protocol} src %{NOTCOLON:_temp_.cisco.source_interface}:%{IPORHOST:source.address}(/%{NUMBER:source.port})?(\s*\(%{CISCO_USER:_temp_.cisco.source_username}\))? dst %{NOTCOLON:_temp_.cisco.destination_interface}:%{IPORHOST:destination.address}(/%{NUMBER:destination.port})?(\s*\(%{CISCO_USER:_temp_.cisco.destination_username}\))? \(type %{NUMBER:_temp_.cisco.icmp_type}, code %{NUMBER:_temp_.cisco.icmp_code}\)$'
      pattern_definitions:
        NOTCOLON: "[^:]*"
        IPORHOST: "(?:%{IP}|%{HOSTNAME})"
        CISCO_USER: ((LOCAL\\)?(%{HOSTNAME}\\)?%{USERNAME}(@%{HOSTNAME})?(, *%{NUMBER})?)
  - grok:
      tag: handle_305012
      if: "ctx._temp_.cisco.message_id == '305012'"
      field: "message"
      description: "305012"
      patterns:
        - Teardown %{DATA} %{NOTSPACE:network.transport} translation from %{NOTCOLON:_temp_.cisco.source_interface}:%{IPORHOST:source.address}/%{NUMBER:source.port}(\s*\(%{CISCO_USER:_temp_.cisco.source_username}\))? to %{NOTCOLON:_temp_.cisco.destination_interface}:%{IP:destination.address}/%{NUMBER:destination.port} duration %{DURATION:_temp_.duration_hms}
      pattern_definitions:
        NOTCOLON: "[^:]*"
        HOSTNAME: "\\b(?:[0-9A-Za-z][0-9A-Za-z_-]{0,62})(?:\\.(?:[0-9A-Za-z][0-9A-Za-z_-]{0,62}))*(\\.?|\\b)"
        IPORHOST: "(?:%{IP}|%{HOSTNAME})"
        CISCO_USER: ((LOCAL\\+)?(%{HOSTNAME}\\+)?%{USERNAME}(@%{HOSTNAME})?(, *%{NUMBER})?)
        DURATION: "%{INT}:%{MINUTE}:%{SECOND}"
  - set:
      tag: set_event_action_e0b65e0c
      if: '["302020"].contains(ctx._temp_.cisco.message_id)'
      field: "event.action"
      value: "flow-creation"
      description: "302020"
  - grok:
      tag: grok_message_694f8bb7
      if: "ctx._temp_.cisco.message_id == '302020'"
      field: "message"
      description: "302020"
      patterns:
        - "Built %{NOTSPACE} %{NOTSPACE:network.protocol} connection for faddr (?:%{NOTCOLON:_temp_.cisco.source_interface}:)?%{ECSDESTIPORHOST}/%{NUMBER}\\s*(?:\\(%{CISCO_USER:_temp_.cisco.destination_username}\\) )?gaddr (?:%{NOTCOLON}:)?%{MAPPEDSRC}/%{NUMBER} laddr (?:%{NOTCOLON:_temp_.cisco.source_interface}:)?%{ECSSOURCEIPORHOST}/%{NUMBER}\\s*(?:\\(%{CISCO_USER:_temp_.cisco.source_username}\\) )?(type %{NUMBER:_temp_.cisco.icmp_type} code %{NUMBER:_temp_.cisco.icmp_code})?"
      pattern_definitions:
        HOSTNAME: "\\b(?:[0-9A-Za-z][0-9A-Za-z_-]{0,62})(?:\\.(?:[0-9A-Za-z][0-9A-Za-z_-]{0,62}))*(\\.?|\\b)"
        IPORHOST: "(?:%{IP}|%{HOSTNAME})"
        NOTCOLON: "[^:]*"
        ECSSOURCEIPORHOST: "(?:%{IP:source.address}|%{HOSTNAME:source.domain})"
        ECSDESTIPORHOST: "(?:%{IP:destination.address}|%{HOSTNAME:destination.domain})"
        MAPPEDSRC: "(?:%{DATA:_temp_.natsrcip}|%{HOSTNAME})"
        CISCO_USER: ((LOCAL\\)?(%{HOSTNAME}\\)?%{USERNAME}(@%{HOSTNAME})?(, *%{NUMBER})?)
  - dissect:
      tag: dissect_message_5f6e5b75
      if: "ctx._temp_.cisco.message_id == '302022'"
      field: "message"
      description: "302022"
      pattern: "Built %{} stub %{network.transport} connection for %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} %{} to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} %{}"
  - dissect:
      tag: dissect_message_9e6dc105
      if: "ctx._temp_.cisco.message_id == '302023'"
      field: "message"
      description: "302023"
      pattern: "Teardown %{->} %{network.transport} connection for %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} duration %{_temp_.duration_hms} forwarded bytes %{network.bytes} %{event.reason}"
  - grok:
      tag: grok_message_a0c9deed
      if: "ctx._temp_.cisco.message_id == '304001'"
      field: "message"
      description: "304001"
      patterns:
        - "(%{NOTSPACE:source.user.name}@)?%{IP:source.address}(\\(%{DATA}\\))? %{DATA} (%{NOTSPACE}@)?%{IPORHOST:destination.address}:%{GREEDYDATA:url.original}"
  - set:
      tag: set_event_outcome_5a89b3d3
      if: "ctx._temp_.cisco.message_id == '304001'"
      field: "event.outcome"
      description: "304001"
      value: success
  - dissect:
      tag: dissect_message_cd8b807d
      if: "ctx._temp_.cisco.message_id == '304002'"
      field: "message"
      description: "304002"
      pattern: "Access %{event.outcome} URL %{url.original} SRC %{source.address} %{}EST %{destination.address} on interface %{_temp_.cisco.source_interface}"
  - grok:
      tag: grok_message_db0dfbcb
      if: "ctx._temp_.cisco.message_id == '305011'"
      field: "message"
      description: "305011"
      patterns:
        - Built %{NOTSPACE} %{NOTSPACE:network.transport} translation from %{NOTSPACE:_temp_.cisco.source_interface}:%{IPORHOST:source.address}/%{NUMBER:source.port}(\(%{NOTSPACE:source.user.name}\))? to %{NOTSPACE:_temp_.cisco.destination_interface}:%{IP:destination.address}/%{NUMBER:destination.port}
  - grok:
      if: "ctx._temp_.cisco.message_id == '305013'"
      field: "message"
      description: "305013"
      tag: "305013"
      patterns:
        - "^Asymmetric NAT rules matched for forward and reverse flows; Connection for protocol %{NOTSPACE:network.iana_number} src %{NOTCOLON:_temp_.cisco.source_interface}:%{IPORHOST}(?:/%{NUMBER:source.port})?(?:\\(%{NOTSPACE:source.user.name}\\))? dst %{NOTCOLON:_temp_.cisco.destination_interface}:%{IPORHOST}(?:/%{NUMBER:destination.port})? denied due to NAT reverse path failure"
        - "^Asymmetric NAT rules matched for forward and reverse flows; Connection for %{NOTSPACE:network.transport} src %{NOTCOLON:_temp_.cisco.source_interface}:%{IPORHOST}(?:/%{NUMBER:source.port})?(?:\\(%{NOTSPACE:source.user.name}\\))? dst %{NOTCOLON:_temp_.cisco.destination_interface}:%{IPORHOST}(?:/%{NUMBER:destination.port})? denied due to NAT reverse path failure"
      pattern_definitions:
        NOTCOLON: "[^:]*"
  - dissect:
      tag: dissect_message_e97c992b
      if: "ctx._temp_.cisco.message_id == '313001'"
      field: "message"
      description: "313001"
      pattern: "%{event.outcome} %{network.transport} type=%{_temp_.cisco.icmp_type}, code=%{_temp_.cisco.icmp_code} from %{source.address} on interface %{_temp_.cisco.source_interface}"
  - dissect:
      tag: dissect_message_31d80956
      if: "ctx._temp_.cisco.message_id == '313004'"
      field: "message"
      description: "313004"
      pattern: "%{event.outcome} %{network.transport} type=%{_temp_.cisco.icmp_type}, from%{}addr %{source.address} on interface %{_temp_.cisco.source_interface} to %{destination.address}: no matching session"
  - grok:
      tag: grok_message_c2324481
      if: "ctx._temp_.cisco.message_id == '313005'"
      field: "message"
      description: "313005"
      patterns:
        - "No matching connection for ICMP error message: %{NOTSPACE:network.transport} src %{NOTCOLON:_temp_.cisco.source_interface}:%{IPORHOST} dst %{NOTCOLON:_temp_.cisco.destination_interface}:%{IPORHOST} \\(type %{NUMBER:_temp_.cisco.icmp_type}, code %{NUMBER:_temp_.cisco.icmp_code}\\) on %{NOTCOLON} interface.%{SPACE}Original IP payload: %{NOTSPACE:input.type} src %{IPORHOST:source.address}(/%{NUMBER:source.port})? dst %{IPORHOST:destination.address}(/%{NUMBER:destination.port})?[.]?"
        - "No matching connection for ICMP error message: %{NOTSPACE:network.transport} src %{NOTCOLON:_temp_.cisco.source_interface}:%{IPORHOST} dst %{NOTCOLON:_temp_.cisco.destination_interface}:%{IPORHOST} \\(type %{NUMBER:_temp_.cisco.icmp_type}, code %{NUMBER:_temp_.cisco.icmp_code}\\) on %{NOTCOLON} interface.%{SPACE}Original IP payload: protocol %{NUMBER:_temp_.cisco.original_iana_number} src %{IPORHOST:source.address}(/%{NUMBER:source.port})? dst %{IPORHOST:destination.address}(/%{NUMBER:destination.port})?[.]?"
        - "No matching connection for ICMP error message: %{NOTSPACE:network.transport} src %{NOTCOLON:_temp_.cisco.source_interface}:%{IPORHOST}\\(%{NOTCOLON:source.user.domain}\\\\%{NOTSPACE:source.user.group.name}\\\\%{NOTSPACE:source.user.name}\\) dst %{NOTCOLON:_temp_.cisco.destination_interface}:%{IPORHOST} \\(type %{NUMBER:_temp_.cisco.icmp_type}, code %{NUMBER:_temp_.cisco.icmp_code}\\) on %{NOTCOLON} interface.%{SPACE}Original IP payload: %{NOTSPACE:input.type} src %{IPORHOST:source.address}(/%{NUMBER:source.port})? dst %{IPORHOST:destination.address}(/%{NUMBER:destination.port})?[.]?"
        - "No matching connection for ICMP error message: %{NOTSPACE:network.transport} src %{NOTCOLON:_temp_.cisco.source_interface}:%{IPORHOST}\\(%{NOTCOLON:source.user.domain}\\\\%{NOTSPACE:source.user.name}\\) dst %{NOTCOLON:_temp_.cisco.destination_interface}:%{IPORHOST} \\(type %{NUMBER:_temp_.cisco.icmp_type}, code %{NUMBER:_temp_.cisco.icmp_code}\\) on %{NOTCOLON} interface.%{SPACE}Original IP payload: %{NOTSPACE:input.type} src %{IPORHOST:source.address}(/%{NUMBER:source.port})? dst %{IPORHOST:destination.address}(/%{NUMBER:destination.port})?[.]?"
        - "No matching connection for ICMP error message: %{NOTSPACE:network.transport} src %{NOTCOLON:_temp_.cisco.source_interface}:%{IPORHOST}(\\(%{CISCO_USER_OR_SGT_SRC}\\))? dst %{NOTCOLON:_temp_.cisco.destination_interface}:%{IPORHOST}(\\(%{CISCO_USER_OR_SGT_DST}\\))? \\(type %{NUMBER:_temp_.cisco.icmp_type}, code %{NUMBER:_temp_.cisco.icmp_code}\\) on %{NOTCOLON} interface.%{SPACE}Original IP payload: %{NOTSPACE:input.type} src %{IPORHOST:source.address}(/%{NUMBER:source.port})? dst %{IPORHOST:destination.address}(/%{NUMBER:destination.port})?[.]?"
        - "No matching connection for ICMP error message: %{NOTSPACE:network.transport} src %{NOTCOLON:_temp_.cisco.source_interface}:%{IPORHOST:source.address}(/%{NUMBER:source.port})?(\\(%{CISCO_USER_OR_SGT_SRC}\\))? dst %{NOTCOLON:_temp_.cisco.destination_interface}:%{IPORHOST:destination.address}(/%{NUMBER:destination.port})?(\\(%{CISCO_USER_OR_SGT_DST}\\))? \\(type %{NUMBER:_temp_.cisco.icmp_type}, code %{NUMBER:_temp_.cisco.icmp_code}\\) on %{NOTCOLON} interface.%{SPACE}Original IP payload: <%{NOTSPACE:input.type}>[.]?"
      pattern_definitions:
        NOTCOLON: "[^:]*"
        HOSTNAME: "\\b(?:[0-9A-Za-z][0-9A-Za-z\\-_]{0,62})(?:\\.(?:[0-9A-Za-z][0-9A-Za-z\\-_]{0,62}))*(\\.?|\\b)"
        IPORHOST: "(?:%{IP}|%{HOSTNAME})"
        USERNAME: "[a-zA-Z0-9._'-]+"
        CISCO_USER_OR_SGT_SRC: (?:%{CISCO_USER:_temp_.cisco.source_user_or_sgt}|%{CISCO_SGT:_temp_.cisco.source_user_or_sgt}|\((?:%{CISCO_USER:_temp_.cisco.source_user_or_sgt}|%{CISCO_SGT:_temp_.cisco.source_user_or_sgt})\))
        CISCO_USER_OR_SGT_DST: (?:%{CISCO_USER:_temp_.cisco.destination_user_or_sgt}|%{CISCO_SGT:_temp_.cisco.destination_user_or_sgt}|\((?:%{CISCO_USER:_temp_.cisco.destination_user_or_sgt}|%{CISCO_SGT:_temp_.cisco.destination_user_or_sgt})\))
        CISCO_USER: (?:\*\*\*\*\*|(?:(?:LOCAL\\)?(?:%{HOSTNAME}\\)?%{USERNAME}\$?(?:@%{HOSTNAME})?%{CISCO_SGT}?)|[^$]+)
        CISCO_SGT: (?:, *)?%{NUMBER}(?::%{WORD})?
  - dissect:
      tag: dissect_message_fdc2950b
      if: "ctx._temp_.cisco.message_id == '313008'"
      field: "message"
      description: "313008"
      pattern: "%{event.outcome} %{network.transport} type=%{_temp_.cisco.icmp_type}, code=%{_temp_.cisco.icmp_code} from %{source.address} on interface %{_temp_.cisco.source_interface}"
  - dissect:
      tag: dissect_message_9b8b0c49
      if: "ctx._temp_.cisco.message_id == '313009'"
      field: "message"
      description: "313009"
      pattern: "%{event.outcome} invalid %{network.transport} code %{_temp_.cisco.icmp_code}, for %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})%{}"
  - dissect:
      tag: dissect_message_a7d7ac1e
      if: "ctx._temp_.cisco.message_id == '322001'"
      field: "message"
      description: "322001"
      pattern: "%{event.outcome} MAC address %{source.mac}, possible spoof attempt on interface %{_temp_.cisco.source_interface}"
  - dissect:
      tag: dissect_message_f22d4120
      if: "ctx._temp_.cisco.message_id == '338001'"
      field: "message"
      description: "338001"
      pattern: "Dynamic filter %{event.outcome} black%{}d %{network.transport} traffic from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})%{}source %{} resolved from %{_temp_.cisco.list_id} list: %{source.domain}, threat-level: %{_temp_.cisco.threat_level}, category: %{_temp_.cisco.threat_category}"
  - set:
      tag: set_server_domain_7ec179b8
      if: "ctx._temp_.cisco.message_id == '338001'"
      field: "server.domain"
      description: "338001"
      value: "{{{source.domain}}}"
      ignore_empty_value: true
  - dissect:
      tag: dissect_message_ced5ea18
      if: "ctx._temp_.cisco.message_id == '338002'"
      field: "message"
      description: "338002"
      pattern: "Dynamic %{}ilter %{event.outcome} black%{}d %{network.transport} traffic from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})%{}destination %{} resolved from %{_temp_.cisco.list_id} list: %{destination.domain}"
  - set:
      tag: set_server_domain_f810669b
      if: "ctx._temp_.cisco.message_id == '338002'"
      field: "server.domain"
      description: "338002"
      value: "{{{destination.domain}}}"
      ignore_empty_value: true
  - dissect:
      tag: dissect_message_8a458d08
      if: "ctx._temp_.cisco.message_id == '338003'"
      field: "message"
      description: "338003"
      pattern: "Dynamic %{}ilter %{event.outcome} black%{}d %{network.transport} traffic from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})%{}source %{} resolved from %{_temp_.cisco.list_id} list: %{}, threat-level: %{_temp_.cisco.threat_level}, category: %{_temp_.cisco.threat_category}"
  - dissect:
      tag: dissect_message_5585f50d
      if: "ctx._temp_.cisco.message_id == '338004'"
      field: "message"
      description: "338004"
      pattern: "Dynamic %{}ilter %{event.outcome} black%{}d %{network.transport} traffic from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})%{}destination %{} resolved from %{_temp_.cisco.list_id} list: %{}, threat-level: %{_temp_.cisco.threat_level}, category: %{_temp_.cisco.threat_category}"
  - dissect:
      tag: dissect_message_2e2f952b
      if: "ctx._temp_.cisco.message_id == '338005'"
      field: "message"
      description: "338005"
      pattern: "Dynamic %{}ilter %{event.outcome} black%{}d %{network.transport} traffic from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})%{}source %{} resolved from %{_temp_.cisco.list_id} list: %{source.domain}, threat-level: %{_temp_.cisco.threat_level}, category: %{_temp_.cisco.threat_category}"
  - set:
      tag: set_server_domain_9897af88
      if: "ctx._temp_.cisco.message_id == '338005'"
      field: "server.domain"
      description: "338005"
      value: "{{{source.domain}}}"
      ignore_empty_value: true
  - dissect:
      tag: dissect_message_2768d74b
      if: "ctx._temp_.cisco.message_id == '338006'"
      field: "message"
      description: "338006"
      pattern: "Dynamic %{}ilter %{event.outcome} black%{}d %{network.transport} traffic from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})%{}destination %{} resolved from %{_temp_.cisco.list_id} list: %{destination.domain}, threat-level: %{_temp_.cisco.threat_level}, category: %{_temp_.cisco.threat_category}"
  - set:
      tag: set_server_domain_2cb506d3
      if: "ctx._temp_.cisco.message_id == '338006'"
      field: "server.domain"
      description: "338006"
      value: "{{{destination.domain}}}"
      ignore_empty_value: true
  - dissect:
      tag: dissect_message_4bf13cb8
      if: "ctx._temp_.cisco.message_id == '338007'"
      field: "message"
      description: "338007"
      pattern: "Dynamic %{}ilter %{event.outcome} black%{}d %{network.transport} traffic from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})%{}source %{} resolved from %{_temp_.cisco.list_id} list: %{}, threat-level: %{_temp_.cisco.threat_level}, category: %{_temp_.cisco.threat_category}"
  - dissect:
      tag: dissect_message_3375a0a5
      if: "ctx._temp_.cisco.message_id == '338008'"
      field: "message"
      description: "338008"
      pattern: "Dynamic %{}ilter %{event.outcome} black%{}d %{network.transport} traffic from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})%{}destination %{} resolved from %{_temp_.cisco.list_id} list: %{}, threat-level: %{_temp_.cisco.threat_level}, category: %{_temp_.cisco.threat_category}"
  - dissect:
      tag: dissect_message_c4d3119a
      if: "ctx._temp_.cisco.message_id == '338101'"
      field: "message"
      description: "338101"
      pattern: "Dynamic %{}ilter %{event.outcome} white%{}d %{network.transport} traffic from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})%{}source %{} resolved from %{_temp_.cisco.list_id} list: %{source.domain}"
  - set:
      tag: set_server_domain_0302e990
      if: "ctx._temp_.cisco.message_id == '338101'"
      field: "server.domain"
      description: "338101"
      value: "{{{source.domain}}}"
      ignore_empty_value: true
  - dissect:
      tag: dissect_message_c5802cf2
      if: "ctx._temp_.cisco.message_id == '338102'"
      field: "message"
      description: "338102"
      pattern: "Dynamic %{}ilter %{event.outcome} white%{}d %{network.transport} traffic from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})%{}destination %{} resolved from %{_temp_.cisco.list_id} list: %{destination.domain}"
  - set:
      tag: set_server_domain_514e3f63
      if: "ctx._temp_.cisco.message_id == '338102'"
      field: "server.domain"
      description: "338102"
      value: "{{{destination.domain}}}"
      ignore_empty_value: true
  - dissect:
      tag: dissect_message_c0d2793b
      if: "ctx._temp_.cisco.message_id == '338103'"
      field: "message"
      description: "338103"
      pattern: "Dynamic %{}ilter %{event.outcome} white%{}d %{network.transport} traffic from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})%{}source %{} resolved from %{_temp_.cisco.list_id} list: %{}"
  - dissect:
      tag: dissect_message_ea3d3290
      if: "ctx._temp_.cisco.message_id == '338104'"
      field: "message"
      description: "338104"
      pattern: "Dynamic %{}ilter %{event.outcome} white%{}d %{network.transport} traffic from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})%{}destination %{} resolved from %{_temp_.cisco.list_id} list: %{}"
  - dissect:
      tag: dissect_message_a8958d27
      if: "ctx._temp_.cisco.message_id == '338201'"
      field: "message"
      description: "338201"
      pattern: "Dynamic %{}ilter %{event.outcome} grey%{}d %{network.transport} traffic from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})%{}source %{} resolved from %{_temp_.cisco.list_id} list: %{source.domain}, threat-level: %{_temp_.cisco.threat_level}, category: %{_temp_.cisco.threat_category}"
  - set:
      tag: set_server_domain_687488fc
      if: "ctx._temp_.cisco.message_id == '338201'"
      field: "server.domain"
      description: "338201"
      value: "{{{source.domain}}}"
      ignore_empty_value: true
  - dissect:
      tag: dissect_message_7f52c707
      if: "ctx._temp_.cisco.message_id == '338202'"
      field: "message"
      description: "338202"
      pattern: "Dynamic %{}ilter %{event.outcome} grey%{}d %{network.transport} traffic from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})%{}destination %{} resolved from %{_temp_.cisco.list_id} list: %{destination.domain}, threat-level: %{_temp_.cisco.threat_level}, category: %{_temp_.cisco.threat_category}"
  - set:
      tag: set_server_domain_44736b1f
      if: "ctx._temp_.cisco.message_id == '338202'"
      field: "server.domain"
      description: "338202"
      value: "{{{destination.domain}}}"
      ignore_empty_value: true
  - dissect:
      tag: dissect_message_dfffb2ab
      if: "ctx._temp_.cisco.message_id == '338203'"
      field: "message"
      description: "338203"
      pattern: "Dynamic %{}ilter %{event.outcome} grey%{}d %{network.transport} traffic from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})%{}source %{} resolved from %{_temp_.cisco.list_id} list: %{source.domain}, threat-level: %{_temp_.cisco.threat_level}, category: %{_temp_.cisco.threat_category}"
  - set:
      tag: set_server_domain_35ee3e38
      if: "ctx._temp_.cisco.message_id == '338203'"
      field: "server.domain"
      description: "338203"
      value: "{{{source.domain}}}"
      ignore_empty_value: true
  - dissect:
      tag: dissect_message_fadff473
      if: "ctx._temp_.cisco.message_id == '338204'"
      field: "message"
      description: "338204"
      pattern: "Dynamic %{}ilter %{event.outcome} grey%{}d %{network.transport} traffic from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})%{}destination %{} resolved from %{_temp_.cisco.list_id} list: %{destination.domain}, threat-level: %{_temp_.cisco.threat_level}, category: %{_temp_.cisco.threat_category}"
  - set:
      tag: set_server_domain_f00bd653
      if: "ctx._temp_.cisco.message_id == '338204'"
      field: "server.domain"
      description: "338204"
      value: "{{{destination.domain}}}"
      ignore_empty_value: true
  - dissect:
      tag: dissect_message_2b7a65da
      if: "ctx._temp_.cisco.message_id == '338301'"
      field: "message"
      description: "338301"
      pattern: "Intercepted DNS reply for domain %{source.domain} from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port}, matched %{_temp_.cisco.list_id}"
  - set:
      tag: set_client_address_f939be97
      if: "ctx._temp_.cisco.message_id == '338301'"
      field: "client.address"
      description: "338301"
      value: "{{{destination.address}}}"
      ignore_empty_value: true
  - set:
      tag: set_client_port_de94a64d
      if: "ctx._temp_.cisco.message_id == '338301'"
      field: "client.port"
      description: "338301"
      value: "{{{destination.port}}}"
      ignore_empty_value: true
  - set:
      tag: set_server_address_de8b6436
      if: "ctx._temp_.cisco.message_id == '338301'"
      field: "server.address"
      description: "338301"
      value: "{{{source.address}}}"
      ignore_empty_value: true
  - set:
      tag: set_server_port_20d11358
      if: "ctx._temp_.cisco.message_id == '338301'"
      field: "server.port"
      description: "338301"
      value: "{{{source.port}}}"
      ignore_empty_value: true
  - dissect:
      if: "ctx._temp_.cisco.message_id == '401004'"
      field: "message"
      description: "401004"
      tag: "401004"
      pattern: "Shunned packet: %{source.address} ==> %{destination.address} on interface %{_temp_.cisco.destination_interface}"
  - grok:
      if: "ctx._temp_.cisco.message_id == '500004'"
      field: "message"
      description: "500004"
      tag: "500004"
      patterns:
        - "^Invalid transport field for protocol=%{NOTSPACE:network.transport}, from %{IPORHOST:source.address}/%{NUMBER:source.port} to %{IPORHOST:destination.address}/%{NUMBER:destination.port}$"
  - dissect:
      tag: dissect_message_bea78615
      if: "ctx._temp_.cisco.message_id == '502103'"
      field: "message"
      description: "502103"
      pattern: "User priv level changed: Uname: %{server.user.name} From: %{_temp_.cisco.privilege.old} To: %{_temp_.cisco.privilege.new}"
  - append:
      tag: append_event_type_d489f7f7
      if: "ctx._temp_.cisco.message_id == '502103'"
      field: "event.type"
      description: "502103"
      value:
        - "group"
        - "change"
  - append:
      tag: append_event_category_9c69d5ed
      if: "ctx._temp_.cisco.message_id == '502103'"
      field: "event.category"
      description: "502103"
      value: "iam"
  - dissect:
      tag: dissect_message_894f4cd2
      if: "ctx._temp_.cisco.message_id == '507003'"
      field: "message"
      description: "507003"
      pattern: "%{network.transport} flow from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} terminated by inspection engine, reason - %{message}"
  - dissect:
      tag: dissect_message_3a253aa4
      if: '["602101"].contains(ctx._temp_.cisco.message_id)'
      field: "message"
      description: "602101"
      pattern: 'PMTU-D packet %{source.bytes} bytes greater than effective mtu %{_temp_.cisco.effective_mtu}, dest_addr=%{destination.address}, src_addr=%{source.address}, prot=%{network.protocol}'
  - dissect:
      tag: dissect_message_c6abf635
      if: '["605004", "605005"].contains(ctx._temp_.cisco.message_id)'
      field: "message"
      description: "605004, 605005"
      pattern: 'Login %{event.outcome} from %{source.address}/%{source.port} to %{_temp_.cisco.destination_interface}:%{destination.address}/%{network.protocol} for user "%{source.user.name}"'
  - dissect:
      tag: dissect_message_2f77840c
      if: "ctx._temp_.cisco.message_id == '609001'"
      field: "message"
      description: "609001"
      pattern: "Built local-host %{_temp_.cisco.source_interface}:%{source.address}"
  - dissect:
      tag: dissect_message_34002fc5
      if: "ctx._temp_.cisco.message_id == '607001'"
      field: "message"
      description: "607001"
      pattern: "Pre-allocate SIP %{_temp_.cisco.connection_type} secondary channel for %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} to %{_temp_.cisco.source_interface}:%{source.address} from %{_temp_.cisco.message} message"
  - grok:
      tag: grok__temp__cisco_connection_type_6415f82a
      if: "ctx._temp_.cisco.message_id == '607001'"
      description: "607001"
      field: "_temp_.cisco.connection_type"
      patterns:
        - "%{CONNECTION}"
      pattern_definitions:
        TRANSPORTS: "(?:UDP|TCP)"
        PROTOCOLS: "(?:RTP|RTCP)"
        CONNECTION: "(?:%{TRANSPORTS:network.transport}|%{PROTOCOLS:network.protocol})"
      ignore_failure: true
  - dissect:
      tag: dissect_message_8a352aca
      if: "ctx._temp_.cisco.message_id == '609002'"
      field: "message"
      description: "609002"
      pattern: "Teardown local-host %{_temp_.cisco.source_interface}:%{source.address} duration %{_temp_.duration_hms}"
  - dissect:
      tag: dissect_message_598706d8
      if: '["611102", "611101"].contains(ctx._temp_.cisco.message_id)'
      field: "message"
      description: "611102, 611101"
      pattern: 'User authentication %{event.outcome}: IP address: %{source.address}, Uname: %{server.user.name}'
  - dissect:
      tag: dissect_message_276452d8
      if: "ctx._temp_.cisco.message_id == '710003'"
      field: "message"
      description: "710003"
      pattern: "%{network.transport} access %{event.outcome} by ACL from %{source.address}/%{source.port} to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port}"
  - dissect:
      tag: dissect_message_0f0b0226
      if: "ctx._temp_.cisco.message_id == '710005'"
      field: "message"
      description: "710005"
      pattern: "%{network.transport} request %{event.outcome} from %{source.address}/%{source.port} to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port}"
  - dissect:
      tag: dissect_message_2a2e3530
      if: "ctx._temp_.cisco.message_id == '713049'"
      field: "message"
      description: "713049"
      pattern: "Group = %{}, IP = %{source.address}, Security negotiation complete for LAN-to-LAN Group (%{}) %{}, Inbound SPI = %{}, Outbound SPI = %{}"
      ignore_failure: true
  - dissect:
      tag: dissect_message_cd8cf8dd
      if: "ctx._temp_.cisco.message_id == '713049'"
      field: "message"
      description: "713049"
      pattern: "Group = %{}, Username = %{user.name}, IP = %{source.address}, Security negotiation complete for User (%{}) %{}, Inbound SPI = %{}, Outbound SPI = %{}"
      ignore_failure: true
  - grok:
      tag: grok_message_de1c83ac
      if: "ctx._temp_.cisco.message_id == '716002'"
      field: "message"
      description: "716002"
      patterns:
        - "Group <%{NOTSPACE:_temp_.cisco.webvpn.group_name}> User <%{NOTANGLE:source.user.name}> IP <%{IP:source.address}> WebVPN session terminated: %{GREEDYDATA:event.reason}."
        - "Group %{NOTSPACE:_temp_.cisco.webvpn.group_name} User %{NOTSPACE:source.user.name} IP %{IP:source.address} WebVPN session terminated: %{GREEDYDATA:event.reason}."
      pattern_definitions:
        NOTANGLE: "[^>]+"
  - grok:
      tag: grok_message_54375f23
      if: "ctx._temp_.cisco.message_id == '722051'"
      field: "message"
      description: "722051"
      patterns:
        - "Group <%{NOTANGLE:_temp_.cisco.webvpn.group_name}> User <%{NOTANGLE:source.user.name}> IP <%{IP:source.address}> IPv4 [Aa]ddress <%{IP:_temp_.cisco.assigned_ip}> IPv6 [Aa]ddress <%{IP:_temp_.cisco.assigned_ipv6}> %{GREEDYDATA}"
        - "Group %{NOTSPACE:_temp_.cisco.webvpn.group_name} User %{NOTSPACE:source.user.name} IP %{IP:source.address} IPv4 [Aa]ddress %{IP:_temp_.cisco.assigned_ip} IPv6 [Aa]ddress %{IP:_temp_.cisco.assigned_ipv6} %{GREEDYDATA}"
      pattern_definitions:
        NOTANGLE: "[^>]+"
  - grok:
      tag: grok_message_5eb9c5e1
      if: "ctx._temp_.cisco.message_id == '722055'"
      field: "message"
      description: "722055"
      patterns:
        - "Group <%{NOTANGLE:_temp_.cisco.webvpn.group_name}> User <%{NOTANGLE:source.user.name}> IP <%{IP:source.address}> Client [Tt]ype: %{GREEDYDATA:user_agent.original}"
        - "Group %{NOTSPACE:_temp_.cisco.webvpn.group_name} User %{NOTSPACE:source.user.name} IP %{IP:source.address} Client [Tt]ype: %{GREEDYDATA:user_agent.original}"
      pattern_definitions:
        NOTANGLE: "[^>]+"
  - grok:
      tag: grok_message_e8671e8d
      if: "ctx._temp_.cisco.message_id == '733100'"
      field: "message"
      description: "733100"
      patterns:
        - \[(%{SPACE})?%{DATA:_temp_.cisco.burst.object}\] drop %{NOTSPACE:_temp_.cisco.burst.id} exceeded. Current burst rate is %{INT:_temp_.cisco.burst.current_rate} per second, max configured rate is %{INT:_temp_.cisco.burst.configured_rate}; Current average rate is %{INT:_temp_.cisco.burst.avg_rate} per second, max configured rate is %{INT:_temp_.cisco.burst.configured_avg_rate}; Cumulative total count is %{INT:_temp_.cisco.burst.cumulative_count}
  - dissect:
      tag: dissect_message_f44eb359
      if: "ctx._temp_.cisco.message_id == '734001'"
      field: "message"
      description: "734001"
      pattern: "DAP: User %{user.email}, Addr %{source.address}, Connection %{_temp_.cisco.connection_type}: The following DAP records were selected for this connection: %{_temp_.cisco.dap_records->}"
  - dissect:
      tag: dissect_message_79c92198
      if: "['746012', '746013'].contains(ctx._temp_.cisco.message_id)"
      field: "message"
      description: "746012, 746013"
      pattern: "user-identity: %{} IP-User mapping %{source.address} - %{source.user.name} %{_temp_.operation.status} - %{event.reason}"
  - dissect:
      tag: dissect_message_6194bb72
      if: "ctx._temp_.cisco.message_id == '805001'"
      field: "message"
      description: "805001"
      pattern: "Offloaded %{network.transport} Flow for connection %{_temp_.cisco.connection_id} from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})"
  - dissect:
      tag: dissect_message_a73405b8
      if: "ctx._temp_.cisco.message_id == '805002'"
      field: "message"
      description: "805002"
      pattern: "%{network.transport} Flow is no longer offloaded for connection %{_temp_.cisco.connection_id} from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} (%{_temp_.natsrcip}/%{_temp_.cisco.mapped_source_port}) to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} (%{_temp_.natdstip}/%{_temp_.cisco.mapped_destination_port})"
  - split:
      tag: split__temp__cisco_dap_records_0a80bda2
      field: "_temp_.cisco.dap_records"
      separator: ",\\s+"
      ignore_missing: true
  - dissect:
      tag: dissect_message_be4bf56c
      if: "ctx._temp_.cisco.message_id == '434002'"
      field: "message"
      pattern: "SFR requested to %{event.action} %{network.protocol} packet from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port}"
  - dissect:
      tag: dissect_message_dcad7e69
      if: "ctx._temp_.cisco.message_id == '434004'"
      field: "message"
      pattern: "SFR requested ASA to %{event.action} further packet redirection and process %{network.protocol} flow from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} locally"
  - dissect:
      tag: dissect_message_81557986
      if: "ctx._temp_.cisco.message_id == '110002'"
      field: "message"
      pattern: "%{event.reason} for %{network.protocol} from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} to %{destination.address}/%{destination.port}"
  - dissect:
      tag: dissect_message_c9305ec0
      if: "ctx._temp_.cisco.message_id == '419002'"
      field: "message"
      pattern: "%{event.reason}from %{_temp_.cisco.source_interface}:%{source.address}/%{source.port} to %{_temp_.cisco.destination_interface}:%{destination.address}/%{destination.port} %{+event.reason}"
  - dissect:
      tag: dissect_message_bd510f62
      if: '["602303", "602304"].contains(ctx._temp_.cisco.message_id)'
      field: "message"
      pattern: "%{network.type}: An %{} %{_temp_.cisco.tunnel_type} SA (SPI= %{}) between %{source.address} and %{destination.address} (user= %{user.name}) has been %{event.action}."
  - dissect:
      tag: dissect_message_f5022bda
      if: "ctx._temp_.cisco.message_id == '750002'"
      field: "message"
      pattern: "Local:%{source.address}:%{source.port} Remote:%{destination.address}:%{destination.port} Username:%{user.name} %{event.reason}"
  - dissect:
      tag: dissect_message_07b97c33
      if: "ctx._temp_.cisco.message_id == '713120'"
      field: "message"
      pattern: "Group = %{}, IP = %{source.address}, %{event.reason} (msgid=%{event.id})"
  - dissect:
      tag: dissect_message_0931f126
      if: "ctx._temp_.cisco.message_id == '713202'"
      field: "message"
      pattern: "IP = %{source.address}, %{event.reason}. %{} packet."
  # Support masked user
  - grok:
      tag: grok_message_838487bc
      if: "ctx._temp_.cisco.message_id == '716039'"
      field: "message"
      patterns:
        - "Authentication: rejected, group = %{NOTSPACE:source.user.group.name} user = %{USER:source.user.name} , Session Type: %{NOTSPACE:_temp_.cisco.session_type}"
        - "Group <%{NOTSPACE:source.user.group.name}> User <%{NOTSPACE:source.user.name}> IP <%{IP:source.address}> Authentication: rejected, Session Type: %{NOTSPACE:_temp_.cisco.session_type}\\."
  - grok:
      tag: grok_message_7d565d9b
      if: "ctx._temp_.cisco.message_id == '716058'"
      field: "message"
      description: "716058"
      patterns:
        - "Group <%{NOTANGLE:_temp_.cisco.webvpn.group_name}> User <%{NOTANGLE:source.user.name}> IP <%{IP:source.address}> AnyConnect session lost connection. Waiting to resume."
        - "Group %{NOTSPACE:_temp_.cisco.webvpn.group_name} User %{NOTSPACE:source.user.name} IP %{IP:source.address} AnyConnect session lost connection. Waiting to resume."
      pattern_definitions:
        NOTANGLE: "[^>]+"
  - grok:
      tag: grok_message_02380617
      if: "ctx._temp_.cisco.message_id == '716059'"
      field: "message"
      description: "716059"
      patterns:
        - "Group <%{NOTANGLE:_temp_.cisco.webvpn.group_name}> User <%{NOTANGLE:source.user.name}> IP <%{IP:source.address}> AnyConnect session resumed(. C| c)onnection from IP <%{IP:_temp_.cisco.mapped_source_ip}>."
        - "Group %{NOTSPACE:_temp_.cisco.webvpn.group_name} User %{NOTSPACE:source.user.name} IP %{IP:source.address} AnyConnect session resumed(. C| c)onnection from IP %{IP:_temp_.cisco.mapped_source_ip}."
      pattern_definitions:
        NOTANGLE: "[^>]+"
  - dissect:
      tag: dissect_message_d0899dc3
      if: "ctx._temp_.cisco.message_id == '750003'"
      field: "message"
      pattern: "Local:%{source.address}:%{source.port} Remote:%{destination.address}:%{destination.port} Username:%{user.name} %{event.reason} ERROR:%{+event.reason}"
  - grok:
      tag: grok_message_c6106f6e
      if: '["713905", "713904", "713906", "713902", "713901"].contains(ctx._temp_.cisco.message_id)'
      field: "message"
      patterns:
        - "^(Group = %{IP}, )?(IP = %{IP:source.address}, )?%{GREEDYDATA:event.reason}$"
  # Handle ecs action outcome protocol
  - set:
      tag: set_event_outcome_3dd7a3b4
      if: '["434002", "434004"].contains(ctx._temp_.cisco.message_id)'
      field: "event.outcome"
      value: "unknown"
  - set:
      tag: set_network_protocol_c0e83b85
      if: '["419002"].contains(ctx._temp_.cisco.message_id)'
      field: "network.protocol"
      value: "tcp"
  - set:
      tag: set_event_outcome_794f7a5a
      if: '["110002"].contains(ctx._temp_.cisco.message_id)'
      field: "event.outcome"
      value: "failure"
  - set:
      tag: set_event_outcome_d4596f53
      if: '["713120"].contains(ctx._temp_.cisco.message_id)'
      field: "event.outcome"
      value: "success"
  - set:
      tag: set_event_outcome_6e12978d
      if: '["746012", "746013"].contains(ctx._temp_.cisco.message_id) && ctx._temp_.operation.status == "Succeeded"'
      field: "event.outcome"
      value: "success"
  - set:
      tag: set_event_outcome_e5fff54a
      if: '["746012", "746013"].contains(ctx._temp_.cisco.message_id) && ctx._temp_.operation.status != "Succeeded"'
      field: "event.outcome"
      value: "failure"
  - set:
      tag: set_event_outcome_e3e9ba71
      if: '["113004", "113008", "113009", "113012"].contains(ctx._temp_.cisco.message_id)'
      field: "event.outcome"
      value: "success"
  - set:
      tag: set_event_outcome_026a1547
      if: '["113002", "113005", "113014", "113021"].contains(ctx._temp_.cisco.message_id)'
      field: "event.outcome"
      value: "failure"
  - set:
      tag: set_event_outcome_f35d0724
      if: '["602303", "602304", "611101"].contains(ctx._temp_.cisco.message_id)'
      field: "event.outcome"
      value: "success"
  - set:
      tag: set_event_outcome_66bd1d8c
      if: '["605004", "611102"].contains(ctx._temp_.cisco.message_id)'
      field: "event.outcome"
      value: "failure"
  - set:
      tag: set_event_outcome_5d0767bc
      if: '["734001"].contains(ctx._temp_.cisco.message_id)'
      field: "event.outcome"
      value: "success"
  - set:
      tag: set_event_outcome_f0723da0
      if: '["716039"].contains(ctx._temp_.cisco.message_id)'
      field: "event.outcome"
      value: "failure"
  - set:
      tag: set_event_outcome_ddbe737d
      if: '["710005"].contains(ctx._temp_.cisco.message_id)'
      field: "event.outcome"
      value: "failure"
  - set:
      tag: set_event_outcome_dd95ba31
      if: '["713901", "713902", "713903", "713904", "713905"].contains(ctx._temp_.cisco.message_id)'
      field: "event.outcome"
      value: "failure"
  - set:
      tag: set_event_action_b23ec255
      if: '["113039", "746012"].contains(ctx._temp_.cisco.message_id)'
      field: "event.action"
      value: "client-vpn-connected"
  - set:
      tag: set_event_action_5565ea16
      if: '["602101"].contains(ctx._temp_.cisco.message_id)'
      field: "event.action"
      value: "vpn-pmtu-d"
  - set:
      tag: set_event_action_4203be42
      if: '["113029","113030","113031","113032","113033","113034","113035","113036","113037","113038","113040"].contains(ctx._temp_.cisco.message_id)'
      field: "event.action"
      value: "client-vpn-error"
  - set:
      tag: set_event_action_78393b0c
      if: '["113019", "746013"].contains(ctx._temp_.cisco.message_id)'
      field: "event.action"
      value: "client-vpn-disconnected"
  - set:
      tag: set_event_action_ed2a7c31
      if: '["750002", "750003"].contains(ctx._temp_.cisco.message_id)'
      field: "event.action"
      value: "connection-started"
  - set:
      tag: set_event_action_65885db3
      if: '["750003", "713905", "713904", "713906", "713902", "713901"].contains(ctx._temp_.cisco.message_id)'
      field: "event.action"
      value: "error"
  - set:
      tag: set_event_action_7311840f
      if: '["113005", "113014", "113021", "605004", "611102", "716039"].contains(ctx._temp_.cisco.message_id)'
      field: "event.action"
      value: "logon-failed"
  - set:
      tag: set_event_action_d03078e7
      if: '["113004", "113008", "113009", "113012", "611101", "734001"].contains(ctx._temp_.cisco.message_id)'
      field: "event.action"
      value: "logged-in"
  - append:
      tag: append_event_type_6d279e6d
      if: '["750003", "713905", "713904", "713906", "713902", "713901"].contains(ctx._temp_.cisco.message_id)'
      field: "event.type"
      value: "error"

  #
  # Handle 302xxx messages (Flow expiration a.k.a "Teardown")
  #
  - set:
      tag: set_event_action_13c02b9c
      if: '["305012", "302014", "302016", "302018", "302021", "302036", "302304", "302306", "609001", "609002"].contains(ctx._temp_.cisco.message_id)'
      field: "event.action"
      value: "flow-expiration"
      description: "305012, 302014, 302016, 302018, 302021, 302036, 302304, 302306, 609001, 609002"
  - grok:
      field: "message"
      if: '["302014", "302016", "302018", "302021", "302036", "302304", "302306"].contains(ctx._temp_.cisco.message_id)'
      description: "302014, 302016, 302018, 302021, 302036, 302304, 302306"
      tag: parse_teardown_message
      patterns:
        - ^Teardown (?:Probe )?%{NOTSPACE:network.transport} (?:state-bypass )?connection %{NOTSPACE:_temp_.cisco.connection_id} (?:for|from) %{NOTCOLON:_temp_.cisco.source_interface}:%{DATA:source.address}/%{NUMBER:source.port:int}\s*(?:\(?%{CISCO_USER:_temp_.cisco.source_username}\)? )?to %{NOTCOLON:_temp_.cisco.destination_interface}:%{DATA:destination.address}/%{NUMBER:destination.port:int}\s*(?:\(?%{CISCO_USER:_temp_.cisco.destination_username}\)? )?duration\s+(?:%{DURATION:_temp_.duration_hms} bytes %{NUMBER:network.bytes}) %{NOTCOLON:event.reason} from %{NOTCOLON:_temp_.cisco.termination_initiator} \(%{CISCO_USER:_temp_.cisco.termination_user}\)
        - ^Teardown (?:Probe )?%{NOTSPACE:network.transport} (?:state-bypass )?connection %{NOTSPACE:_temp_.cisco.connection_id} (?:for|from) %{NOTCOLON:_temp_.cisco.source_interface}:%{DATA:source.address}/%{NUMBER:source.port:int}\s*(?:\(?%{CISCO_USER:_temp_.cisco.source_username}\)? )?to %{NOTCOLON:_temp_.cisco.destination_interface}:%{DATA:destination.address}/%{NUMBER:destination.port:int}\s*(?:\(?%{CISCO_USER:_temp_.cisco.destination_username}\)? )?duration\s+(?:%{DURATION:_temp_.duration_hms} bytes %{NUMBER:network.bytes}) %{NOTCOLON:event.reason} from %{NOTCOLON:_temp_.cisco.termination_initiator}
        - ^Teardown (?:Probe )?%{NOTSPACE:network.transport} (?:state-bypass )?connection %{NOTSPACE:_temp_.cisco.connection_id} (?:for|from) %{NOTCOLON:_temp_.cisco.source_interface}:%{DATA:source.address}/%{NUMBER:source.port:int}\s*(?:\(?%{CISCO_USER:_temp_.cisco.source_username}\)? )?to %{NOTCOLON:_temp_.cisco.destination_interface}:%{DATA:destination.address}/%{NUMBER:destination.port:int}\s*(?:\(?%{CISCO_USER:_temp_.cisco.destination_username}\)? )?duration\s+(?:%{DURATION:_temp_.duration_hms} bytes %{NUMBER:network.bytes}) %{NOTCOLON:event.reason} \(%{CISCO_USER:_temp_.cisco.termination_user}\)
        - ^Teardown (?:Probe )?%{NOTSPACE:network.transport} (?:state-bypass )?connection %{NOTSPACE:_temp_.cisco.connection_id} (?:for|from) %{NOTCOLON:_temp_.cisco.source_interface}:%{DATA:source.address}/%{NUMBER:source.port:int}\s*(?:\(?%{CISCO_USER:_temp_.cisco.source_username}\)? )?to %{NOTCOLON:_temp_.cisco.destination_interface}:%{DATA:destination.address}/%{NUMBER:destination.port:int}\s*(?:\(?%{CISCO_USER:_temp_.cisco.destination_username}\)? )?duration\s+(?:%{DURATION:_temp_.duration_hms} bytes %{NUMBER:network.bytes}) \(%{CISCO_USER:_temp_.cisco.termination_user}\)
        - ^Teardown (?:Probe )?%{NOTSPACE:network.transport} (?:state-bypass )?connection %{NOTSPACE:_temp_.cisco.connection_id} (?:for|from) %{NOTCOLON:_temp_.cisco.source_interface}:%{DATA:source.address}/%{NUMBER:source.port:int}\s*(?:\(?%{CISCO_USER:_temp_.cisco.source_username}\)? )?to %{NOTCOLON:_temp_.cisco.destination_interface}:%{DATA:destination.address}/%{NUMBER:destination.port:int}\s*(?:\(?%{CISCO_USER:_temp_.cisco.destination_username}\)? )?duration\s+(?:%{DURATION:_temp_.duration_hms} bytes %{NUMBER:network.bytes}) %{NOTCOLON:event.reason}
        - ^Teardown (?:Probe )?%{NOTSPACE:network.transport} (?:state-bypass )?connection %{NOTSPACE:_temp_.cisco.connection_id} (?:for|from) %{NOTCOLON:_temp_.cisco.source_interface}:%{DATA:source.address}/%{NUMBER:source.port:int}\s*(?:\(?%{CISCO_USER:_temp_.cisco.source_username}\)? )?to %{NOTCOLON:_temp_.cisco.destination_interface}:%{DATA:destination.address}/%{NUMBER:destination.port:int}\s*(?:\(?%{CISCO_USER:_temp_.cisco.destination_username}\)? )?duration\s+(?:%{DURATION:_temp_.duration_hms} bytes %{NUMBER:network.bytes})
        - ^Teardown (?:Probe )?%{NOTSPACE:network.transport} connection for faddr (?:%{NOTCOLON:_temp_.cisco.source_interface}:)?%{ECSDESTIPORHOST}/%{NUMBER}\s*(?:\(?%{CISCO_USER:_temp_.cisco.destination_username}\)? )?gaddr (?:%{NOTCOLON}:)?%{MAPPEDSRC}/%{NUMBER} laddr (?:%{NOTCOLON:_temp_.cisco.source_interface}:)?%{ECSSOURCEIPORHOST}/%{NUMBER}\s*(?:\(%{CISCO_USER:_temp_.cisco.source_username}\))?(\s*type %{NUMBER:_temp_.cisco.icmp_type} code %{NUMBER:_temp_.cisco.icmp_code})?
      pattern_definitions:
        HOSTNAME: "\\b(?:[0-9A-Za-z][0-9A-Za-z_-]{0,62})(?:\\.(?:[0-9A-Za-z][0-9A-Za-z_-]{0,62}))*(\\.?|\\b)"
        IPORHOST: "(?:%{IP}|%{HOSTNAME})"
        NOTCOLON: "[^:]*"
        ECSSOURCEIPORHOST: "(?:%{IP:source.address}|%{HOSTNAME:source.domain})"
        ECSDESTIPORHOST: "(?:%{IP:destination.address}|%{HOSTNAME:destination.domain})"
        MAPPEDSRC: "(?:%{IPORHOST:_temp_.natsrcip}|%{HOSTNAME})"
        DURATION: "%{INT}:%{MINUTE}:%{SECOND}"
        CISCO_USER: ((LOCAL\\)?(%{HOSTNAME}\\)?%{USERNAME}(@%{HOSTNAME})?(, *%{NUMBER})?)

  #
  # Decode FTD's Security Event Syslog Messages
  #
  # 43000x messages are security event syslog messages specific to FTD.
  # Format is a comma-separated sequence of key: value pairs.
  #
  # The result of this decoding is saved as _temp_.orig_security.{Key}: {Value}
  - kv:
      tag: kv_message_to__temp__orig_security_8a35cb25
      if: '["430001", "430002", "430003", "430004", "430005", ""].contains(ctx._temp_.cisco.message_id)'
      field: "message"
      description: "430001, 430002, 430003, 430004, 430005"
      field_split: ",(?=[A-za-z1-9\\s]+:)"
      value_split: ":"
      target_field: "_temp_.orig_security"
      trim_key: " "
      trim_value: " "
      ignore_failure: true

  #
  # Remove _temp_.full_message.
  #
  # The field has been used as temporary buffer while decoding. The full message
  # is kept under event.original. Processors below can still add a message field, as some
  # security events contain an explanatory Message field.
  - remove:
      tag: remove_4d200af9
      field:
        - message
        - _temp_.full_message
        - _conf
      ignore_missing: true

  #
  # Populate ECS fields from Security Events
  #
  # This script uses the key-value pairs from Security Events to populate
  # the appropriate ECS fields.
  #
  # A single key can be mapped to multiple ECS fields, and more than one key can
  # map to the same ECS field, which results in an array being created.
  #
  # This script performs an additional job:
  #
  # Before FTD version 6.3, the message_id was not included in Security Events.
  # As this field encodes the kind of event (intrusion, connection, malware...)
  # the script below will guess the right message_id from the keys present in
  # the event.
  #
  # The reason for overloading this script with different behaviors is
  # that this pipeline is already reaching the limit on script compilations.
  #
  #*******************************************************************************
  # Code generated by go generate. DO NOT EDIT.
  #*******************************************************************************
  - script:
      tag: script_6fbab0e8
      if: ctx._temp_?.orig_security != null
      params:
        ACPolicy:
          target: ac_policy
          id: ["430001", "430002", "430003"]
          ecs: [_temp_.cisco.rule_name]
        AccessControlRuleAction:
          target: access_control_rule_action
          id: ["430002", "430003"]
          ecs: [event.outcome]
        AccessControlRuleName:
          target: access_control_rule_name
          id: ["430002", "430003"]
          ecs: [_temp_.cisco.rule_name]
        AccessControlRuleReason:
          target: access_control_rule_reason
          id: ["430002", "430003"]
        ApplicationProtocol:
          target: application_protocol
          ecs: [network.protocol]
        ArchiveDepth:
          target: archive_depth
          id: ["430004", "430005"]
        ArchiveFileName:
          target: archive_file_name
          id: ["430004", "430005"]
          ecs: [file.name]
        ArchiveFileStatus:
          target: archive_file_status
          id: ["430004", "430005"]
        ArchiveSHA256:
          target: archive_sha256
          id: ["430004", "430005"]
          ecs: [file.hash.sha256]
        Classification:
          target: classification
          id: ["430001"]
        Client:
          target: client
          ecs: [network.application]
        ClientVersion:
          target: client_version
          id: ["430002", "430003"]
        ConnectionDuration:
          target: connection_duration
          id: ["430003"]
          ecs: [event.duration]
        DNS_Sinkhole:
          target: dns_sinkhole
          id: ["430002", "430003"]
        DNS_TTL:
          target: dns_ttl
          id: ["430002", "430003"]
        DNSQuery:
          target: dns_query
          id: ["430002", "430003"]
          ecs: [dns.question.name]
        DNSRecordType:
          target: dns_record_type
          id: ["430002", "430003"]
          ecs: [dns.question.type]
        DNSResponseType:
          target: dns_response_type
          id: ["430002", "430003"]
          ecs: [dns.response_code]
        DNSSICategory:
          target: dnssi_category
          id: ["430002", "430003"]
        DstIP:
          target: dst_ip
          ecs: [destination.address]
        DstPort:
          target: dst_port
          ecs: [destination.port]
        DestinationIP_DynamicAttribute:
          target: destination_ip_dynamic_attribute
          id: ["430002", "430003"]
        DestinationSecurityGroup:
          target: destination_security_group
          id: ["430002", "430003"]
        DestinationSecurityGroupTag:
          target: destination_security_group_tag
          id: ["430002", "430003"]
        EgressInterface:
          target: egress_interface
          id: ["430001", "430002", "430003"]
          ecs: [_temp_.cisco.destination_interface]
        EgressZone:
          target: egress_zone
          id: ["430001", "430002", "430003"]
          ecs: [observer.egress.zone]
        EncryptPeerIP:
          target: encrypt_peer_ip
          id: ["430001", "430002", "430003"]
        Endpoint Profile:
          target: endpoint_profile
          id: ["430002", "430003"]
          ecs: [_temp_.host.type]
        FileAction:
          target: file_action
          id: ["430004", "430005"]
        FileCount:
          target: file_count
          id: ["430002", "430003"]
        FileDirection:
          target: file_direction
          id: ["430004", "430005"]
        FileName:
          target: file_name
          id: ["430004", "430005"]
          ecs: [file.name]
        FilePolicy:
          target: file_policy
          id: ["430004", "430005"]
          ecs: [_temp_.cisco.rule_name]
        FileSHA256:
          target: file_sha256
          id: ["430004", "430005"]
          ecs: [file.hash.sha256]
        FileSandboxStatus:
          target: file_sandbox_status
          id: ["430004", "430005"]
        FileSize:
          target: file_size
          id: ["430004", "430005"]
          ecs: [file.size]
        FileStorageStatus:
          target: file_storage_status
          id: ["430004", "430005"]
        FileType:
          target: file_type
          id: ["430004", "430005"]
        FirstPacketSecond:
          target: first_packet_second
          id: ["430004", "430005"]
          ecs: [event.start]
        GID:
          target: gid
          id: ["430001"]
          ecs: [service.id]
        HTTPReferer:
          target: http_referer
          id: ["430002", "430003"]
          ecs: [http.request.referrer]
        HTTPResponse:
          target: http_response
          id: ["430001", "430002", "430003"]
          ecs: [http.response.status_code]
        ICMPCode:
          target: icmp_code
          id: ["430001", "430002", "430003"]
        ICMPType:
          target: icmp_type
          id: ["430001", "430002", "430003"]
        IPReputationSICategory:
          target: ip_reputation_si_category
          id: ["430002", "430003"]
        IPSCount:
          target: ips_count
          id: ["430002", "430003"]
        IngressInterface:
          target: ingress_interface
          id: ["430001", "430002", "430003"]
          ecs: [_temp_.cisco.source_interface]
        IngressZone:
          target: ingress_zone
          id: ["430001", "430002", "430003"]
          ecs: [observer.ingress.zone]
        InitiatorBytes:
          target: initiator_bytes
          id: ["430003"]
          ecs: [source.bytes]
        InitiatorPackets:
          target: initiator_packets
          id: ["430003"]
          ecs: [source.packets]
        InlineResult:
          target: inline_result
          id: ["430001"]
          ecs: [event.outcome]
        IntrusionPolicy:
          target: intrusion_policy
          id: ["430001"]
          ecs: [_temp_.cisco.rule_name]
        MPLS_Label:
          target: mpls_label
          id: ["430001"]
        Message:
          target: message
          id: ["430001"]
          ecs: [message]
        NAT_InitiatorIP:
          target: nat_src_ip
          id: ["430002", "430003"]
          ecs: [source.nat.ip]
        NAT_InitiatorPort:
          target: nat_src_port
          id: ["430002", "430003"]
          ecs: [source.nat.port]
        NAT_ResponderIP:
          target: nat_dst_ip
          id: ["430002", "430003"]
          ecs: [destination.nat.ip]
        NAT_ResponderPort:
          target: nat_dst_port
          id: ["430002", "430003"]
          ecs: [destination.nat.port]
        NAPPolicy:
          target: nap_policy
          id: ["430001", "430002", "430003"]
        NetBIOSDomain:
          target: net_bios_domain
          id: ["430002", "430003"]
          ecs: [host.hostname]
        NumIOC:
          target: num_ioc
          id: ["430001"]
        Prefilter Policy:
          target: prefilter_policy
          id: ["430002", "430003"]
        Priority:
          target: priority
          id: ["430001"]
        Protocol:
          target: protocol
          ecs: [network.transport]
        ReferencedHost:
          target: referenced_host
          id: ["430002", "430003"]
          ecs: [url.domain]
        ResponderBytes:
          target: responder_bytes
          id: ["430003"]
          ecs: [destination.bytes]
        ResponderPackets:
          target: responder_packets
          id: ["430003"]
          ecs: [destination.packets]
        Revision:
          target: revision
          id: ["430001"]
          ecs: [rule.version]
        SHA_Disposition:
          target: sha_disposition
          id: ["430004", "430005"]
        SID:
          target: sid
          id: ["430001"]
          ecs: [rule.id]
        SSLActualAction:
          target: ssl_actual_action
          ecs: [event.outcome]
        SSLCertificate:
          target: ssl_certificate
          id: ["430002", "430003", "430004", "430005"]
        SSLExpectedAction:
          target: ssl_expected_action
          id: ["430002", "430003"]
        SSLFlowStatus:
          target: ssl_flow_status
          id: ["430002", "430003", "430004", "430005"]
        SSLPolicy:
          target: ssl_policy
          id: ["430002", "430003"]
        SSLRuleName:
          target: ssl_rule_name
          id: ["430002", "430003"]
        SSLServerCertStatus:
          target: ssl_server_cert_status
          id: ["430002", "430003"]
        SSLServerName:
          target: ssl_server_name
          id: ["430002", "430003"]
          ecs: [server.domain]
        SSLSessionID:
          target: ssl_session_id
          id: ["430002", "430003"]
        SSLTicketID:
          target: ssl_ticket_id
          id: ["430002", "430003"]
        SSLURLCategory:
          target: sslurl_category
          id: ["430002", "430003"]
        SSLVersion:
          target: ssl_version
          id: ["430002", "430003"]
        SSSLCipherSuite:
          target: sssl_cipher_suite
          id: ["430002", "430003"]
        SecIntMatchingIP:
          target: sec_int_matching_ip
          id: ["430002", "430003"]
        Security Group:
          target: security_group
          id: ["430002", "430003"]
        SperoDisposition:
          target: spero_disposition
          id: ["430004", "430005"]
        SourceSecurityGroup:
          target: source_security_group
          id: ["430002", "430003"]
        SourceSecurityGroupTag:
          target: source_security_group_tag
          id: ["430002", "430003"]
        SourceSecurityGroupType:
          target: source_security_group_type
          id: ["430002", "430003"]
        SrcIP:
          target: src_ip
          ecs: [source.address]
        SrcPort:
          target: src_port
          ecs: [source.port]
        TCPFlags:
          target: tcp_flags
          id: ["430002", "430003"]
        ThreatName:
          target: threat_name
          id: ["430005"]
          ecs: [_temp_.cisco.threat_category]
        ThreatScore:
          target: threat_score
          id: ["430005"]
          ecs: [_temp_.cisco.threat_level]
        Tunnel or Prefilter Rule:
          target: tunnel_or_prefilter_rule
          id: ["430002", "430003"]
        URI:
          target: uri
          id: ["430004", "430005"]
          ecs: [url.original]
        URL:
          target: url
          id: ["430002", "430003"]
          ecs: [url.original]
        URLCategory:
          target: url_category
          id: ["430002", "430003"]
        URLReputation:
          target: url_reputation
          id: ["430002", "430003"]
        URLSICategory:
          target: urlsi_category
          id: ["430002", "430003"]
        User:
          target: user
          ecs: [user.id, user.name]
        UserAgent:
          target: user_agent
          id: ["430002", "430003"]
          ecs: [user_agent.original]
        VLAN_ID:
          target: vlan_id
          id: ["430001", "430002", "430003"]
        VPN_Action:
          target: vpn_action
          id: ["430001", "430002", "430003"]
        WebApplication:
          target: web_application
          ecs: [network.application]
        originalClientSrcIP:
          target: original_client_src_ip
          id: ["430002", "430003"]
          ecs: [client.address]
      lang: painless
      source: |
        boolean isEmpty(def value) {
          return (value instanceof AbstractList ? value.size() : value.length()) == 0;
        }
        def appendOrCreate(Map dest, String[] path, def value) {
         for (int i=0; i<path.length-1; i++) {
          dest = dest.computeIfAbsent(path[i], _ -> new HashMap());
         }
         String key = path[path.length - 1];
         def existing = dest.get(key);
         return existing == null ?
          dest.put(key, value)
          : existing instanceof AbstractList ?
            existing.add(value)
            : dest.put(key, new ArrayList([existing, value]));
        }
        def msg = ctx._temp_.orig_security;
        def counters = new HashMap();
        def dest = new HashMap();
        def dest_event = new HashMap();
        def security_event_list = new ArrayList(['ac_policy',
                                    'access_control_rule_action',
                                    'access_control_rule_name',
                                    'access_control_rule_reason',
                                    'application_protocol',
                                    'client',
                                    'client_version',
                                    'connection_duration',
                                    'dns_query',
                                    'dns_record_type',
                                    'dns_response_type',
                                    'dns_ttl',
                                    'destination_ip_dynamic_attribute',
                                    'destination_security_group',
                                    'destination_security_group_tag',
                                    'dst_ip',
                                    'dst_port',
                                    'egress_interface',
                                    'egress_zone',
                                    'encrypt_peer_ip',
                                    'file_action',
                                    'file_count',
                                    'file_direction',
                                    'file_name',
                                    'file_policy',
                                    'file_sandbox_status',
                                    'file_sha256',
                                    'file_size',
                                    'file_type',
                                    'first_packet_second',
                                    'http_referer',
                                    'http_response',
                                    'icmp_code',
                                    'icmp_type',
                                    'ingress_interface',
                                    'ingress_zone',
                                    'initiator_bytes',
                                    'initiator_packets',
                                    'nap_policy',
                                    'prefilter_policy',
                                    'protocol',
                                    'referenced_host',
                                    'responder_bytes',
                                    'responder_packets',
                                    'sha_disposition',
                                    'source_security_group',
                                    'source_security_group_tag',
                                    'source_security_group_type',
                                    'spero_disposition',
                                    'src_ip',
                                    'src_port',
                                    'ssl_actual_action',
                                    'ssl_certificate',
                                    'ssl_expected_action',
                                    'ssl_flow_status',
                                    'ssl_policy',
                                    'ssl_rule_name',
                                    'ssl_server_cert_status',
                                    'ssl_server_name',
                                    'ssl_session_id',
                                    'ssl_ticket_id',
                                    'ssl_version',
                                    'sslurl_category',
                                    'tunnel_or_prefilter_rule',
                                    'uri',
                                    'url',
                                    'url_category',
                                    'url_reputation',
                                    'user',
                                    'user_agent',
                                    'vpn_action',
                                    'web_application']);
        ctx._temp_.cisco['security'] = dest;
        ctx._temp_.cisco['security_event'] = dest_event;
        for (entry in msg.entrySet()) {
         def param = params.get(entry.getKey());
         if (param == null) {
           continue;
         }
         param.getOrDefault('id', []).forEach( id -> counters[id] = 1 + counters.getOrDefault(id, 0) );
         if (!isEmpty(entry.getValue())) {
          param.getOrDefault('ecs', []).forEach( field -> appendOrCreate(ctx, field.splitOnToken('.'), entry.getValue()) );
          if (security_event_list.contains(param.target)){
            dest_event[param.target] = entry.getValue();
          }
          else{
            dest[param.target] = entry.getValue();
          }
         }
        }
        if (ctx._temp_.cisco.message_id != "") return;
        def best;
        for (entry in counters.entrySet()) {
         if (best == null || best.getValue() < entry.getValue()) best = entry;
        }
        if (best != null) ctx._temp_.cisco.message_id = best.getKey();
  #*******************************************************************************
  # End of generated code.
  #*******************************************************************************

  # Convert security_event fields into their appropriate datatype
  - convert:
      if: ctx._temp_?.cisco?.security_event?.connection_duration != null
      tag: convert-security_event_connection_duration
      field: _temp_.cisco.security_event.connection_duration
      target_field: _temp_.cisco.security_event.connection_duration
      type: integer
  - convert:
      if: ctx._temp_?.cisco?.security_event?.dns_ttl != null
      tag: convert-security_event_dns_ttl
      field: _temp_.cisco.security_event.dns_ttl
      target_field: _temp_.cisco.security_event.dns_ttl
      type: integer
  - convert:
      if: ctx._temp_?.cisco?.security_event?.dst_ip != null
      tag: convert-security_event_dst_ip
      field: _temp_.cisco.security_event.dst_ip
      target_field: _temp_.cisco.security_event.dst_ip
      type: ip
  - convert:
      if: ctx._temp_?.cisco?.security_event?.encrypt_peer_ip != null
      tag: convert-security_event_encrypt_peer_ip
      field: _temp_.cisco.security_event.encrypt_peer_ip
      type: ip
  - convert:
      if: ctx._temp_?.cisco?.security_event?.dst_port != null
      tag: convert-security_event_dst_port
      field: _temp_.cisco.security_event.dst_port
      target_field: _temp_.cisco.security_event.dst_port
      type: integer
  - convert:
      if: ctx._temp_?.cisco?.security_event?.file_count != null
      tag: convert-security_event_file_count
      field: _temp_.cisco.security_event.file_count
      target_field: _temp_.cisco.security_event.file_count
      type: integer
  - convert:
      if: ctx._temp_?.cisco?.security_event?.file_size != null
      tag: convert-security_event_file_size
      field: _temp_.cisco.security_event.file_size
      target_field: _temp_.cisco.security_event.file_size
      type: integer
  - date:
      field: _temp_.cisco.security_event.first_packet_second
      tag: date_first_packet_second
      if: ctx._temp_?.cisco?.security_event?.first_packet_second != null
      formats:
        - ISO8601
      on_failure:
        - append:
            tag: append_error_message_ee723da2
            field: error.message
            value: 'Processor {{{_ingest.on_failure_processor_type}}} with tag {{{_ingest.on_failure_processor_tag}}} in pipeline {{{_ingest.pipeline}}} failed with message: {{{_ingest.on_failure_message}}}'
  - convert:
      if: ctx._temp_?.cisco?.security_event?.http_response != null
      tag: convert-security_event_http_response
      field: _temp_.cisco.security_event.http_response
      target_field: _temp_.cisco.security_event.http_response
      type: integer
  - convert:
      if: ctx._temp_?.cisco?.security_event?.initiator_bytes != null
      tag: convert-security_event_initiator_bytes
      field: _temp_.cisco.security_event.initiator_bytes
      target_field: _temp_.cisco.security_event.initiator_bytes
      type: long
  - convert:
      if: ctx._temp_?.cisco?.security_event?.initiator_packets != null
      tag: convert-security_event_initiator_packets
      field: _temp_.cisco.security_event.initiator_packets
      target_field: _temp_.cisco.security_event.initiator_packets
      type: integer
  - convert:
      if: ctx._temp_?.cisco?.security_event?.responder_bytes != null
      tag: convert-security_event_responder_bytes
      field: _temp_.cisco.security_event.responder_bytes
      target_field: _temp_.cisco.security_event.responder_bytes
      type: long
  - convert:
      if: ctx._temp_?.cisco?.security_event?.responder_packets != null
      tag: convert-security_event_responder_packets
      field: _temp_.cisco.security_event.responder_packets
      target_field: _temp_.cisco.security_event.responder_packets
      type: integer
  - convert:
      if: ctx._temp_?.cisco?.security_event?.src_ip != null
      tag: convert-security_event_src_ip
      field: _temp_.cisco.security_event.src_ip
      target_field: _temp_.cisco.security_event.src_ip
      type: ip
  - convert:
      if: ctx._temp_?.cisco?.security_event?.src_port != null
      tag: convert-security_event_src_port
      field: _temp_.cisco.security_event.src_port
      target_field: _temp_.cisco.security_event.src_port
      type: integer

  #
  # Normalize ECS field values
  #
  - script:
      tag: script_a14307b2
      lang: painless
      params:
        "ctx._temp_.cisco.message_id":
          target: event.action
          map:
            "430001": intrusion-detected
            "430002": connection-started
            "430003": connection-finished
            "430004": file-detected
            "430005": malware-detected
        "dns.question.type":
          map:
            "a host address": A
            "ip6 address": AAAA
            "text strings": TXT
            "a domain name pointer": PTR
            "an authoritative name server": NS
            "the canonical name for an alias": CNAME
            "marks the start of a zone of authority": SOA
            "mail exchange": MX
            "server selection": SRV
        "dns.response_code":
          map:
            "non-existent domain": NXDOMAIN
            "server failure": SERVFAIL
            "query refused": REFUSED
            "no error": NOERROR
      source: |
        def getField(Map src, String[] path) {
         for (int i=0; i<path.length-1; i++) {
          src = src.getOrDefault(path[i], null);
          if (src == null || !(src instanceof Map)) {
            return null;
          }
         }
         return src[path[path.length-1]];
        }
        def setField(Map dest, String[] path, def value) {
         for (int i=0; i<path.length-1; i++) {
           dest = dest.computeIfAbsent(path[i], _ -> new HashMap());
         }
         dest[path[path.length-1]] = value;
        }
        for (entry in params.entrySet()) {
          def srcField = entry.getKey();
          def param = entry.getValue();
          String oldVal = getField(ctx, srcField.splitOnToken('.'));
          if (oldVal == null) continue;
          def newVal = param.map?.getOrDefault(oldVal.toLowerCase(), null);
          if (newVal != null) {
            def dstField = param.getOrDefault('target', srcField);
            setField(ctx, dstField.splitOnToken('.'), newVal);
          }
        }
  - set:
      tag: set_dns_response_code_7c444fac
      if: "ctx.dns?.question?.type != null && ctx.dns?.response_code == null"
      field: dns.response_code
      value: NOERROR
  - set:
      tag: set_event_action_7e874bea
      if: 'ctx._temp_.cisco.message_id == "430001"'
      field: event.action
      value: intrusion-detected
  - set:
      tag: set_event_action_b9f4d205
      if: 'ctx._temp_.cisco.message_id == "430002"'
      field: event.action
      value: connection-started
  - set:
      tag: set_event_action_35070dd9
      if: 'ctx._temp_.cisco.message_id == "430003"'
      field: event.action
      value: connection-finished
  - set:
      tag: set_event_action_53445ef8
      if: 'ctx._temp_.cisco.message_id == "430004"'
      field: event.action
      value: file-detected
  - set:
      tag: set_event_action_c05fb940
      if: 'ctx._temp_.cisco.message_id == "430005"'
      field: event.action
      value: malware-detected

  #
  # Handle event.duration
  #
  # It can be set from ConnectionDuration FTD field above. This field holds
  # seconds as a string. Copy it to _temp_.duration_hms so that the following
  # processor converts it to the right value and populates start and end.
  - set:
      tag: set__temp__duration_hms_d6d5a699
      field: "_temp_.duration_hms"
      value: "{{{event.duration}}}"
      ignore_empty_value: true
  #
  # Ensure source.bytes is long
  #
  - convert:
      tag: convert_source_bytes_5459973e
      if: "ctx.source?.bytes != null"
      field: "source.bytes"
      type: "long"

  #
  # Ensure destination.bytes is long
  #
  - convert:
      tag: convert_destination_bytes_c62141a0
      if: "ctx.destination?.bytes != null"
      field: "destination.bytes"
      type: "long"

  #
  # Sum source.bytes and destination.bytes in network.bytes
  #
  - script:
      tag: script_22d056a5
      lang: painless
      source: |-
        if (ctx.network == null) {
          ctx.network = [:];
        }
        ctx.network.bytes = ctx.source.bytes + ctx.destination.bytes;
      if: ctx.source?.bytes != null && ctx.destination?.bytes != null && ctx.network?.bytes == null

  #
  # Process the flow duration "hh:mm:ss" present in some messages
  # This will fill event.start, event.end and event.duration
  #
  - script:
      tag: script_d2e3c5de
      lang: painless
      if: "ctx._temp_?.duration_hms != null"
      source: >
        long parse_hms(String s) {
            long cur = 0, total = 0;
            for (char c: s.toCharArray()) {
                if (c >= (char)'0' && c <= (char)'9') {
                    cur = (cur*10) + (long)c - (char)'0';
                } else if (c == (char)':') {
                    total = (total + cur) * 60;
                    cur = 0;
                } else if (c != (char)'h' && c == (char)'m' && c == (char)'s') {
                    return 0;
                }
            }
            return total + cur;
        }
        if (ctx.event == null) {
            ctx['event'] = new HashMap();
        }
        if (ctx?._temp_.cisco?.message_id == '430003') {
          String start = ctx['@timestamp'];
          ctx.event['start'] = start;
          long nanos = parse_hms(ctx._temp_.duration_hms) * 1000000000L;
          ctx.event['duration'] = nanos;
          ctx.event['end'] = ZonedDateTime.ofInstant(
              Instant.parse(start).plusNanos(nanos),
              ZoneOffset.UTC);
        } else {
          String end = ctx['@timestamp'];
          ctx.event['end'] = end;
          long nanos = parse_hms(ctx._temp_.duration_hms) * 1000000000L;
          ctx.event['duration'] = nanos;
          ctx.event['start'] = ZonedDateTime.ofInstant(
              Instant.parse(end).minusNanos(nanos),
              ZoneOffset.UTC);
        }
  #
  # Parse Source/Dest Username/Domain
  #
  - gsub:
      tag: strip_extra_escapes_from_source_username
      field: "_temp_.cisco.source_username"
      if: 'ctx._temp_?.cisco?.source_username != null'
      ignore_failure: true
      pattern: '\\{2,}'
      replacement: '\\'
  - grok:
      tag: simplify_source_username
      field: "_temp_.cisco.source_username"
      if: 'ctx._temp_?.cisco?.source_username != null'
      ignore_failure: true
      patterns:
        - '%{CISCO_DOMAIN_USER:_temp_.cisco.source_username}%{CISCO_SGT}'
      pattern_definitions:
        CISCO_DOMAIN_USER: (%{CISCO_DOMAIN})?%{CISCO_USER}
        CISCO_SGT: (, *%{NUMBER:_temp_.cisco.source_user_security_group_tag})?
        CISCO_USER: "%{USERNAME}(@%{HOSTNAME})?"
        CISCO_DOMAIN: (LOCAL\\)?(%{HOSTNAME}\\)?
  - convert:
      tag: convert__temp__cisco_source_user_security_group_tag_48d5bb1d
      field: _temp_.cisco.source_user_security_group_tag
      type: long
      ignore_missing: true
  - grok:
      tag: grok__temp__cisco_destination_username_c682dc3d
      field: "_temp_.cisco.destination_username"
      if: 'ctx._temp_?.cisco?.destination_username != null'
      ignore_failure: true
      patterns:
        - '%{CISCO_DOMAIN_USER:_temp_.cisco.destination_username}%{CISCO_SGT}'
      pattern_definitions:
        CISCO_DOMAIN_USER: (%{CISCO_DOMAIN})?%{CISCO_USER}
        CISCO_SGT: (, *%{NUMBER:_temp_.cisco.destination_user_security_group_tag})?
        CISCO_USER: "%{USERNAME}(@%{HOSTNAME})?"
        CISCO_DOMAIN: (LOCAL\\)?(%{HOSTNAME}\\)?
  - convert:
      tag: convert__temp__cisco_destination_user_security_group_tag_29c8f8b0
      field: _temp_.cisco.destination_user_security_group_tag
      type: long
      ignore_missing: true
  - set:
      tag: set_source_user_name_ae86e40f
      field: source.user.name
      value: "{{{ _temp_.cisco.source_username }}}"
      if: 'ctx.source?.user?.name == null && ctx._temp_?.cisco?.source_username != null'
  - set:
      tag: set_destination_user_name_bdfbaa4b
      field: destination.user.name
      value: "{{{ _temp_.cisco.destination_username }}}"
      if: 'ctx.destination?.user?.name == null && ctx._temp_?.cisco?.destination_username != null'
  # Support masked user value
  - grok:
      field: "source.user.name"
      if: 'ctx.source?.user?.name != null'
      tag: "grok_source_user_name"
      patterns:
        - (%{CISCO_DOMAIN})?%{CISCO_USER_EMAIL:source.user.email}
        - (%{CISCO_DOMAIN})?%{CISCO_USER}
        - \*+
      pattern_definitions:
        USERNAME: "[^@$]+"
        CISCO_USER_EMAIL: "%{CISCO_USER}@%{HOSTNAME:source.user.domain}"
        CISCO_USER: "%{USERNAME:source.user.name}"
        CISCO_DOMAIN: (LOCAL\\)?(%{HOSTNAME:source.user.domain}\\)?
      on_failure:
        - append:
            tag: append_error_message_c22dd4ec
            field: error.message
            value: "fail-{{{ _ingest.on_failure_processor_tag }}}"
        - fail:
            tag: fail_f05c953f
            message: "Processor {{{ _ingest.on_failure_processor_type }}} with tag {{{ _ingest.on_failure_processor_tag }}} in pipeline {{{ _ingest.on_failure_pipeline }}} failed with message: {{{ _ingest.on_failure_message }}}"
  - grok:
      field: "destination.user.name"
      tag: "grok_destination_user_name"
      if: 'ctx.destination?.user?.name != null'
      patterns:
        - (%{CISCO_DOMAIN})?%{CISCO_USER_EMAIL:destination.user.email}
        - (%{CISCO_DOMAIN})?%{CISCO_USER}
      pattern_definitions:
        USERNAME: "[^@$]+"
        CISCO_USER_EMAIL: "%{CISCO_USER}@%{HOSTNAME:destination.user.domain}"
        CISCO_USER: "%{USERNAME:destination.user.name}"
        CISCO_DOMAIN: (LOCAL\\)?(%{HOSTNAME:destination.user.domain}\\)?
      on_failure:
        - append:
            tag: append_error_message_c828d076
            field: error.message
            value: "fail-{{{ _ingest.on_failure_processor_tag }}}"
        - fail:
            tag: fail_b32a2b4d
            message: "Processor {{{ _ingest.on_failure_processor_type }}} with tag {{{ _ingest.on_failure_processor_tag }}} in pipeline {{{ _ingest.on_failure_pipeline }}} failed with message: {{{ _ingest.on_failure_message }}}"

  #
  # Normalize protocol names
  #
  - lowercase:
      tag: lowercase_network_transport_25502ef0
      field: "network.transport"
      ignore_failure: true
  - lowercase:
      tag: lowercase_network_protocol_d249a697
      field: "network.protocol"
      ignore_failure: true
  - lowercase:
      tag: lowercase_network_application_48360e31
      field: "network.application"
      ignore_failure: true
  - lowercase:
      tag: lowercase_file_type_eddbcf5b
      field: "file.type"
      ignore_failure: true
  - lowercase:
      tag: lowercase_network_direction_bee20ce0
      field: "network.direction"
      ignore_failure: true
  - lowercase:
      tag: lowercase_network_type_e98b3947
      field: "network.type"
      ignore_failure: true
  #
  # Populate network.iana_number from network.transport. Also does reverse
  # mapping in case network.transport contains the iana_number.
  #
  - script:
      tag: script_66543883
      if: "ctx.network?.transport != null"
      lang: painless
      params:
        icmp: 1
        igmp: 2
        ipv4: 4
        tcp: 6
        egp: 8
        igp: 9
        pup: 12
        udp: 17
        rdp: 27
        irtp: 28
        dccp: 33
        idpr: 35
        ipv6: 41
        ipv6-route: 43
        ipv6-frag: 44
        rsvp: 46
        gre: 47
        esp: 50
        ipv6-icmp: 58
        ipv6-nonxt: 59
        ipv6-opts: 60
      source: >
        def net = ctx.network;
        def iana = params[net.transport];
        if (iana != null) {
          net['iana_number'] = iana;
          return;
        }
        def reverse = new HashMap();
        def[] arr = new def[] { null };
        for (entry in params.entrySet()) {
          arr[0] = entry.getValue();
          reverse.put(String.format("%d", arr), entry.getKey());
        }
        def trans = reverse[net.transport];
        if (trans != null) {
          net['iana_number'] = net.transport;
          net['transport'] = trans;
        }
  #
  # Normalize event.outcome
  #
  - lowercase:
      tag: lowercase_event_outcome_eb9dfc47
      field: "event.outcome"
      ignore_missing: true
  - set:
      tag: set_event_outcome_0ee786ff
      field: "event.outcome"
      if: 'ctx.event?.outcome == "est-allowed"'
      value: success
  - set:
      tag: set_event_outcome_e69d9ed0
      field: "event.outcome"
      if: 'ctx.event?.outcome == "permitted"'
      value: success
  - set:
      tag: set_event_outcome_d77f39eb
      field: "event.outcome"
      if: 'ctx.event?.outcome == "allow"'
      value: success
  - set:
      tag: set_event_outcome_7940c8ce
      field: "event.outcome"
      if: 'ctx.event?.outcome == "denied"'
      value: failure
  - set:
      tag: set_event_outcome_d846c955
      field: "event.outcome"
      if: 'ctx.event?.outcome == "deny"'
      value: failure
  - set:
      tag: set_event_outcome_a17dcc31
      field: "event.outcome"
      if: 'ctx.event?.outcome == "dropped"'
      value: failure
  - set:
      tag: set_network_transport_f68fa9c9
      field: "network.transport"
      if: 'ctx.network?.transport == "icmpv6"'
      value: "ipv6-icmp"
  #
  # Convert numeric fields to integer or long, as output of dissect and kv processors is always a string
  #
  - convert:
      tag: convert_source_port_84300464
      field: source.port
      type: integer
      ignore_failure: true
      ignore_missing: true
  - convert:
      tag: convert_destination_port_fcc6107f
      field: destination.port
      type: integer
      ignore_failure: true
      ignore_missing: true
  - convert:
      tag: convert_source_bytes_76a08ffa
      field: source.bytes
      type: long
      ignore_failure: true
      ignore_missing: true
  - convert:
      tag: convert_destination_bytes_a4f751f1
      field: destination.bytes
      type: long
      ignore_failure: true
      ignore_missing: true
  - convert:
      tag: convert_network_bytes_0331925b
      field: network.bytes
      type: long
      ignore_failure: true
      ignore_missing: true
  - convert:
      tag: convert_source_packets_b6ed0bec
      field: source.packets
      type: integer
      ignore_failure: true
      ignore_missing: true
  - convert:
      tag: convert_destination_packets_b05e4229
      field: destination.packets
      type: integer
      ignore_failure: true
      ignore_missing: true
  - convert:
      tag: convert__temp__cisco_mapped_source_port_3bc23b9e
      field: _temp_.cisco.mapped_source_port
      type: integer
      ignore_failure: true
      ignore_missing: true
  - convert:
      tag: convert__temp__cisco_mapped_destination_port_e77628cb
      field: _temp_.cisco.mapped_destination_port
      type: integer
      ignore_failure: true
      ignore_missing: true
  - convert:
      tag: convert__temp__cisco_icmp_code_d372a55a
      field: _temp_.cisco.icmp_code
      type: integer
      ignore_failure: true
      ignore_missing: true
  - convert:
      tag: convert__temp__cisco_icmp_type_d845b17f
      field: _temp_.cisco.icmp_type
      type: integer
      ignore_failure: true
      ignore_missing: true
  - convert:
      tag: convert_http_response_status_code_d42dd79a
      field: http.response.status_code
      type: integer
      ignore_failure: true
  - convert:
      tag: convert_file_size_5671cd5a
      field: file.size
      type: integer
      ignore_failure: true
  - convert:
      tag: convert_network_iana_number_7aa7bdd4
      field: network.iana_number
      type: string
      ignore_failure: true
      ignore_missing: true
  - convert:
      tag: convert_sip_to_uri_port_07c9c1eb
      field: sip.to.uri.port
      type: integer
      ignore_failure: true
  #
  # Assign ECS .ip fields from .address is a valid IP address is found,
  # otherwise set .domain field.
  #
  - grok:
      tag: grok_source_address_8b8ee91d
      field: source.address
      patterns:
        - "^(?:%{IP:source.ip}|%{GREEDYDATA:source.domain})$"
      ignore_failure: true
  - grok:
      tag: grok_destination_address_c89a6b50
      field: destination.address
      patterns:
        - "^(?:%{IP:destination.ip}|%{GREEDYDATA:destination.domain})$"
      ignore_failure: true
  - grok:
      tag: grok_client_address_fc87f583
      field: client.address
      patterns:
        - "^(?:%{IP:client.ip}|%{GREEDYDATA:client.domain})$"
      ignore_failure: true
  - grok:
      tag: grok_server_address_f7b0a23f
      field: server.address
      patterns:
        - "^(?:%{IP:server.ip}|%{GREEDYDATA:server.domain})$"
      ignore_failure: true
  #
  # Geolocation for source and destination addresses
  #
  - geoip:
      tag: geoip_source_ip_to_source_geo_da2e41b2
      field: "source.ip"
      target_field: "source.geo"
      ignore_missing: true
  - geoip:
      tag: geoip_destination_ip_to_destination_geo_ab5e2968
      field: "destination.ip"
      target_field: "destination.geo"
      ignore_missing: true
  #
  # IP Autonomous System (AS) Lookup
  #
  - geoip:
      tag: geoip_source_ip_to_source_as_28d69883
      database_file: GeoLite2-ASN.mmdb
      field: source.ip
      target_field: source.as
      properties:
        - asn
        - organization_name
      ignore_missing: true
  - geoip:
      tag: geoip_destination_ip_to_destination_as_8a007787
      database_file: GeoLite2-ASN.mmdb
      field: destination.ip
      target_field: destination.as
      properties:
        - asn
        - organization_name
      ignore_missing: true
  - rename:
      tag: rename_source_as_asn_to_source_as_number_a917047d
      field: source.as.asn
      target_field: source.as.number
      ignore_missing: true
  - rename:
      tag: rename_source_as_organization_name_to_source_as_organization_name_f1362d0b
      field: source.as.organization_name
      target_field: source.as.organization.name
      ignore_missing: true
  - rename:
      tag: rename_destination_as_asn_to_destination_as_number_3b459fcd
      field: destination.as.asn
      target_field: destination.as.number
      ignore_missing: true
  - rename:
      tag: rename_destination_as_organization_name_to_destination_as_organization_name_814bd459
      field: destination.as.organization_name
      target_field: destination.as.organization.name
      ignore_missing: true
  #
  # Set mapped_{src|dst}_ip fields only if they consist of a valid IP address.
  #
  - grok:
      tag: grok__temp__natsrcip_b3c200b0
      field: _temp_.natsrcip
      patterns:
        - "^(?:%{IP:_temp_.cisco.mapped_source_ip}|%{GREEDYDATA:_temp_.cisco.mapped_source_host})$"
      ignore_failure: true
  - grok:
      tag: grok__temp__natdstip_c82c5519
      field: _temp_.natdstip
      patterns:
        - "^(?:%{IP:_temp_.cisco.mapped_destination_ip}|%{GREEDYDATA:_temp_.cisco.mapped_destination_host})$"
      ignore_failure: true
  #
  # NAT fields
  #
  # The firewall always populates mapped ip and port even if there was no NAT.
  # This populates both nat.ip and nat.port only when some translation is done.
  # Fills nat.ip and nat.port even when only the ip or port changed.
  - set:
      tag: set_source_nat_ip_74fb14cd
      field: source.nat.ip
      value: "{{{_temp_.cisco.mapped_source_ip}}}"
      if: "ctx._temp_?.cisco?.mapped_source_ip != ctx.source?.ip"
      ignore_empty_value: true
  - convert:
      tag: convert_source_nat_ip_0f3c4387
      field: source.nat.ip
      type: ip
      ignore_missing: true
  - set:
      tag: set_source_nat_port_d5e04275
      field: source.nat.port
      value: "{{{_temp_.cisco.mapped_source_port}}}"
      if: "ctx._temp_?.cisco?.mapped_source_port != ctx.source?.port"
      ignore_empty_value: true
  - convert:
      tag: convert_source_nat_port_a9cad0ec
      field: source.nat.port
      type: long
      ignore_missing: true
  - set:
      tag: set_destination_nat_ip_08825da6
      field: destination.nat.ip
      value: "{{{_temp_.cisco.mapped_destination_ip}}}"
      if: "ctx._temp_?.cisco.mapped_destination_ip != ctx.destination?.ip"
      ignore_empty_value: true
  - convert:
      tag: convert_destination_nat_ip_79b6561e
      field: destination.nat.ip
      type: ip
      ignore_missing: true
  - set:
      tag: set_destination_nat_port_8b078cd3
      field: destination.nat.port
      value: "{{{_temp_.cisco.mapped_destination_port}}}"
      if: "ctx._temp_?.cisco?.mapped_destination_port != ctx.destination?.port"
      ignore_empty_value: true
  - convert:
      tag: convert_destination_nat_port_11e2f6c5
      field: destination.nat.port
      type: long
      ignore_missing: true
  - convert:
      tag: convert__temp__cisco_effective_mtu_222882a3
      if: "ctx._temp_?.cisco?.effective_mtu != null"
      field: _temp_.cisco.effective_mtu
      type: long
  #
  # Zone-based Network Directionality
  #
  # If external and internal zones are specified and our ingress/egress zones are
  # populated, then we can classify traffic directionality based off of our defined
  # zones rather than the logs.
  - set:
      tag: set_network_direction_c506c84d
      field: network.direction
      value: inbound
      if: >
        ctx._temp_?.external_zones != null &&
        ctx._temp_?.internal_zones != null &&
        ctx.observer?.ingress?.zone != null &&
        ctx.observer?.egress?.zone != null &&
        ctx._temp_.external_zones.contains(ctx.observer.ingress.zone) &&
        ctx._temp_.internal_zones.contains(ctx.observer.egress.zone)
  - set:
      tag: set_network_direction_3a48d62a
      field: network.direction
      value: outbound
      if: >
        ctx._temp_?.external_zones != null &&
        ctx._temp_?.internal_zones != null &&
        ctx.observer?.ingress?.zone != null &&
        ctx.observer?.egress?.zone != null &&
        ctx._temp_.external_zones.contains(ctx.observer.egress.zone) &&
        ctx._temp_.internal_zones.contains(ctx.observer.ingress.zone)
  - set:
      tag: set_network_direction_15edfcb3
      field: network.direction
      value: internal
      if: >
        ctx._temp_?.external_zones != null &&
        ctx._temp_?.internal_zones != null &&
        ctx.observer?.ingress?.zone != null &&
        ctx.observer?.egress?.zone != null &&
        ctx._temp_.internal_zones.contains(ctx.observer.egress.zone) &&
        ctx._temp_.internal_zones.contains(ctx.observer.ingress.zone)
  - set:
      tag: set_network_direction_060c3e89
      field: network.direction
      value: external
      if: >
        ctx._temp_?.external_zones != null &&
        ctx._temp_?.internal_zones != null &&
        ctx.observer?.ingress?.zone != null &&
        ctx.observer?.egress?.zone != null &&
        ctx._temp_.external_zones.contains(ctx.observer.egress.zone) &&
        ctx._temp_.external_zones.contains(ctx.observer.ingress.zone)
  - set:
      tag: set_network_direction_6acde5b1
      field: network.direction
      value: unknown
      if: >
        ctx._temp_?.external_zones != null &&
        ctx._temp_?.internal_zones != null &&
        ctx.observer?.egress?.zone != null &&
        ctx.observer?.ingress?.zone != null &&
        (
          (
            !ctx._temp_.external_zones.contains(ctx.observer.egress.zone) &&
            !ctx._temp_.internal_zones.contains(ctx.observer.egress.zone)
          ) ||
          (
            !ctx._temp_.external_zones.contains(ctx.observer.ingress.zone) &&
            !ctx._temp_.internal_zones.contains(ctx.observer.ingress.zone)
          )
        )
  #
  # Network Directionality when zones are not configured.
  #
  # Requires Integration option "private_is_internal" (defaults to True)
  #
  - script:
      tag: script_53fa3ccb
      description: Calculate network.direction if zones are not configured
      lang: painless
      if: >
        ctx.tags?.contains('private_is_internal') == true &&
        ctx.source?.ip != null &&
        ctx.destination?.ip != null &&
        (ctx._temp_?.external_zones == null || ctx._temp_?.internal_zones == null)
      source: |
        boolean isPrivateCIDR(def ip) {
          CIDR class_a_network = new CIDR('10.0.0.0/8');
          CIDR class_b_network = new CIDR('172.16.0.0/12');
          CIDR class_c_network = new CIDR('192.168.0.0/16');

          try {
            return class_a_network.contains(ip) || class_b_network.contains(ip) || class_c_network.contains(ip);
          } catch (IllegalArgumentException e) {
            return false;
          }
        }
        try {
          if (ctx.network == null) {
            Map map = new HashMap();
            ctx.put('network', map);
          }

          if (!isPrivateCIDR(ctx.source.ip) && isPrivateCIDR(ctx.destination.ip)) {
            ctx.network.direction = 'inbound';
          } else if (isPrivateCIDR(ctx.source.ip) && !isPrivateCIDR(ctx.destination.ip)) {
            ctx.network.direction = 'outbound';
          } else if (isPrivateCIDR(ctx.source.ip) && isPrivateCIDR(ctx.destination.ip)) {
            ctx.network.direction = 'internal';
          } else if (!isPrivateCIDR(ctx.source.ip) && !isPrivateCIDR(ctx.destination.ip)) {
            ctx.network.direction = 'external';
          } else {
            ctx.network.direction = 'unknown';
          }
        }
        catch (Exception e) {
          ctx.network.direction = null;
        }

  - set:
      tag: set__temp__url_domain_e921c493
      field: _temp_.url_domain
      value: "{{{url.domain}}}"
      ignore_failure: true
      if: ctx.url?.domain != null

  - uri_parts:
      tag: uri_parts_url_original_c5d45689
      field: url.original
      ignore_failure: true
      if: ctx.url?.original != null
  - append:
      tag: append_url_domain_0992c817
      field: url.domain
      value: "{{{_temp_.url_domain}}}"
      ignore_failure: true
      allow_duplicates: false
      if: ctx._temp_?.url_domain != null

  #
  # Populate ECS event.code
  #
  - rename:
      tag: rename__temp__cisco_message_id_to_event_code_77cf88fd
      field: _temp_.cisco.message_id
      target_field: event.code
      ignore_failure: true
  - remove:
      tag: remove_9e18eb53
      field:
        - _temp_.cisco.message_id
        - event.code
      if: 'ctx._temp_.cisco.message_id == ""'
      ignore_failure: true

  #
  # Populate ECS dns
  #
  - registered_domain:
      tag: registered_domain_dns_question_name_to_dns_question_24868ff9
      field: dns.question.name
      target_field: dns.question
      ignore_missing: true
      ignore_failure: true
  - remove:
      tag: remove_dns_question_domain_3403bb7d
      field: dns.question.domain
      ignore_missing: true

  # Define ECS Host and Device fields from Cisco ISE pxGrid Endpoint Profile data
  - remove:
        tag: remove__temp__host_type_184c15cf
        field: _temp_.host.type
        if: "ctx._temp_?.host?.type == 'Invalid ID'"
  - gsub:
        tag: gsub__temp__host_type_bdc12a47
        field: _temp_.host.type
        pattern: "Device"
        replacement: " "
        if: "ctx._temp_?.host?.type != null"
  - gsub:
        tag: gsub__temp__host_type_e2b660f2
        field: _temp_.host.type
        pattern: "^.*Macintosh-Workstation"
        replacement: "Macintosh:Mac"
        if: "ctx._temp_?.host?.type != null"
  - gsub:
        tag: gsub__temp__host_type_22a5ec73
        field: _temp_.host.type
        pattern: "^.*Microsoft-Workstation"
        replacement: "Microsoft:Microsoft"
        if: "ctx._temp_?.host?.type != null"
  - gsub:
        tag: gsub__temp__host_type_8d5c7bfa
        field: _temp_.host.type
        pattern: "^.*ChromeBook-Workstation"
        replacement: "ChromeBook:ChromeBook"
        if: "ctx._temp_?.host?.type != null"
  - gsub:
        tag: gsub__temp__host_type_f805fb20
        field: _temp_.host.type
        pattern: "(?:Workstation|[-_])"
        replacement: " "
        if: "ctx._temp_?.host?.type != null"
  - csv:
      tag: csv__temp__host_type_182fc074
      field: _temp_.host.type
      target_fields:
        - device.manufacturer
        - host.type
        - device.model.name
        - host.os.full
      separator: ":"
      if: "ctx._temp_?.host?.type != null"
  - trim:
      tag: trim_device_manufacturer_6933cd45
      field: device.manufacturer
      if: "ctx.device?.manufacturer != null"
  - trim:
      tag: trim_device_model_name_d9ef67ee
      field: device.model.name
      if: "ctx.device?.model?.name != null"
  - trim:
      tag: trim_host_type_8e01ca3d
      field: host.type
      if: "ctx.host?.type != null"
  - trim:
      tag: trim_host_os_full_961c504e
      field: host.os.full
      if: "ctx.host?.os?.full != null"

  #
  # Copy _temp_.cisco to its final destination, cisco.asa or cisco.ftd.
  #
  - rename:
      tag: rename__temp__cisco_to_cisco_ftd_5d520ec6
      field: _temp_.cisco
      target_field: "cisco.ftd"
      ignore_failure: true
  #
  # Remove temporary fields
  #
  - remove:
      tag: remove__temp__fc21405e
      field: _temp_
      ignore_missing: true
  #
  # Rename some 7.x fields
  #
  - rename:
      tag: rename_cisco_ftd_list_id_to_cisco_ftd_rule_name_c282ac18
      field: cisco.ftd.list_id
      target_field: cisco.ftd.rule_name
      ignore_missing: true
  # ECS categorization
  - script:
      tag: script_c697f75a
      lang: painless
      params:
        connection-finished:
          kind: event
          category:
            - network
          type:
            - connection
            - end
        connection-started:
          kind: event
          category:
            - network
          type:
            - connection
            - start
        file-detected:
          kind: event
          category:
            - file
          type:
            - info
        firewall-rule:
          kind: event
          category:
            - network
          type:
            - info
        flow-creation:
          kind: event
          category:
            - network
          type:
            - connection
            - start
        flow-expiration:
          kind: event
          category:
            - network
          type:
            - connection
            - end
        intrusion-detected:
          kind: alert
          category:
            - intrusion_detection
          type:
            - info
        malware-detected:
          kind: event
          category:
            - malware
          type:
            - info
        bypass:
          kind: event
          category:
            - network
          type:
            - info
        error:
          kind: event
          outcome: failure
          category:
            - network
          type:
            - info
            - end
        deleted:
          kind: event
          category:
            - network
          type:
            - info
            - end
        creation:
          kind: event
          category:
            - network
          type:
            - info
            - connection
            - start
      source: >-
        if (ctx.event?.action == null || !params.containsKey(ctx.event.action)) {
          return;
        }
        ctx.event.kind = params.get(ctx.event.action).get('kind');
        ctx.event.category = params.get(ctx.event.action).get('category').clone();
        ctx.event.type = params.get(ctx.event.action).get('type').clone();
        if (ctx.event?.outcome == null) {
          return;
        }
        if (ctx.event.category.contains('network') || ctx.event.category.contains('intrusion_detection')) {
          if (ctx.event.outcome == 'success') {
            ctx.event.type.add('allowed');
          }
          if (ctx.event.outcome == 'failure') {
            ctx.event.type.add('denied');
          }
          if (ctx.event.outcome == 'trust') {
            ctx.event.outcome = 'success';
            ctx.event.type.add('allowed');
          }
          if (ctx.event.outcome == 'block') {
            ctx.event.outcome = 'success';
            ctx.event.type.add('denied');
          }
          if (ctx.event.outcome == 'block with reset') {
            ctx.event.outcome = 'success';
            ctx.event.type.add('denied');
          }
          if (ctx.event.outcome == 'domain not found') {
            ctx.event.outcome = 'success';
            ctx.event.type.add('denied');
          }
          if (ctx.event.outcome == 'monitor') {
            ctx.event.outcome = 'success';
          }
          if (ctx.event.outcome == 'monitored') {
            ctx.event.category.add('intrusion_detection');
            ctx.event.outcome = 'success';
          }
          if (ctx.event.outcome == 'pass') {
            ctx.event.outcome = 'success';
            ctx.event.type.add('allowed');
          }
        }
  # Malware event kind is classified as alert when sha_disposition is "Malware", "Custom Detection" not for other cases.
  - set:
      tag: set_event_kind_0d467c5d
      if: 'ctx.event?.code == "430005" && ["Malware", "Custom Detection"].contains(ctx.cisco.ftd.security.sha_disposition)'
      field: event.kind
      value: alert
  - append:
      tag: append_event_category_2567a2c0
      if: 'ctx.event?.code == "430005" && !["Malware", "Custom Detection"].contains(ctx.cisco.ftd.security.sha_disposition)'
      field: event.category
      value: file

  # Remove user.name if FTD reports "Not Found" or "No Authentication Required".
  - remove:
      tag: remove_8ec81543
      field:
        - user.id
        - user.name
      if: ctx.user?.name == 'Not Found' || ctx.user?.name == 'No Authentication Required'

  # Remove custom domain identifier from FTD events.
  - grok:
      tag: grok_user_name_bde43d8d
      field: user.name
      patterns:
        - "(?:%{DATA}\\\\)?%{GREEDYDATA:user.name}"
      if: ctx.user?.name?.contains('\\') == true && ["430001", "430002", "430003", "430004", "430005", ""].contains(ctx.event?.code)

  # Set user.name if only destination.user.name is set.
  - set:
      tag: set_user_name_9ce9053b
      description: copy destination.user.name to user.name if it is not set
      field: user.name
      value: "{{{destination.user.name}}}"
      ignore_empty_value: true
      if: ctx.user?.name == null

  # Remove user field if present and empty
  - remove:
      tag: remove_c1fa188a
      field:
        - user
      if: ctx.user instanceof Map && ctx.user.size() == 0
      ignore_failure: true

  # Define ECS rule fields
  - set:
      tag: set_rule_name_08307892
      field: rule.name
      copy_from: cisco.ftd.security_event.access_control_rule_name
      if: ctx.cisco?.ftd?.security_event?.access_control_rule_name != null

  - set:
      tag: set_rule_ruleset_35670dfd
      field: rule.ruleset
      copy_from: cisco.ftd.security_event.ac_policy
      if: ctx.cisco?.ftd?.security_event?.ac_policy != null

  - set:
      tag: set_rule_ruleset_f21e7c38
      field: rule.ruleset
      copy_from: cisco.ftd.security.intrusion_policy
      if: ctx.rule?.ruleset == null && ctx.cisco?.ftd?.security?.intrusion_policy != null

  - set:
      tag: set_rule_ruleset_54b90b88
      field: rule.ruleset
      copy_from: cisco.ftd.security_event.file_policy
      if: ctx.rule?.ruleset == null && ctx.cisco?.ftd?.security_event?.file_policy != null

  # Configures observer fields with a copy from cisco and host fields. Later on these might replace host.hostname.
  - set:
      tag: set_observer_hostname_f91e0258
      field: observer.hostname
      value: "{{{ host.hostname }}}"
      ignore_empty_value: true
  - set:
      tag: set_observer_vendor_9f64bbe1
      field: observer.vendor
      value: "Cisco"
      ignore_empty_value: true
  - set:
      tag: set_observer_type_665792fa
      field: observer.type
      value: "idps"
      ignore_empty_value: true
  - set:
      tag: set_observer_product_75c9b9fb
      field: observer.product
      value: "ftd"
      ignore_empty_value: true
  - set:
      tag: set_observer_egress_interface_name_eed72a68
      field: observer.egress.interface.name
      value: "{{{ cisco.ftd.destination_interface }}}"
      ignore_empty_value: true
  - set:
      tag: set_observer_ingress_interface_name_5445d42f
      field: observer.ingress.interface.name
      value: "{{{ cisco.ftd.source_interface }}}"
      ignore_empty_value: true
  - append:
      tag: append_related_ip_8121c591
      field: related.ip
      value: "{{{source.ip}}}"
      if: "ctx.source?.ip != null"
      allow_duplicates: false
  - append:
      tag: append_related_ip_53b62ed8
      field: related.ip
      value: "{{{source.nat.ip}}}"
      if: "ctx.source?.nat?.ip != null"
      allow_duplicates: false
  - append:
      tag: append_related_ip_c1a6356b
      field: related.ip
      value: "{{{destination.ip}}}"
      if: "ctx.destination?.ip != null"
      allow_duplicates: false
  - append:
      tag: append_related_ip_6a388074
      field: related.ip
      value: "{{{destination.nat.ip}}}"
      if: "ctx.destination?.nat?.ip != null"
      allow_duplicates: false
  - append:
      tag: append_related_ip_cfc2aa6f
      field: related.ip
      value: '{{{cisco.ftd.security_event.encrypt_peer_ip}}}'
      if: ctx.cisco?.ftd?.security_event?.encrypt_peer_ip != null
      allow_duplicates: false
  - append:
      tag: append_related_user_1c6fb0ea
      field: related.user
      value: "{{{user.name}}}"
      if: ctx.user?.name != null && ctx.user.name != ''
      allow_duplicates: false
  - append:
      tag: append_related_user_6a92751c
      field: related.user
      value: "{{{server.user.name}}}"
      if: ctx.server?.user?.name != null && ctx.server.user.name != ''
      allow_duplicates: false
  - append:
      tag: append_related_user_8285e12e
      field: related.user
      value: "{{{source.user.name}}}"
      if: ctx.source?.user?.name != null && ctx.source.user.name != ''
      allow_duplicates: false
  - append:
      tag: append_related_user_d9a51d5b
      field: related.user
      value: "{{{destination.user.name}}}"
      if: ctx.destination?.user?.name != null && ctx.destination.user.name != ''
      allow_duplicates: false
  - append:
      tag: append_related_hash_017aef51
      field: related.hash
      value: "{{{file.hash.sha256}}}"
      if: "ctx.file?.hash?.sha256 != null"
      allow_duplicates: false
  - append:
      tag: append_related_hosts_2091d4c1
      field: related.hosts
      value: "{{{host.hostname}}}"
      if: ctx.host?.hostname != null && ctx.host.hostname != ''
      allow_duplicates: false
  - append:
      tag: append_related_hosts_b31f7669
      field: related.hosts
      value: "{{{observer.hostname}}}"
      if: ctx.observer?.hostname != null && ctx.observer.hostname != ''
      allow_duplicates: false
  - append:
      tag: append_related_hosts_76b993a4
      field: related.hosts
      value: "{{{destination.domain}}}"
      if: ctx.destination?.domain != null && ctx.destination.domain != ''
      allow_duplicates: false
  - append:
      tag: append_related_hosts_d5331533
      field: related.hosts
      value: "{{{source.domain}}}"
      if: ctx.source?.domain != null && ctx.source.domain != ''
      allow_duplicates: false
  - append:
      tag: append_related_hosts_de5f8d4b
      field: related.hosts
      value: "{{{source.user.domain}}}"
      if: ctx.source?.user?.domain != null && ctx.source.user.domain != ''
      allow_duplicates: false
  - append:
      tag: append_related_hosts_c2d08554
      field: related.hosts
      value: "{{{destination.user.domain}}}"
      if: ctx.destination?.user?.domain != null && ctx.destination.user.domain != ''
      allow_duplicates: false
  - script:
      tag: script_63456991
      lang: painless
      description: This script processor iterates over the whole document to remove fields with null or empty values.
      source: |
        boolean dropEmptyFields(Object object) {
          if (object == null || object == '') {
            return true;
          } else if (object instanceof Map) {
            ((Map) object).values().removeIf(value -> dropEmptyFields(value));
            return (((Map) object).size() == 0);
          } else if (object instanceof List) {
            ((List) object).removeIf(value -> dropEmptyFields(value));
            return (((List) object).length == 0);
          }
          return false;
        }
        dropEmptyFields(ctx);
  - community_id:
      tag: community_id_99f56bc8
      ignore_missing: true
      ignore_failure: true
on_failure:
  # Copy any fields under _temp_.cisco to its final destination. Those can help
  # with diagnosing the failure.
  - rename:
      field: _temp_.cisco
      target_field: "cisco.ftd"
      ignore_failure: true
  # Remove _temp_/_conf to avoid adding a lot of unnecessary fields to the index.
  - remove:
      field:
        - _temp_
        - _conf
      ignore_missing: true
  - set:
      field: event.kind
      value: pipeline_error
  - append:
      field: error.message
      value: >-
        Processor '{{{ _ingest.on_failure_processor_type }}}'
        {{#_ingest.on_failure_processor_tag}}with tag '{{{ _ingest.on_failure_processor_tag }}}'
        {{/_ingest.on_failure_processor_tag}}in pipeline '{{{ _ingest.pipeline }}}'
        failed with message '{{{ _ingest.on_failure_message }}}'
