---
description: "Pipeline for CloudFront standard access logs"

processors:
  - set:
      field: ecs.version
      value: '8.11.0'
  - set:
      field: event.kind
      value: event
  - set:
      field: event.category
      value: ["web"]
  - append:
      field: event.type
      value: ["access"]
  - set:
      field: cloud.provider
      value: aws
  - rename:
      field: message
      target_field: event.original
      ignore_missing: true
      if: 'ctx.event?.original == null'
      description: 'Renames the original `message` field to `event.original` to store a copy of the original message. The `event.original` field is not touched if the document already has one; it may happen when Logstash sends the document.'
  - remove:
      field: message
      ignore_missing: true
      if: 'ctx.event?.original != null'
      description: 'The `message` field is no longer required if the document has an `event.original` field.'
  - drop:
      if: "ctx?.event?.original?.startsWith('#')"
      description: "Drop if logline contains header(s), which startswith `#`"

  # pipeline custom csv...

  - csv:
      description: Parse cloudfront csv row
      field: event.original
      separator: "\t"
      target_fields:
      - _tmp.date                                   # date
      - _tmp.time                                   # time
      - aws.cloudfront.edge_location                # x-edge-location
      - http.response.bytes                         # sc-bytes
      - source.address                              # c-ip
      - http.request.method                         # cs-method
      - aws.cloudfront.domain                       # cs(Host)
      - url.path                                    # cs-uri-stem
      - http.response.status_code                   # cs-status
      - http.request.referrer                       # cs(Referer)
      - _tmp.user_agent                             # cs(User-Agents)
      - url.query                                   # cs-uri-query
      - aws.cloudfront.cookies                      # cs(Cookie)
      - aws.cloudfront.edge_result_type             # x-edge-result-type
      - http.request.id                             # x-edge-request-id
      - destination.address                         # x-host-header
      - network.protocol                            # cs-protocol
      - http.request.bytes                          # cs-bytes
      - event.duration                              # time-taken
      - _tmp.forwarded_ip                           # x-forwarded-for
      - _tmp.ssl_protocol                           # ssl-protocol
      - tls.cipher                                  # ssl-cipher
      - aws.cloudfront.edge_response_result_type    # x-edge-response-result-type
      - _tmp.protocol                               # cs-protocol-version
      - aws.cloudfront.fle_status                   # fle-status
      - aws.cloudfront.fle_encrypted_fields         # fle-encrypted-fields
      - source.port                                 # c-port
      - aws.cloudfront.time_to_first_byte           # time-to-first-byte
      - aws.cloudfront.edge_detailed_result_type    # x-edge-detailed-result-type
      - http.response.mime_type                      # sc-content-type
      - http.response.body.bytes                    # sc-content-len
      - aws.cloudfront.range_start                  # sc-range-start
      - aws.cloudfront.range_end                    # sc-range-end
  - set:
      field: _tmp.time
      value: "{{ _tmp.date }} {{ _tmp.time }}"
  - date:
      field: _tmp.time
      target_field: '@timestamp'
      ignore_failure: true
      formats:
        - yyyy-MM-dd HH:mm:ss
  - convert:
      field: http.response.bytes
      type: long
      ignore_missing: true
  - convert:
      field: http.response.status_code
      type: long
      ignore_missing: true
  - urldecode:
      field: _tmp.user_agent
      ignore_missing: true
  - remove:
      field: uri.query
      if: "ctx?.uri?.query != null && ctx.uri.query == '-'"
  - user_agent:
      field: _tmp.user_agent
      target_field: user_agent
      ignore_missing: true
  - remove:
      field: aws.cloudfront.cookies
      if: "ctx?.aws?.cloudfront?.cookies != null && ctx.aws.cloudfront.cookies == '-'"
  - convert:
      field: http.request.bytes
      type: long
      ignore_missing: true
  - script:
      lang: painless
      if: ctx.event?.duration != null
      params:
        S_TO_NS: 1000000000
      source: >-
        ctx.event.duration = (Long)(Float.parseFloat(ctx.event.duration) * params.S_TO_NS);
  - remove:
      field: _tmp.forwarded_ip
      if: "ctx?._tmp?.forwarded_ip != null && ctx?._tmp?.forwarded_ip == '-'"
  - lowercase:
      field: _tmp.forwarded_ip
      ignore_missing: true
  - gsub:
      description: In rare cases, the field contains hex encoded whitspaces (\20). We replace them by whitespaces again to not break parsing.
      field: _tmp.forwarded_ip
      pattern: "\\\\x20"
      replacement: " "
      ignore_missing: true
  - split:
      field: _tmp.forwarded_ip
      separator: ',\s*'
      ignore_missing: true
  - convert:
      description: Creates a target field containing valid ip's if ALL values are valid ip's.
      field: _tmp.forwarded_ip
      target_field: _tmp.forwarded_ip_converted
      type: ip
      ignore_missing: true
      tag: convert_forwarded_ip
      on_failure:
        - append:
            description: Add convert failure to error message and continue.
            field: error.message
            value: 'Processor with tag {{ _ingest.on_failure_processor_tag }} failed with message {{ _ingest.on_failure_message }}'
        - remove:
            field: _tmp.forwarded_ip
  - set:
      field: related.ip
      copy_from: _tmp.forwarded_ip_converted
      ignore_empty_value: true
  - set:
      field: network.forwarded_ip
      copy_from: _tmp.forwarded_ip_converted
      ignore_empty_value: true
  - script:
      lang: painless
      description: Set tls protocol and version
      if: "ctx?._tmp?.ssl_protocol != null && ctx._tmp.ssl_protocol != '-'"
      source: |
        String ssl_protocol = ctx?._tmp?.ssl_protocol;
        String[] protocol_version = ssl_protocol.splitOnToken('v');

        if (!ctx.containsKey('tls')) {
          ctx['tls'] = new HashMap();
        }
        ctx.tls.version_protocol = protocol_version[0];
        ctx.tls.version          = protocol_version[1];
  - remove:
      field: tls.cipher
      if: "ctx?.tls?.cipher != null && ctx?.tls?.cipher == '-'"
  - dissect:
      field: _tmp.protocol
      pattern: "%{}/%{http.version}"
      ignore_failure: true
  - remove:
      field: aws.cloudfront.fle_status
      if: "ctx?.aws?.cloudfront?.fle_status != null && ctx.aws.cloudfront.fle_status == '-'"
  - remove:
      field: aws.cloudfront.fle_encrypted_fields
      if: "ctx?.aws?.cloudfront?.fle_encrypted_fields != null && ctx.aws.cloudfront.fle_encrypted_fields == '-'"
  - set:
      field: destination.domain
      copy_from: destination.address
      ignore_empty_value: true
  - convert:
      field: source.port
      type: long
      ignore_missing: true
  - convert:
      field: aws.cloudfront.time_to_first_byte
      type: float
      ignore_missing: true
  - remove:
      field: http.response.body.bytes
      if: "ctx?.http?.response?.body?.bytes != null && ctx?.http?.response?.body?.bytes == '-'"
  - convert:
      field: http.response.body.bytes
      type: long
      ignore_missing: true
  - remove:
      field: aws.cloudfront.range_start
      if: "ctx?.aws?.cloudfront?.range_start != null && ctx.aws.cloudfront.range_start == '-'"
  - remove:
      field: aws.cloudfront.range_end
      if: "ctx?.aws?.cloudfront?.range_end != null && ctx.aws.cloudfront.range_end == '-'"
  - script:
      lang: painless
      description: This script builds the `url.full` field out of the available `url.*` parts.
      source: |
        def full = "";
        if(ctx.network?.protocol != null && ctx.network?.protocol != "") {
            full += ctx.network.protocol+"://";
        }
        if(ctx.destination?.domain != null && ctx.destination?.domain != "") {
            full += ctx.destination.domain;
        }
        if(ctx.url?.path != null && ctx.url?.path != "") {
            full += ctx.url.path;
        }
        if(ctx.url?.query != null && ctx.url?.query != "") {
            full += "?"+ctx.url.query;
        }
        if(full != "") {
            ctx._tmp.url_full = full
        }
  - uri_parts:
      field: _tmp.url_full
      target_field: url
      keep_original: false
      ignore_missing: true
  - rename:
      field: _tmp.url_full
      target_field: url.full
      ignore_missing: true
  - registered_domain:
      field: url.domain
      target_field: url
      ignore_missing: true
  - convert:
      field: source.address
      target_field: source.ip
      type: ip
      ignore_missing: true
      ignore_failure: true
  - set:
      field: network.type
      value: ipv4
      if: 'ctx.source?.ip != null && ctx.source?.ip.contains(".")'
  - set:
      field: network.type
      value: ipv6
      if: 'ctx.source?.ip != null && ctx.source?.ip.contains(":")'
  # IP Geolocation Lookup
  - geoip:
      field: source.ip
      target_field: source.geo
      ignore_missing: true
  # IP Autonomous System (AS) Lookup
  - geoip:
      database_file: GeoLite2-ASN.mmdb
      field: source.ip
      target_field: source.as
      properties:
        - asn
        - organization_name
      ignore_missing: true
  - rename:
      field: source.as.asn
      target_field: source.as.number
      ignore_missing: true
  - rename:
      field: source.as.organization_name
      target_field: source.as.organization.name
      ignore_missing: true
  - append:
      field: related.ip
      value: "{{source.ip}}"
      if: ctx?.source?.ip != null
  - append:
      field: related.hosts
      value: "{{destination.domain}}"
      allow_duplicates: false
      if: ctx?.destination?.domain != null
  - append:
      field: related.hosts
      value: "{{aws.cloudfront.domain}}"
      allow_duplicates: false
      if: ctx?.aws?.cloudfront?.domain != null
  - set:
      field: event.id
      copy_from: http.request.id
      ignore_empty_value: true
  - set:
      field: event.outcome
      value: failure
      if: ctx?.http?.response?.status_code >= 400
  - set:
      field: event.outcome
      value: success
      if: ctx?.http?.response?.status_code < 400 && ctx.http?.response?.status_code > 000
  - set:
      field: event.outcome
      value: failure
      if: ctx?.http?.response?.status_code == 000
  - lowercase:
      field: tls.version_protocol
      ignore_missing: true
  - remove:
      field: _tmp
      ignore_missing: true
  - remove:
      field: event.original
      if: "ctx?.tags == null || !(ctx.tags.contains('preserve_original_event'))"
      ignore_failure: true
      ignore_missing: true
  - pipeline:
      name: '{{ IngestPipeline "ppbgdi" }}'
on_failure:
  - set:
      field: event.kind
      value: pipeline_error
  - append:
      field: error.message
      value: '{{ _ingest.on_failure_message }}'
