---
description: Pipeline for processing sample logs
processors:
  - json:
      field: event.original
      target_field: temp
  - foreach:
      field: temp.event
      ignore_missing: true
      processor:
        set:
          field: "event.{{ _ingest._key }}"
          value: "{{ _ingest._value }}"
  - remove:
      field: temp.event
      ignore_missing: true
  - set:
      field: "@timestamp"
      copy_from: event.created
  - convert:
      field: event.severity
      type: long
  - convert:
      field: event.duration
      type: float
      ignore_missing: true
  - script:
      description: Convert duration from seconds nanosecond
      source: |
        ctx.event.duration = (long)(ctx?.event?.duration * 1000000000)
      if: 'ctx?.event?.duration != null'
  - rename:
      field: temp.http
      target_field: http
      ignore_missing: true
  - script:
      description: lowercase http headers
      source: |
        if (ctx?.http?.request?.headers != null){
            Map request_headers = new HashMap();
            for (header in ctx.http.request.headers.entrySet()){
            request_headers.put(header.getKey().toLowerCase(), header.getValue());
            }
            ctx.http.request.headers = request_headers;
        }
        if (ctx?.http?.response?.headers != null){
            Map response_headers = new HashMap();
            for (header in ctx.http.response.headers.entrySet()){
            response_headers.put(header.getKey().toLowerCase(), header.getValue());
            }
            ctx.http.response.headers = response_headers;
        }
  - user_agent:
      field: http.request.headers.user-agent
      extract_device_type: true
      ignore_missing: true
  - remove:
      field: http.request.headers.user-agent
      ignore_missing: true
  - rename:
      field: http.response.headers.content-length
      target_field: http.response.bytes
      ignore_missing: true
  - convert:
      field: http.response.bytes
      type: long
      ignore_missing: true
  - rename:
      field: http.response.headers.content-type
      target_field: http.response.mime_type
      ignore_missing: true
  - remove:
      field: log
      ignore_missing: true
      if: 'ctx?.temp?.log != null'
      description: Replace entire log (e.g. from kubernetes) with app log information
  - rename:
      field: temp.log
      target_field: log
      ignore_missing: true
  - lowercase:
      field: log.level
      ignore_missing: true
  - remove:
      field: message
      ignore_missing: true
  - rename:
      field: temp.message
      target_field: message
      ignore_missing: true
  - rename:
      field: temp.process
      target_field: process
      ignore_missing: true
  - uri_parts:
      field: temp.url.original
      remove_if_successful: true
      ignore_missing: true
  - set:
      description: Override event.id with request.id if existing
      field: event.id
      copy_from: http.request.id
      override: true
      ignore_empty_value: true
  - remove:
      description: Remove request id to avoid redundancy
      field: http.request.id
      ignore_missing: true
  - set:
      description: Override event.id with request header if existing
      field: event.id
      copy_from: http.request.headers.x-amz-cf-id
      override: true
      ignore_empty_value: true
      if: 'ctx?.event?.id == null'
  - remove:
      description: Remove request header to avoid redundancy
      field: http.request.headers.x-amz-cf-id
      ignore_missing: true
  - set:
      description: Set event.id from pidTid
      field: event.id
      copy_from: temp.pidTid
      ignore_empty_value: true
      if: 'ctx?.event?.id == null'
  - remove:
      description: Remove pidTid to avoid overhead
      field: temp.pidTid
      ignore_missing: true

  # TODO: Is this always an IP addres or may be a host as well? Is it cf or the client?
  - rename:
      field: temp.request.remoteAddr
      target_field: source.address
      ignore_missing: true
  - grok:
      field: source.address
      patterns:
        - "^(%{IP:source.ip}|%{HOSTNAME:source.domain})(:%{POSINT:source.port})?"
      ecs_compatibility: v1
      ignore_missing: true
  - set:
      field: service
      copy_from: temp.service
      ignore_empty_value: true
      override: true
  - remove:
      field: temp.service
      ignore_missing: true
  - set:
      field: service.name
      copy_from: kubernetes.namespace_labels.service
      ignore_empty_value: true
      override: true
  - rename:
      field: temp.ppbgdi.app.api
      target_field: ppbgdi.app.api
      ignore_missing: true
  - set:
      field: ppbgdi.app.system
      copy_from: kubernetes.namespace_labels.system
      ignore_empty_value: true
  - rename:
      field: temp.ppbgdi.app.crs
      target_field: ppbgdi.app.crs
      ignore_missing: true
  - set:
      field: service.name
      copy_from: kubernetes.namespace_labels.service
      ignore_empty_value: true
  - set:
      field: service.environment
      copy_from: kubernetes.namespace_labels.env
      ignore_empty_value: true
  - set:
      field: data_stream.namespace
      copy_from: service.environment
      ignore_empty_value: true
      override: true

  # TODO: Set ip.address and or ip. domain.
  # TODO: Set related ip and related.domain

  - remove:
      description: Remove deprecated fields (old field structure)
      field:
        - temp.function
        - temp.level
        - temp.logger
        - temp.module
        - temp.request
        - temp.response
        - temp.time
        - temp.excInfo
      ignore_missing: true
on_failure:
- append:
    field: error.message
    value: '{{ _ingest.on_failure_message }}'

