---
description: Pipeline for parsing Akamai logs
processors:
- set:
    field: ecs.version
    value: 8.6.0
- rename:
    field: message
    target_field: event.original
- json:
    field: event.original
    target_field: json
- drop:
    if: ctx?.json?.offset != null
- set:
    field: observer.vendor
    value: akamai
- set:
    field: observer.type
    value: proxy
- date:
    field: json.httpMessage.start
    formats:
    - UNIX
    target_field: '@timestamp'
    timezone: UTC
- set:
    field: event.start
    copy_from: '@timestamp'
- rename:
    field: json.httpMessage.status
    ignore_missing: true
    target_field: http.response.status_code
- convert:
    field: http.response.status_code
    ignore_missing: true
    type: long
- rename:
    field: json.httpMessage.bytes
    ignore_missing: true
    target_field: http.response.bytes
- convert:
    field: http.response.bytes
    ignore_missing: true
    type: long
- rename:
    field: json.httpMessage.requestId
    ignore_missing: true
    target_field: http.request.id
- set:
    field: event.id
    copy_from: http.request.id
    ignore_empty_value: true
- fingerprint:
    fields:
        - http.request.id
    ignore_missing: true
    target_field: _id
- rename:
    field: json.httpMessage.method
    ignore_missing: true
    target_field: http.request.method
- rename:
    field: json.httpMessage.host
    ignore_missing: true
    target_field: url.domain
- urldecode:
    field: json.httpMessage.path
    ignore_missing: true
    target_field: url.path
- urldecode:
    field: json.httpMessage.query
    ignore_missing: true
    target_field: url.query
- rename:
    field: json.httpMessage.port
    ignore_missing: true
    target_field: url.port
- convert:
    field: url.port
    ignore_missing: true
    type: long
- urldecode:
    field: json.httpMessage.responseHeaders
    ignore_missing: true
    target_field: _tmp.response.headers
- kv:
    field: _tmp.response.headers
    field_split: '\r\n'
    ignore_missing: true
    target_field: akamai.siem.response.headers
    value_split: ': '
- urldecode:
    field: json.httpMessage.requestHeaders
    ignore_missing: true
    target_field: _tmp.request.headers
- kv:
    field: _tmp.request.headers
    field_split: '\r\n'
    ignore_missing: true
    target_field: akamai.siem.request.headers
    value_split: ': '
- script:
    description: This script builds the `url.full` field out of the available `url.*` parts.
    lang: painless
    source: |
        def full = "";
        if(ctx.url.scheme != null && ctx.url.scheme != "") {
            full += ctx.url.scheme+"://";
        }
        if(ctx.url.domain != null && ctx.url.domain != "") {
            full += ctx.url.domain;
        }
        if(ctx.json.httpMessage.path != null && ctx.json.httpMessage.path != "") {
            full += ctx.json.httpMessage.path;
        }
        if(ctx.json.httpMessage.query != null && ctx.json.httpMessage.query != "") {
            full += "?"+ctx.json.httpMessage.query;
        }
        if(full != "") {
            ctx.url.full = full
        }
- dissect:
    field: json.httpMessage.protocol
    ignore_failure: true
    pattern: '%{network.protocol}/%{http.version}'
- lowercase:
    field: network.protocol
    ignore_missing: true
- set:
    if: ctx?.network?.protocol != null && ctx?.network?.protocol == 'http'
    field: network.transport
    value: tcp
- dissect:
    field: json.httpMessage.tls
    ignore_failure: true
    ignore_missing: true
    pattern: '%{tls.version_protocol}v%{tls.version}'
- lowercase:
    field: tls.version_protocol
    ignore_missing: true
- rename:
    field: json.attackData.clientIP
    ignore_missing: true
    target_field: source.address
- convert:
    field: source.address
    ignore_failure: true
    ignore_missing: true
    target_field: source.ip
    type: ip
- geoip:
    field: source.ip
    ignore_missing: true
    target_field: source.geo
- rename:
    if: ctx?.source?.geo?.country_iso_code == null
    field: json.geo.country
    ignore_missing: true
    target_field: source.geo.country_iso_code
- set:
    if: ctx?.source?.geo?.region_iso_code == null
    field: source.geo.region_iso_code
    ignore_empty_value: true
    value: '{{json.geo.country}}-{{json.geo.regionCode}}'
- rename:
    if: ctx?.source?.geo?.city_name == null
    field: json.geo.city
    ignore_missing: true
    target_field: source.geo.city_name
- geoip:
    field: source.ip
    database_file: GeoLite2-ASN.mmdb
    ignore_missing: true
    properties:
    - asn
    - organization_name
    target_field: source.as
- rename:
    field: source.as.asn
    ignore_missing: true
    target_field: source.as.number
- convert:
    if: ctx?.source?.as?.number == null
    field: json.geo.asn
    ignore_missing: true
    target_field: source.as.number
    type: long
- rename:
    field: source.as.organization_name
    ignore_missing: true
    target_field: source.as.organization.name
## Attack Data
- urldecode:
    field: json.attackData.ruleActions
    ignore_missing: true
    target_field: json.attackData.ruleActions
- split:
    field: json.attackData.ruleActions
    preserve_trailing: true
    separator: ;
    target_field: json.attackData.ruleActions
- urldecode:
    field: json.attackData.ruleData
    ignore_missing: true
    target_field: json.attackData.ruleData
- split:
    field: json.attackData.ruleData
    preserve_trailing: true
    separator: ;
    target_field: json.attackData.ruleData
- urldecode:
    field: json.attackData.ruleMessages
    ignore_missing: true
    target_field: json.attackData.ruleMessages
- split:
    field: json.attackData.ruleMessages
    preserve_trailing: true
    separator: ;
    target_field: json.attackData.ruleMessages
- urldecode:
    field: json.attackData.ruleSelectors
    ignore_missing: true
    target_field: json.attackData.ruleSelectors
- split:
    field: json.attackData.ruleSelectors
    preserve_trailing: true
    separator: ;
    target_field: json.attackData.ruleSelectors
- urldecode:
    field: json.attackData.ruleTags
    ignore_missing: true
    target_field: json.attackData.ruleTags
- split:
    field: json.attackData.ruleTags
    preserve_trailing: true
    separator: ;
    target_field: json.attackData.ruleTags
- urldecode:
    field: json.attackData.ruleVersions
    ignore_missing: true
    target_field: json.attackData.ruleVersions
- split:
    field: json.attackData.ruleVersions
    preserve_trailing: true
    separator: ;
    target_field: json.attackData.ruleVersions
- urldecode:
    field: json.attackData.rules
    ignore_missing: true
    target_field: json.attackData.rules
- split:
    field: json.attackData.rules
    preserve_trailing: true
    separator: ;
    target_field: json.attackData.rules
- script:
    description: Base64 Decode the json.attackData.rule* fields
    lang: painless
    source: |
        ArrayList items = new ArrayList(["rules", "ruleActions", "ruleData", "ruleMessages", "ruleTags", "ruleSelectors", "ruleVersions"]);
        ArrayList rules_array = new ArrayList();
        ArrayList rule_actions = new ArrayList();
        ArrayList rule_tags = new ArrayList();
        for (def i = 0; i < ctx.json.attackData.rules.length; i++) {
            HashMap map = new HashMap();
            for (def j = 0; j < items.length; j++) {
                String key = items[j];
                if (i < ctx.json.attackData[key].length ) {
                    String value = ctx.json.attackData[key][i].replace(" ", "").decodeBase64();
                    map.put(key, value);
                    if (key == "ruleTags") {
                        rule_tags.add(value.toLowerCase());
                    } else if (key == "ruleActions") {
                        rule_actions.add(value.toLowerCase());
                    }
                }
            }
            rules_array.add(map);
        }
        ctx.akamai.siem.rules = rules_array;
        ctx._rule_actions = rule_actions;
        ctx._rule_tags = rule_tags;
- foreach:
    field: _rule_actions
    ignore_missing: true
    processor:
      append:
        field: akamai.siem.rule_actions
        allow_duplicates: false
        value: '{{{_ingest._value}}}'
- remove:
    field: _rule_actions
    ignore_missing: true
- foreach:
    field: _rule_tags
    ignore_missing: true
    processor:
      append:
        field: akamai.siem.rule_tags
        allow_duplicates: false
        value: '{{{_ingest._value}}}'
- remove:
    field: _rule_tags
    ignore_missing: true
- rename:
    field: json.attackData.configId
    ignore_missing: true
    target_field: akamai.siem.config_id
- rename:
    field: json.attackData.policyId
    ignore_missing: true
    target_field: akamai.siem.policy_id
- rename:
    field: json.attackData.policyId
    ignore_missing: true
    target_field: akamai.siem.policy_id
- rename:
    field: json.attackData.slowPostAction
    ignore_missing: true
    target_field: akamai.siem.slow_post_action
- convert:
    field: json.attackData.slowPostRate
    ignore_missing: true
    target_field: akamai.siem.slow_post_rate
    type: long
- rename:
    field: json.attackData.clientReputation
    ignore_missing: true
    target_field: akamai.siem.client_reputation
- rename:
    field: json.attackData.clientReputation
    ignore_missing: true
    target_field: akamai.siem.client_reputation
## Bot Data
- convert:
    field: json.botData.botScore
    ignore_missing: true
    target_field: akamai.siem.bot.score
    type: long
- convert:
    field: json.botData.responseSegment
    ignore_missing: true
    target_field: akamai.siem.bot.response_segment
    type: long
## Client Data
- rename:
    field: json.clientData.appBundleId
    ignore_missing: true
    target_field: akamai.siem.client_data.app_bundle_id
- rename:
    field: json.clientData.appVersion
    ignore_missing: true
    target_field: akamai.siem.client_data.app_version
- convert:
    field: json.clientData.telemetryType
    ignore_missing: true
    target_field: akamai.siem.client_data.telemetry_type
    type: long
- rename:
    field: json.clientData.sdkVersion
    ignore_missing: true
    target_field: akamai.siem.client_data.sdk_version
## User Risk Data
- rename:
    field: json.userRiskData.uuid
    ignore_missing: true
    target_field: akamai.siem.user_risk.uuid
- convert:
    field: json.userRiskData.status
    ignore_missing: true
    target_field: akamai.siem.user_risk.status
    type: long
- convert:
    field: json.userRiskData.score
    ignore_missing: true
    target_field: akamai.siem.user_risk.score
    type: long
- convert:
    field: json.userRiskData.allow
    ignore_missing: true
    target_field: akamai.siem.user_risk.allow
    type: long
- kv:
    field: json.userRiskData.risk
    field_split: '\|'
    ignore_missing: true
    target_field: akamai.siem.user_risk.risk
    value_split: ':'
- kv:
    field: json.userRiskData.trust
    field_split: '\|'
    ignore_missing: true
    target_field: akamai.siem.user_risk.trust
    value_split: ':'
- kv:
    field: json.userRiskData.general
    field_split: '\|'
    ignore_missing: true
    target_field: akamai.siem.user_risk.general
    value_split: ':'
- append:
    field: related.ip
    allow_duplicates: false
    value: '{{source.ip}}'
- set:
    field: client
    copy_from: source
- set:
    field: event.category
    value:
      - network
- set:
    field: event.kind
    value: event
- remove:
    field:
      - json
      - _tmp
    ignore_missing: true
- remove:
    if: ctx?.tags == null || !(ctx.tags.contains('preserve_original_event'))
    field: event.original
    ignore_failure: true
    ignore_missing: true
- script:
    description: This script processor iterates over the whole document to remove fields with null values.
    lang: painless
    source: |
      void handleMap(Map map) {
        for (def x : map.values()) {
          if (x instanceof Map) {
              handleMap(x);
          } else if (x instanceof List) {
              handleList(x);
          }
        }
        map.values().removeIf(v -> v == null || v == '' || (v instanceof Map && v.size() == 0) || (v instanceof List && v.size() == 0));
      }
      void handleList(List list) {
        for (def x : list) {
            if (x instanceof Map) {
                handleMap(x);
            } else if (x instanceof List) {
                handleList(x);
            }
        }
        list.removeIf(v -> v == null || v == '' || (v instanceof Map && v.size() == 0) || (v instanceof List && v.size() == 0));
      }
      handleMap(ctx);
on_failure:
  - set:
      field: error.message
      value: |-
        Processor "{{ _ingest.on_failure_processor_type }}" with tag "{{ _ingest.on_failure_processor_tag }}" in pipeline "{{ _ingest.on_failure_pipeline }}" failed with message "{{ _ingest.on_failure_message }}"
  - set:
      field: event.kind
      value: pipeline_error
