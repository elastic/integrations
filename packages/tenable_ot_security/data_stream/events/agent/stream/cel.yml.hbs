config_version: 2
interval: {{interval}}
{{#if enable_request_tracer}}
resource.tracer.filename: "../../logs/cel/http-request-trace-*.ndjson"
request.tracer.maxbackups: 5
{{/if}}
{{#if proxy_url}}
resource.proxy_url: {{proxy_url}}
{{/if}}
{{#if ssl}}
resource.ssl: {{ssl}}
{{/if}}
{{#if http_client_timeout}}
resource.timeout: {{http_client_timeout}}
{{/if}}
max_executions: {{max_executions}}
resource.url: {{api_host}}
 
state:
  want_more: false
  key: {{key}}
  batch_size: {{batch_size}}
  query: >-
    query getEvents($first: Int, $after: String) {
      events(first: $first, after: $after) {
        pageInfo {
          hasNextPage
          endCursor
        }
        nodes {
          id
          eventType{
            type
            group
            description
            schema
            category
            family
            canCapture
            actions
            exclusion
          }
          srcIP
          dstIP
          protocolRaw
          time
          srcMac
          dstMac
          completion
          protocolNiceName
          resolved
          hitId
          severity
          category
          logId
          resolvedUser
          type
          srcAssets{
            nodes{
              id
              name
              lastHit
              lastSeen
            }
          }
          srcInterface{
            id
            lastSeen
          }
          hasDetails
          payloadSize
          protocol
          port
          continuous
        }
      }
    }
 
program: |-
  request(
  	"POST",
  	state.url.trim_right("/") + "/graphql"
  ).with(
  	{
  		"Header": {
  			"Content-Type": ["application/json"],
  			"Accept": ["application/json"],
  			"X-ApiKeys": ["key=" + state.key],
  		},
  		"Body": {
  			"query": state.query,
  			"variables": {
  				"first": state.batch_size,
  				"after": state.?cursor.end_cursor.orValue(null),
  			},
  		}.encode_json(),
  	}
  ).do_request().as(resp,
  	bytes(resp.Body).decode_json().as(body,
  		body.data.events.nodes.as(nodes,
  			state.with(
  				{
  					"events": nodes.map(e,
  						{
  							"message": e,
  							?"event.original": state.?preserve_original_event.orValue(false) ? optional.of(e.encode_json()) : optional.none(),
  						}
  					),
  					"cursor": {"end_cursor": (size(nodes) > 0) ? body.data.events.pageInfo.endCursor : state.?cursor.end_cursor},
  					"want_more": body.data.events.pageInfo.hasNextPage,
  				}
  			)
  		)
  	)
  )
tags:
{{#if preserve_original_event}}
  - preserve_original_event
{{/if}}
{{#each tags as |tag|}}
  - {{tag}}
{{/each}}
{{#contains "forwarded" tags}}
publisher_pipeline.disable_host: true
{{/contains}}
{{#if processors}}
processors:
{{processors}}
{{/if}}