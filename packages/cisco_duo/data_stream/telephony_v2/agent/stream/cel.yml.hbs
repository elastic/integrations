config_version: 2
interval: {{interval}}
resource.url: {{hostname}}
resource.rate_limit.burst: 1
resource.rate_limit.limit: {{rate_limit}}

{{#if enable_request_tracer}}
resource.tracer.filename: "../../logs/cel/http-request-trace-*.ndjson"
resource.tracer.maxbackups: 5
resource.tracer.maxsize: 5
{{/if}}

regexp:
  "next_offset_timestamp": '^\d+'

state:
  url: {{hostname}}
  integration_key: {{integration_key}}
  secret_key: {{secret_key}}
  limit: {{limit}}
  initial_interval: {{initial_interval}}
  want_more: false
redact:
  fields:
    - integration_key
    - secret_key

program: |
    (
        state.want_more ?
            state
        :
            state.with({
                "mintime": string(state.?cursor.last_published.orValue(int(now - duration(state.initial_interval)) * 1000)),
            })
    ).as(state, state.with({
        // calculate maxtime to be the current time minus a buffer (2 minutes) to avoid potential synchronization issues.
        "maxtime": (int(now - duration("2m"))).as(mx,
            mx < int(timestamp(int(state.mintime) / 1000) + duration("4320h")) ? string(mx * 1000) : string(int(timestamp(int(state.mintime) / 1000) + duration("4320h") - duration("2m")) * 1000)
        )
    })).as(state, state.with(
        {
            // prepare request data dynamically for each request to prevent 40103 error.
            "date": now.format(time_layout.RFC1123Z),
            "method": "GET",
            "url_base": state.url.trim_right("/"),
            "url_path": "/admin/v2/logs/telephony",
            "query_string": {
                "limit": [string(dyn(state).limit)],
                "maxtime": [state.maxtime],
                "mintime": [state.mintime],
                ?"next_offset": has(state.next_offset) ?
                    optional.of([string(state.next_offset)])
                :
                    optional.none(),
                "sort": ["ts:asc"],
            }.format_query(),
        }.as(r, r.with({
            "authorization": "Basic " + (
                state.integration_key + ":" + (
                    [
                        r.date,
                        r.method,
                        r.url_base.trim_prefix("https://"),
                        r.url_path,
                        r.query_string,
                    ].join("\n")
                    .hmac("sha1", bytes(state.secret_key))
                    .hex()
                )
            ).base64(),
        })).as(r,
            request(
                r.method,
                [r.url_base, r.url_path, "?", r.query_string].join("")
            ).with({
                "Header": {
                    "Content-Type": ["application/x-www-form-urlencoded"],
                    "Date": [r.date],
                    "Authorization": [r.authorization],
                },
            }).do_request().as(resp, (resp.StatusCode == 200) ?
                bytes(resp.Body).decode_json().as(body, has(body.?response.items) && size(body.response.items) > 0 ?
                    {
                        "events": body.response.items.map(item,
                            {
                                "message": item.encode_json(),
                            }
                        ),
                        "want_more": has(body.?response.?metadata.next_offset),
                        ?"next_offset": (body.?response.metadata.next_offset.orValue(null) != null) ?
                            optional.of(string(body.response.metadata.next_offset))
                        :
                            optional.none(),
                        "cursor": {
                            ?"last_published": (has(body.?response.items) && size(body.response.items) > 0) ?
                                optional.of(
                                    body.response.items.map(i, i.ts).max().as(last_timestamp,
                                        !has(dyn(state).?cursor.last_published) ?
                                            last_timestamp
                                        : (last_timestamp < dyn(state).cursor.last_published) ?
                                            dyn(state).cursor.last_published
                                        :
                                            last_timestamp
                                    )
                                )
                            :
                                dyn(state).?cursor.last_published,
                        }
                    }
                :
                    {
                        "events": [],
                        "want_more": false,
                    }

                )
            :
                bytes(resp.Body).decode_json().as(body,
                    {
                        "events": {
                            "error": {
                                "code": has(body.code) ? string(body.code) : string(resp.StatusCode),
                                "id": string(resp.Status),
                                "message": "GET:"+(
                                    size(resp.Body) != 0 ?
                                        string(resp.Body)
                                    :
                                        string(resp.Status) + ' (' + string(resp.StatusCode) + ')'
                                ),
                            },
                        },
                        "want_more": false,
                    }
                )
            )
        )
    ))

tags:
{{#if preserve_original_event}}
  - preserve_original_event
{{/if}}
{{#each tags as |tag|}}
  - {{tag}}
{{/each}}
{{#contains "forwarded" tags}}
publisher_pipeline.disable_host: true
{{/contains}}
{{#if processors}}
processors:
{{processors}}
{{/if}}
