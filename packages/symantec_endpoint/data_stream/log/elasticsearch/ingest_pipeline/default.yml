---
description: Pipeline for parsing Symantec Endpoint logs
processors:
- set:
    copy_from: message
    field: event.original

- set:
    field: ecs.version
    value: 1.12.0

- set:
    field: observer.vendor
    value: Symantec
- set:
    field: observer.product
    value: Endpoint Protection
- set:
    field: observer.type
    value: edr

- grok:
    if: ctx.message.startsWith('<')
    field: message
    patterns:
      - '<%{NONNEGINT:log.syslog.priority:long}>(?:%{SYSLOGTIMESTAMP:timestamp}|%{TIMESTAMP_ISO8601:timestamp})(?: %{SYSLOGFACILITY})?(?: %{SYSLOGHOST:log.syslog.host.hostname})?(?: %{SYSLOGPROG}:)? %{GREEDYDATA:message}'
      - '%{SYSLOG5424LINE}'
    pattern_definitions:
      SYSLOGPROG: '%{PROG:log.syslog.process.name}(?:\[%{POSINT:log.syslog.process.pid:long}\])?'
      SYSLOG5424PRI: '<%{NONNEGINT:log.syslog.priority:long}>'
      SYSLOG5424BASE: '%{SYSLOG5424PRI}%{NONNEGINT:log.syslog.version:long} +(?:-|%{TIMESTAMP_ISO8601:timestamp}) +(?:-|%{IPORHOST:log.syslog.host.hostname}) +(?:-|%{SYSLOG5424PRINTASCII:log.syslog.process.name}) +(?:-|%{POSINT:log.syslog.process.pid:long}) +(?:-|%{SYSLOG5424PRINTASCII:log.syslog.message_id}) +(?:-|%{SYSLOG5424SD:log.syslog.structured_data})?'
      SYSLOG5424LINE: '%{SYSLOG5424BASE} +%{GREEDYDATA:message}'
- date:
    if: ctx?.timestamp != null
    field: timestamp
    target_field: "@timestamp"
    formats:
      - "MMM dd HH:mm:ss"
      - "MMM  d HH:mm:ss"
      - "MMM d HH:mm:ss"
      - ISO8601
    timezone: '{{{_conf.tz_offset}}}'
- remove:
    ignore_missing: true
    field: timestamp

###
# Processing steps:
# 1. Parse the CSV into an array of column values.
# 2. Parse labels from each column if the value takes the form of 'Label Name: Some Value' or 'Label Name:'.
# 3. Fingerprint the message based by joining the labels separated by '|'. Use 'NONE' for columns without an embedded label.
# 4. Set 'event.provider' based on the message fingerprint. The different log types are listed in https://knowledge.broadcom.com/external/article?legacyId=tech171741#Administrative.
# 5. Handle columns without an embedded label. Based on the fingerprint, map unlabeled columns to a key.
###

- csv:
    field: message
    empty_value: ""
    target_fields:
      - '_csv_array.00'
      - '_csv_array.01'
      - '_csv_array.02'
      - '_csv_array.03'
      - '_csv_array.04'
      - '_csv_array.05'
      - '_csv_array.06'
      - '_csv_array.07'
      - '_csv_array.08'
      - '_csv_array.09'
      - '_csv_array.10'
      - '_csv_array.11'
      - '_csv_array.12'
      - '_csv_array.13'
      - '_csv_array.14'
      - '_csv_array.15'
      - '_csv_array.16'
      - '_csv_array.17'
      - '_csv_array.18'
      - '_csv_array.19'
      - '_csv_array.20'
      - '_csv_array.21'
      - '_csv_array.22'
      - '_csv_array.23'
      - '_csv_array.24'
      - '_csv_array.25'
      - '_csv_array.26'
      - '_csv_array.27'
      - '_csv_array.28'
      - '_csv_array.29'
      - '_csv_array.30'
      - '_csv_array.31'
      - '_csv_array.32'
      - '_csv_array.33'
      - '_csv_array.34'
      - '_csv_array.35'
      - '_csv_array.36'
      - '_csv_array.37'
      - '_csv_array.38'
      - '_csv_array.39'
      - '_csv_array.40'
      - '_csv_array.41'
      - '_csv_array.42'
      - '_csv_array.43'
      - '_csv_array.44'
      - '_csv_array.45'
      - '_csv_array.46'
      - '_csv_array.47'
      - '_csv_array.48'
      - '_csv_array.49'
      - '_csv_array.50'

- script:
    description: Create array from CSV values.
    tag: csv-map-to-array
    lang: painless
    source: |
      def columnArray = [];
      def sortedMap = new TreeMap();
      sortedMap.putAll(ctx._csv_array);
      sortedMap.forEach((key, value) -> {
        def v = value;
        if (v.startsWith("'") && v.endsWith("'"))
        {
          v = v.substring(1, v.length() - 1);
        }
        columnArray.add(v);
      });
      ctx['_csv_array'] = columnArray;

- script:
    description: Split colon separated key/values.
    tag: split-colon-separated-key-value
    lang: painless
    source: |
      def aliases = Collections.unmodifiableMap([
        'domain': 'domain_name',
        'end_time': 'end',
        'local': 'local_host_ip',
        'server_name': 'server',
        'user': 'user_name'
      ]);

      def pattern = /^([a-zA-Z][a-zA-Z0-9 \(\)-]{0,28}):(?:\s(.+)|\s)?/;
      def keyValue = [:];
      def fingerprint = [];
      ctx._csv_array.forEach(v -> {
          def m = pattern.matcher(v);
          def key = 'NONE';
          if (m.matches()) {
            key = m.group(1).toLowerCase().replace(' ', '_');

            def tmp = aliases[key];
            if (tmp != null) {
              key = tmp;
            }


            def value = m.group(2);
            if (value != null && !value.trim().isEmpty()) {
              keyValue[key] = value.trim();
            }
          }

          fingerprint.add(key);
          return true;
      });
      if (!keyValue.isEmpty()) {
        ctx['_csv_map'] = keyValue;
      }
      ctx['_fingerprint'] = String.join("|", fingerprint);

- remove:
    field: message
    ignore_missing: true

- script:
    description: Assign keys to unlabeled columns based on fingerprints.
    lang: painless
    params:
      providers:
      # https://knowledge.broadcom.com/external/article?legacyId=TECH171741#Agent_Behavior
      - name: 'Agent Behavior Log'
        fingerprint: NONE|NONE|NONE|NONE|NONE|begin|end|rule|NONE|NONE|NONE|NONE|NONE|user_name|domain_name|action_type|file_size_(bytes)|device_id
        event_category: [intrusion_detection]
        event_type: [process]
        columns:
          - index: 1
            name: local_host_ip
          - index: 2
            name: action
          - index: 3
            name: event_description
          - index: 4
            name: api_name
          - index: 8
            name: caller_process_id
          - index: 9
            name: caller_process_name
          - index: 10
            name: caller_return_address
          - index: 11
            name: caller_return_module_name
          - index: 12
            name: parameters # name of the module, process, registry location or file
      # https://knowledge.broadcom.com/external/article?legacyId=TECH171741#Agent_Security
      - name: 'Agent Security Log'
        fingerprint:
          - NONE|event_description|local_host_ip|local_host_mac|remote_host_name|remote_host_ip|remote_host_mac|NONE|NONE|intrusion_id|begin|end|occurrences|application|location|user_name|domain_name|local_port|remote_port|cids_signature_id|cids_signature_string|cids_signature_subid|intrusion_url|intrusion_payload_url|sha-256|md-5
          - NONE|event_description|local_host_ip|local_host_mac|remote_host_name|remote_host_ip|remote_host_mac|NONE|NONE|NONE|begin|end|occurrences|application|location|user_name|domain_name|local_port|remote_port|cids_signature_id|cids_signature_string|cids_signature_subid|intrusion_url|intrusion_payload_url|sha-256|md-5
        event_category: [intrusion_detection, network]
        event_type: [connection, process]
        columns:
          - index: 7
            name: traffic_direction
          - index: 8
            name: network_protocol
      # https://knowledge.broadcom.com/external/article?legacyId=TECH171741#Agent_Traffic
      - name: 'Agent Traffic Log'
        fingerprint: NONE|local_host_ip|local_port|local_host_mac|remote_host_ip|remote_host_name|remote_port|remote_host_mac|NONE|NONE|begin|end|occurrences|application|rule|location|user_name|domain_name|action|sha-256|md-5
        event_category: [intrusion_detection, network]
        event_type: [connection, process]
        columns:
          - index: 9
            name: traffic_direction
          - index: 8
            name: network_protocol
      # https://knowledge.broadcom.com/external/article?legacyId=TECH171741#Agent_Activity
      - name: 'Agent Activity Log'
        fingerprint: site|server|domain_name|NONE|NONE|NONE|NONE
        columns:
          - index: 3
            name: event_description
          - index: 4
            name: local_host_name
          - index: 5
            name: user_name
          - index: 6
            name: domain_name
      # https://knowledge.broadcom.com/external/article?legacyId=TECH171741#Agent_Packet
      - name: 'Agent Packet Log'
        fingerprint:
          - NONE|local_host|local_port|remote_host_ip|remote_host_name|remote_port|NONE|application|action
        event_category: [intrusion_detection, network]
        event_type: [connection, process]
        columns:
          - index: 6
            name: traffic_direction
      # https://knowledge.broadcom.com/external/article?legacyId=TECH171741#Agent_System
      - name: 'Agent System Log'
        fingerprint:
          - NONE|category|NONE|NONE|event_time
        columns:
          - index: 2
            name: event_source
          - index: 3
            name: event_description
      # https://knowledge.broadcom.com/external/article?legacyId=TECH171741#Administrative
      - name: 'Administrative Log'
        fingerprint: site|server|domain_name|admin|NONE
        columns:
          - index: 4
            name: event_description
      # https://knowledge.broadcom.com/external/article?legacyId=TECH171741#System
      - name: 'System Log'
        fingerprint: site|server|NONE
        columns:
          - index: 2
            name: event_description
      # https://knowledge.broadcom.com/external/article?legacyId=TECH171741#Agent_Proactive_Detection
      - name: 'Agent Proactive Detection Log'
        fingerprint: NONE|computer_name|detection_type|first_seen|application_name|application_type|application_version|NONE|NONE|NONE|hash_type|application_hash|company_name|file_size_(bytes)|sensitivity|detection_score|coh_engine_version|NONE|permitted_application_reason|disposition|download_site|web_domain|downloaded_by|prevalence|confidence|url_tracking_status|risk_level|detection_source|source|risk_name|occurrences|NONE|NONE|actual_action|requested_action|secondary_action|event_time|inserted|end|domain_name|group|server|user_name|source_computer|source_ip
        columns:
          - index: 0
            name: event_description
          - index: 31
            name: file_path
      # https://knowledge.broadcom.com/external/article?legacyId=TECH171741#Policy
      - name: 'Policy Log'
        fingerprint: site|server|domain_name|admin|event_description|NONE
        columns:
          - index: 5
            name: policy_name
      # https://knowledge.broadcom.com/external/article?legacyId=TECH171741#Agent_Scan
      - name: 'Agent Scan Log'
        fingerprint: scan_id|begin|end|NONE|duration_(seconds)|user1|user2|NONE|scan_complete|command|threats|infected|total_files|omitted|computer|ip_address|domain_name|group|server
        columns:
          - index: 3
            name: action
          - index: 7
            name: event_description
      # https://knowledge.broadcom.com/external/article?legacyId=tech171741#Agent_Risk
      - name: 'Agent Risk Log'
        fingerprint: NONE|ip_address|computer_name|source|risk_name|occurrences|NONE|NONE|actual_action|requested_action|secondary_action|event_time|inserted|end|last_update_time|domain_name|group|server|user_name|source_computer|source_ip|disposition|download_site|web_domain|downloaded_by|prevalence|confidence|url_tracking_status|first_seen|sensitivity|permitted_application_reason|application_hash|hash_type|company_name|application_name|application_version|application_type|file_size_(bytes)|category_set|category_type|location|intensive_protection_level|certificate_issuer|certificate_signer|certificate_thumbprint|signing_timestamp|certificate_serial_number
        columns:
          - index: 0
            name: event_description
          - index: 6
            name: file_path
    source: |
      // Assume first column is always the host.hostname.
      def hostname = ctx._csv_array.get(0);
      if (/[a-zA-Z0-9_-]+/.matcher(hostname).matches()) {
        if (ctx?.host == null) {
          ctx['host'] = [:];
        }
        ctx['host']['hostname'] = hostname;
      }

      def provider = null;
      for (def p: params.providers) {
        if (p.fingerprint == ctx._fingerprint || (p.fingerprint instanceof Collection && p.fingerprint.contains(ctx._fingerprint))) {
          provider = p;
          break;
        }
      }
      if (provider == null) { return; }

      ctx['event']['provider'] = provider.name;
      if (provider?.event_category != null) {
        ctx['event']['category'] = provider.event_category;
      }
      if (provider?.event_type!= null) {
        ctx['event']['type'] = provider.event_type;
      }
      provider.columns.forEach(c -> {
        ctx._csv_map[c.name] = ctx._csv_array.get(c.index);
      });

# Action
- lowercase:
    field: _csv_map.action
    ignore_missing: true
- rename:
    field: _csv_map.action
    target_field: event.action
    ignore_missing: true

# Actual Action
- set:
    if: ctx?.event?.action == null
    copy_from: _csv_map.actual_action
    field: event.action
    ignore_failure: true

# Admin
- set:
    copy_from: _csv_map.admin
    field: user.name
    ignore_failure: true

# Application
- rename:
    field: _csv_map.application
    target_field: process.executable
    ignore_missing: true

# Application Name
- set:
    if: ctx?._csv_map?.application_name != null
    field: file.pe.product
    copy_from: _csv_map.application_name

# Application Version
- set:
    if: ctx?._csv_map?.application_version != null
    field: file.pe.file_version
    copy_from: _csv_map.application_version

# Begin
- date:
    field: _csv_map.begin
    target_field: event.start
    ignore_failure: true
    formats:
      - yyyy-MM-dd HH:mm:ss

# Caller MD-5
- dissect:
    tag: caller-md5
    field: _csv_map.event_description
    pattern: '%{} Caller MD5=%{process.hash.md5}'
    ignore_failure: true

# Caller Process ID
- convert:
    field: _csv_map.caller_process_id
    target_field: process.pid
    type: long
    ignore_missing: true

# Caller Process Name
- rename:
    if: ctx?.process?.executable == null
    field: _csv_map.caller_process_name
    target_field: process.executable
    ignore_missing: true

# Certificate Issuer
- append:
    if: ctx?._csv_map?.certificate_issuer != null
    field: file.x509.issuer.common_name
    value: '{{{_csv_map.certificate_issuer}}}'

# Certificate Serial Number
- set:
    if: ctx?._csv_map?.certificate_serial_number != null
    field: file.x509.serial_number
    copy_from: _csv_map.certificate_serial_number

 # Certificate Signer
- append:
    if: ctx?._csv_map?.certificate_signer != null
    field: file.x509.issuer.common_name
    value: '{{{_csv_map.certificate_signer}}}'

# Certificate Thumbprint (hex encoded sha1 hashes are 40 characters)
- lowercase:
    if: ctx?._csv_map?.certificate_thumbprint != null && ctx._csv_map.certificate_thumbprint.length() == 40
    field: _csv_map.certificate_thumbprint
    target_field: file.hash.sha1

# CIDS Signature ID
- rename:
    field: _csv_map.cids_signature_id
    target_field: symantec_endpoint.log.signature.id
    ignore_missing: true

# CIDS Signature String
- rename:
    field: _csv_map.cids_signature_string
    target_field: symantec_endpoint.log.signature.name
    ignore_missing: true

# CIDS Signature Sub-ID
- rename:
    field: _csv_map.cids_signature_subid
    target_field: symantec_endpoint.log.signature.sub_id
    ignore_missing: true

# Company Name
- set:
    if: ctx?._csv_map?.company_name != null
    field: file.pe.company
    copy_from: _csv_map.company_name

# Domain Name
- rename:
    if: ctx?.user?.domain == null
    field: _csv_map.domain_name
    target_field: user.domain
    ignore_missing: true

# Downloaded by
- set:
    if: ctx?._csv_map?.downloaded_by != null
    field: process.executable
    copy_from: _csv_map.downloaded_by

# Duration (seconds)
- convert:
    field: _csv_map.duration_(seconds)
    target_field: event.duration
    type: long
    ignore_missing: true
    ignore_failure: true
- script:
    description: Convert event.duration from seconds to nanoseconds.
    if: ctx?.event?.duration != null
    lang: painless
    source:
      ctx.event['duration'] = ctx.event.duration * 1e9;

# End
- date:
    field: _csv_map.end
    target_field: event.end
    ignore_failure: true
    formats:
      - yyyy-MM-dd HH:mm:ss

# Event Description
- remove:
    if: ctx?._csv_map?.event_description != null
    field: message
    ignore_missing: true
- rename:
    field: _csv_map.event_description
    target_field: message
    ignore_missing: true

# Event Time
- date:
    if: ctx?._csv_map?.event_time != null
    field: _csv_map.event_time
    target_field: _csv_map.event_time
    ignore_failure: true
    formats:
      - yyyy-MM-dd HH:mm:ss
    on_failure:
      - remove:
          field: _csv_map.event_time
- set:
    if: ctx?._csv_map?.event_time != null
    field: '@timestamp'
    copy_from: _csv_map.event_time

# File Path
- rename:
    field: _csv_map.file_path
    target_field: file.path
    ignore_missing: true

# File Size (bytes)
- convert:
    field: _csv_map.file_size_(bytes)
    target_field: file.size
    type: long
    ignore_missing: true
    ignore_failure: true

# Inserted
- date:
    if: ctx?._csv_map?.inserted != null
    field: _csv_map.inserted
    target_field: _csv_map.inserted
    ignore_failure: true
    formats:
      - yyyy-MM-dd HH:mm:ss
    on_failure:
      - remove:
          field: _csv_map.inserted

# Intrusion ID
- rename:
    field: _csv_map.intrusion_id
    target_field: rule.id
    ignore_missing: true

# Intrusion Payload URL
- rename:
    field: _csv_map.intrusion_payload_url
    target_field: symantec_endpoint.log.intrusion_payload_url
    ignore_missing: true

# Intrusion URL
- rename:
    field: _csv_map.intrusion_url
    target_field: url.original
    ignore_missing: true

# Last Update Time (listed as always being in GMT)
- date:
    if: ctx?._csv_map?.last_update_time != null
    field: _csv_map.last_update_time
    target_field: _csv_map.last_update_time
    formats:
      - yyyy-MM-dd HH:mm:ss
    on_failure:
      - remove:
          field: _csv_map.last_update_time

# Local Host IP
- convert:
    if: ctx?._csv_map?.local_host_ip != "0.0.0.0"
    field: _csv_map.local_host_ip
    target_field: source.ip
    type: ip
    ignore_missing: true
    on_failure:
      - rename:
          field: _csv_map.local_host_ip
          target_field: source.address

# Local Host MAC
- rename:
    field: _csv_map.local_host_mac
    target_field: source.mac
    ignore_missing: true
- gsub:
    field: source.mac
    pattern: '[-:.]'
    replacement: ''
    ignore_missing: true
- remove:
    if: ctx?.source?.mac == '000000000000'
    field: source.mac
- gsub:
    field: source.mac
    pattern: '(..)(?!$)'
    replacement: '$1-'
    ignore_missing: true
- uppercase:
    field: source.mac
    ignore_missing: true

# Local Host Name
- rename:
    field: _csv_map.local_host_name
    target_field: source.domain
    ignore_missing: true

# Local Port
- convert:
    if: ctx?._csv_map?.local_port != "0"
    field: _csv_map.local_port
    target_field: source.port
    type: long
    ignore_failure: true

# Location
- rename:
    field: _csv_map.location
    target_field: source.geo.name
    ignore_missing: true

# MD-5
- rename:
    field: _csv_map.md-5
    target_field: process.hash.md5
    ignore_missing: true
- lowercase:
    field: process.hash.md5
    ignore_missing: true

# Network Protocol (known as ECS network transport)
- rename:
    field: _csv_map.network_protocol
    target_field: network.transport
    ignore_missing: true
- lowercase:
    field: network.transport
    ignore_missing: true

# Occurrences
- convert:
    field: _csv_map.occurrences
    target_field: event.count
    type: long
    ignore_failure: true

# Remote Host IP
- convert:
    if: ctx?._csv_map?.remote_host_ip != "0.0.0.0"
    field: _csv_map.remote_host_ip
    target_field: destination.ip
    type: ip
    ignore_missing: true
    on_failure:
      - rename:
          field: _csv_map.remote_host_ip
          target_field: destination.address

# Remote Host MAC
- rename:
    field: _csv_map.remote_host_mac
    target_field: destination.mac
    ignore_missing: true
- gsub:
    field: destination.mac
    pattern: '[-:.]'
    replacement: ''
    ignore_missing: true
- remove:
    if: ctx?.destination?.mac == '000000000000'
    field: destination.mac
- gsub:
    field: destination.mac
    pattern: '(..)(?!$)'
    replacement: '$1-'
    ignore_missing: true
- uppercase:
    field: destination.mac
    ignore_missing: true

# Remote Host Name
- rename:
    if: ctx?._csv_map?.remote_host_name != ""
    field: _csv_map.remote_host_name
    target_field: destination.domain
    ignore_missing: true

# Remote Port
- convert:
    if: ctx?._csv_map?.remote_port != "0"
    field: _csv_map.remote_port
    target_field: destination.port
    type: long
    ignore_failure: true

# Rule
- rename:
    field: _csv_map.rule
    target_field: rule.name
    ignore_missing: true

# Server
#- set:
#    field: host.hostname
#    copy_from: _csv_map.server
#    ignore_failure: true

# SHA-256
- rename:
    field: _csv_map.sha-256
    target_field: process.hash.sha256
    ignore_missing: true
- lowercase:
    field: process.hash.sha256
    ignore_missing: true

# Signing Timestamp (Agent Risk Log)
- date:
    if: ctx?._csv_map?.signing_timestamp != null
    field: _csv_map.signing_timestamp
    target_field: _csv_map.signing_timestamp
    formats:
      - UNIX
    on_failure:
      - remove:
          field: _csv_map.event_time
- set:
    if: ctx?._csv_map?.signing_timestamp != null
    field: file.x509.not_before
    copy_from: _csv_map.signing_timestamp

# Traffic Direction
# NOTE: inbound/outbound is changed to ingress/egress because this is a host
# based EDR and ECS guidelines say to use ingress/egress for hosts.
- rename:
    field: _csv_map.traffic_direction
    target_field: network.direction
    ignore_missing: true
- lowercase:
    field: network.direction
    ignore_missing: true
- set:
    if: ctx?.network?.direction == "inbound"
    field: network.direction
    value: ingress
- set:
    if: ctx?.network?.direction == "outbound"
    field: network.direction
    value: egress

# User Name
- rename:
    field: _csv_map.user_name
    target_field: user.name
    ignore_missing: true

# User1
- set:
    if: ctx?._csv_map?.user1 != null && ctx?.user?.name == null
    field: user.name
    copy_from: _csv_map.user1

- remove:
    description: Remove columns that are mapped to ECS.
    ignore_missing: true
    field:
      - _csv_map.action
      - _csv_map.admin
      - _csv_map.application
      - _csv_map.begin
      - _csv_map.caller_process_id
      - _csv_map.caller_process_name
      - _csv_map.cids_signature_id
      - _csv_map.cids_signature_string
      - _csv_map.cids_signature_subid
      - _csv_map.domain_name
      - _csv_map.duration_(seconds)
      - _csv_map.end
      - _csv_map.event_description
      - _csv_map.file_size_(bytes)
      - _csv_map.intrusion_id
      - _csv_map.intrusion_payload_url
      - _csv_map.intrusion_url
      - _csv_map.local_host_ip
      - _csv_map.local_host_mac
      - _csv_map.local_host_name
      - _csv_map.local_port
      - _csv_map.location
      - _csv_map.md-5
      - _csv_map.network_protocol
      - _csv_map.occurrences
      - _csv_map.remote_host_ip
      - _csv_map.remote_host_mac
      - _csv_map.remote_host_name
      - _csv_map.remote_port
      - _csv_map.rule
      - _csv_map.sha-256
      - _csv_map.traffic_direction
      - _csv_map.user_name

- script:
    description: Merge key/values not mapped to ECS into symantec_endpoint.log.
    tag: merge-unmapped-keys
    lang: painless
    source: |
      if (ctx?._csv_map != null && !ctx?._csv_map.isEmpty()) {
        def sep = ctx['symantec_endpoint'];
        if (sep == null) {
          sep = [:];
          ctx['symantec_endpoint'] = sep;
        }
        def log = sep['log'];
        if (log == null) {
          log = [:];
          sep['log'] = log;
        }
        ctx._csv_map.forEach((k, v) -> {
          log[k] = v;
        });
      }

      ctx.remove('_csv_map');

# ECS Categorization
- set:
    field: event.kind
    value: event
- append:
    if: ctx?.event.action == 'blocked' || (ctx?.message != null && !ctx.message.contains('not blocked') && ctx.message.contains('blocked'))
    field: event.type
    value: denied
    allow_duplicates: false
- append:
    if: ctx?.event.action == 'not blocked' || (ctx?.message != null && ctx.message.contains('not blocked'))
    field: event.type
    value: allowed
    allow_duplicates: false
- append:
    if: ctx?.event?.provider == 'Administrative Log' && ctx.message.contains('log on')
    field: event.category
    value: authentication
- append:
    if: ctx?.event?.provider == 'Administrative Log' && ctx.message.contains('log on')
    field: event.type
    value: info
- set:
    if: ctx?.event?.provider == 'Administrative Log' && ctx.message.contains('log on failed')
    field: event.outcome
    value: failure
- set:
    if: ctx?.event?.provider == 'Administrative Log' && ctx.message.contains('log on succeeded')
    field: event.outcome
    value: success

# Host IP
- append:
    if: ctx?.source?.ip != null
    field: host.ip
    value: '{{{source.ip}}}'
    allow_duplicates: false

# Host MAC
- append:
    if: ctx?.source?.mac != null
    field: host.mac
    value: '{{{source.mac}}}'
    allow_duplicates: false

# Host Hostname
- set:
    if: ctx?.source?.domain  != null
    field: host.hostname
    value: '{{{source.domain}}}'

# Related IP
- append:
    if: ctx?.source?.ip != null
    field: related.ip
    value: '{{{source.ip}}}'
    allow_duplicates: false
- append:
    if: ctx?.destination?.ip != null
    field: related.ip
    value: '{{{destination.ip}}}'
    allow_duplicates: false

# Related Hash
- append:
    if: ctx?.file?.hash?.sha1 != null
    field: related.hash
    value: '{{{file.hash.sha1}}}'
    allow_duplicates: true
- append:
    if: ctx?.process?.hash?.md5 != null
    field: related.hash
    value: '{{{process.hash.md5}}}'
    allow_duplicates: true
- append:
    if: ctx?.process?.hash?.sha256 != null
    field: related.hash
    value: '{{{process.hash.sha256}}}'
    allow_duplicates: true

# Community ID
- community_id:
    ignore_failure: true

# IP Geolocation Lookup
- geoip:
    if: ctx.source?.geo == null
    field: source.ip
    target_field: source.geo
    ignore_missing: true
- geoip:
    if: ctx.destination?.geo == null
    field: destination.ip
    target_field: destination.geo
    ignore_missing: true

# IP Autonomous System (AS) Lookup
- geoip:
    database_file: GeoLite2-ASN.mmdb
    field: source.ip
    target_field: source.as
    properties:
      - asn
      - organization_name
    ignore_missing: true
- geoip:
    database_file: GeoLite2-ASN.mmdb
    field: destination.ip
    target_field: destination.as
    properties:
      - asn
      - organization_name
    ignore_missing: true
- rename:
    field: source.as.asn
    target_field: source.as.number
    ignore_missing: true
- rename:
    field: source.as.organization_name
    target_field: source.as.organization.name
    ignore_missing: true
- rename:
    field: destination.as.asn
    target_field: destination.as.number
    ignore_missing: true
- rename:
    field: destination.as.organization_name
    target_field: destination.as.organization.name
    ignore_missing: true

- script:
    # Local was assumed to be source and remote was assumed to be destination.
    # But if direction is ingress then swap the two around.
    description: Swap source/destination for "ingress".
    tag: swap-source-destination-on-ingress
    if: ctx?.network?.direction == "ingress" && ctx?.source != null && ctx?.destination != null
    lang: painless
    source: |
      def tmp = ctx.source;
      ctx.source = ctx.destination;
      ctx.destination = tmp;

- remove:
    description: Retain event.original when preserve_original_event tag exists.
    if: ctx?.tags == null || !ctx.tags.contains('preserve_original_event')
    field: event.original
    ignore_missing: true

- remove:
    if: ctx?.tags == null || !ctx.tags.contains('debug')
    ignore_missing: true
    field:
      - _conf
      - _csv_array
      - _fingerprint

on_failure:
- set:
    field: error.message
    value: '{{ _ingest.on_failure_message }}'

- remove:
    if: ctx?.tags == null || !ctx.tags.contains('debug')
    ignore_missing: true
    field:
      - _conf
      - _csv_array
      - _csv_map
      - _fingerprint
