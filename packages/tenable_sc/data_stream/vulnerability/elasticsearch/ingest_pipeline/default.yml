---
description: Pipeline for Tenable.sc vulnerability logs
processors:
  - set:
      field: ecs.version
      value: '8.0.0'
  - rename:
      field: message
      target_field: event.original
      ignore_missing: true
  - json:
      field: event.original
      target_field: json
      ignore_failure: true
  - fingerprint:
      fields:
        - json.lastSeen
        - json.pluginID
        - json.ip
        - json.uuid
        - json.firstSeen
        - json.lastSeen
        - json.exploitAvailable
        - json.vulnPubDate
        - json.patchPubDate
        - json.pluginPubDate
        - json.pluginModDate
        - json.pluginText
        - json.dnsName
        - json.macAddress
        - json.operatingSystem
        - json.pluginInfo
      target_field: _id
      ignore_missing: true
  - date:
      field: json.lastSeen
      target_field: "@timestamp"
      ignore_failure: true
      formats:
          - UNIX
  - set:
      field: event.category
      value: threat
  - set:
      field: event.type
      value: info
  - set:
      field: event.kind
      value: event
  - set:
      field: vulnerability.scanner.vendor
      value: Tenable
  - set:
      field: vulnerability.score.version
      value: '3.0'
      if: ctx?.json?.cvssV3BaseScore != '' || ctx?.json?.cvssV3TemporalScore != ''
  - split:
      field: json.seeAlso
      target_field: json.seeAlso
      separator: '\n'
  - script:
      description: |
        This script will add all the cve reference links as well as the reference links provided in the response vunlerability.reference field.
      lang: painless
      source: >-
        Set referenceSet = new HashSet();
        if (ctx.json.cve != '') {
          def cveIDs = ctx.json.cve.toString().splitOnToken(",");
          for (int i = 0; i < cveIDs.length; i++) {
            referenceSet.add("https://cve.mitre.org/cgi-bin/cvename.cgi?name=" + cveIDs[i]);
          }
        }
        def seeAlsoLinks = ctx.json.seeAlso;
        if (seeAlsoLinks != null) {
          for (int i = 0; i < seeAlsoLinks.length; i++) {
            referenceSet.add(seeAlsoLinks[i]);
          }
        }
        ctx.vulnerability.reference = new ArrayList(referenceSet);
  - set: 
      field: vulnerability.enumeration
      value: 'CVE'
      if: ctx?.json?.cve != ''
  - split:
      field: json.cve
      target_field: vulnerability.id
      separator: ','
  - set: 
      field: vulnerability.classification
      value: 'CVSS'
      if: ctx?.json?.cvssV3BaseScore != '' || ctx?.json?.cvssV3TemporalScore != ''
  - convert:
      field: json.cvssV3BaseScore
      type: float
      ignore_failure: true
  - rename:
      field: json.cvssV3BaseScore
      target_field: vulnerability.score.base
      ignore_missing: true
  - convert:
      field: json.cvssV3TemporalScore
      type: float
      ignore_failure: true
  - rename:
      field: json.cvssV3TemporalScore
      target_field: vulnerability.score.temporal
      ignore_missing: true
  - rename:
      field: json.description
      target_field: vulnerability.description
      ignore_missing: true
  - rename:
      field: json.severity.name
      target_field: vulnerability.severity
      ignore_missing: true
  - rename:
      field: json.severity.id
      target_field: tenable_sc.vulnerability.severity.id
      ignore_missing: true
  - script: 
      if: ctx.json.uniqueness != ""
      lang: painless
      source: >-
        def keys = ctx.json.uniqueness.toString().splitOnToken(",");
        String uniqueKey = "";
        if (keys.length > 0) {
          for (int i = 0; i < keys.length; i++) {
            if(keys[i] == "repositoryID") {
              uniqueKey = uniqueKey + ctx.json.repository.id + (i == keys.length - 1 ? "" : "_");
            } else {
              uniqueKey = uniqueKey + ctx.json[keys[i]] + (i == keys.length - 1 ? "" : "_");
            }
          }
        }
        ctx.tenable_sc.vulnerability.id = uniqueKey;
  - fingerprint: 
      fields: 
        - json.pluginID
        - json.port
        - json.protocol
        - tenable_sc.vulnerability.id
      target_field: tenable_sc.vulnerability.custom_hash
      method: SHA-256
      ignore_missing: true
  - rename:
      field: json.pluginID
      target_field: tenable_sc.vulnerability.plugin.id
      ignore_missing: true
  - rename:
      field: json.severity.description
      target_field: tenable_sc.vulnerability.severity.description
      ignore_missing: true
  - set:
      field: tenable_sc.vulnerability.has_been_mitigated
      value: false
      if: ctx?.json?.hasBeenMitigated == '0'
  - set:
      field: tenable_sc.vulnerability.has_been_mitigated
      value: true
      if: ctx?.json?.hasBeenMitigated == '1'
  - rename:
      field: json.acceptRisk
      target_field: tenable_sc.vulnerability.accept_risk
      ignore_missing: true
  - rename:
      field: json.recastRisk
      target_field: tenable_sc.vulnerability.recast_risk
      ignore_missing: true
  - rename:
      field: json.vprScore
      target_field: tenable_sc.vulnerability.vpr.score
      if: ctx?.json?.vprScore != ''
  - convert:
      field: tenable_sc.vulnerability.vpr.score
      type: double
      ignore_failure: true
  - json: 
      field: json.vprContext
      target_field: json.vprContext
      ignore_failure: true
  - script:
      if: ctx?.json?.vprContext != null
      lang: painless
      source: >-
        def parts = ctx.json.vprContext;
        if (parts != null && parts.length > 0) {
          Map map = new HashMap();
          for (int i = 0; i < parts.length; i++) {
            map.put(parts[i]["id"], parts[i]["value"])
          }
          ctx.tenable_sc.vulnerability.vpr.context = map;
          ctx.tenable_sc.vulnerability.vpr.context._original = parts;
        }
  - append:
      field: related.ip
      value: '{{{json.ip}}}'
      if: ctx?.json?.ip != null
  - append:
      field: host.ip
      value: '{{{json.ip}}}'
      if: ctx?.json?.ip != null
  - rename:
      field: json.ip
      target_field: tenable_sc.vulnerability.ip
      ignore_missing: true
  - rename:
      field: json.port
      target_field: tenable_sc.vulnerability.port
      ignore_missing: true
  - rename:
      field: json.protocol
      target_field: tenable_sc.vulnerability.protocol
      ignore_missing: true
  - rename:
      field: json.pluginName
      target_field: tenable_sc.vulnerability.plugin.name
      ignore_missing: true
  - date:
      field: json.firstSeen
      target_field: tenable_sc.vulnerability.first_seen
      ignore_failure: true
      formats:
          - UNIX
  - date:
      field: json.lastSeen
      target_field: tenable_sc.vulnerability.last_seen
      ignore_failure: true
      formats:
          - UNIX
  - set: 
      field: tenable_sc.vulnerability.exploit.is_available
      value: true
      if: ctx?.json?.exploitAvailable == 'Yes'
  - set: 
      field: tenable_sc.vulnerability.exploit.is_available
      value: false
      if: ctx?.json?.exploitAvailable == 'No'
  - rename:
      field: json.exploitEase
      target_field: tenable_sc.vulnerability.exploit.ease
      ignore_missing: true
  - rename:
      field: json.exploitFrameworks
      target_field: tenable_sc.vulnerability.exploit.frameworks
      ignore_missing: true
  - rename:
      field: json.solution
      target_field: tenable_sc.vulnerability.solution
      ignore_missing: true
  - rename:
      field: json.synopsis
      target_field: tenable_sc.vulnerability.synopsis
      ignore_missing: true
  - rename:
      field: json.riskFactor
      target_field: tenable_sc.vulnerability.risk_factor
      ignore_missing: true
  - rename:
      field: json.stigSeverity
      target_field: tenable_sc.vulnerability.stig_severity
      ignore_missing: true
  - rename:
      field: json.baseScore
      target_field: tenable_sc.vulnerability.base_score
      ignore_missing: true
  - rename:
      field: json.temporalScore
      target_field: tenable_sc.vulnerability.temporal_score
      ignore_missing: true
  - rename:
      field: json.cvssVector
      target_field: tenable_sc.vulnerability.cvss_vector
      ignore_missing: true
  - rename:
      field: json.cvssV3Vector
      target_field: tenable_sc.vulnerability.cvss_v3_vector
      ignore_missing: true
  - split:
      field: json.cpe
      target_field: tenable_sc.vulnerability.cpe
      separator: '<br/>'
      ignore_missing: true
  - set: 
      field: tenable_sc.vulnerability.is_vulnerability_published
      value: false
      if: ctx?.json?.vulnPubDate != null
  - set: 
      field: tenable_sc.vulnerability.is_vulnerability_published
      value: true
      if: ctx?.json?.vulnPubDate != '-1'
  - date:
      field: json.vulnPubDate
      target_field: tenable_sc.vulnerability.vuln_pub_date
      ignore_failure: true
      if: ctx?.json?.vulnPubDate != '-1'
      formats:
          - UNIX
  - set: 
      field: tenable_sc.vulnerability.patch.is_published
      value: false
      if: ctx?.json?.patchPubDate != null
  - set: 
      field: tenable_sc.vulnerability.patch.is_published
      value: true
      if: ctx?.json?.patchPubDate != '-1'
  - date:
      field: json.patchPubDate
      target_field: tenable_sc.vulnerability.patch.pub_date
      ignore_failure: true
      if: ctx?.json?.patchPubDate != '-1'
      formats:
          - UNIX
  - set: 
      field: tenable_sc.vulnerability.plugin.is_modified
      value: false
      if: ctx?.json?.pluginModDate != null
  - set: 
      field: tenable_sc.vulnerability.plugin.is_modified
      value: true
      if: ctx?.json?.pluginModDate != '-1'
  - date:
      field: json.pluginModDate
      target_field: tenable_sc.vulnerability.plugin.mod_date
      ignore_failure: true
      if: ctx?.json?.pluginModDate != '-1'
      formats:
          - UNIX
  - set: 
      field: tenable_sc.vulnerability.plugin.is_published
      value: false
      if: ctx?.json?.pluginPubDate != null
  - set: 
      field: tenable_sc.vulnerability.plugin.is_published
      value: true
      if: ctx?.json?.pluginPubDate != '-1'
  - date:
      field: json.pluginPubDate
      target_field: tenable_sc.vulnerability.plugin.pub_date
      ignore_failure: true
      if: ctx?.json?.pluginPubDate != '-1'
      formats:
          - UNIX
  - rename:
      field: json.uuid
      target_field: tenable_sc.vulnerability.uuid
      ignore_missing: true
  - rename:
      field: json.checkType
      target_field: tenable_sc.vulnerability.check_type
      ignore_missing: true
  - rename:
      field: json.version
      target_field: tenable_sc.vulnerability.version
      ignore_missing: true
  - rename:
      field: json.bid
      target_field: tenable_sc.vulnerability.bid
      ignore_missing: true
  - split:
      field: json.xref
      target_field: tenable_sc.vulnerability.xref
      separator: ","
      ignore_missing: true
  - rename:
      field: json.pluginText
      target_field: tenable_sc.vulnerability.plugin.text
      ignore_missing: true
  - set: 
      field: host.hostname
      copy_from: json.dnsName
      ignore_failure: true
  - set: 
      field: tenable_sc.vulnerability.dns.name
      copy_from: json.dnsName
      ignore_failure: true
  - script:
      lang: painless
      source: |
        def domain = "";
        def nameArray = ctx?.json?.dnsName?.toString().splitOnToken(".");
        if (nameArray?.length > 0) {
          for (int i = 1; i < nameArray.length; i++) {
            domain += nameArray[i] + (i < nameArray.length - 1 ? "." : "");
          }
          ctx.host.name = nameArray[0];
          ctx.host.domain = domain; 
        }
  - append:
      field: related.hosts
      value: "{{{host.hostname}}}"
      allow_duplicates: false
  - append:
      field: related.hosts
      value: "{{{host.name}}}"
      allow_duplicates: false
  - append:
      field: related.hosts
      value: "{{{json.netbiosName}}}"
      allow_duplicates: false
  - gsub:
      field: json.macAddress
      pattern: '[-:.]'
      replacement: '-'
      ignore_missing: true
  - uppercase:
      field: json.macAddress
      ignore_missing: true
  - append:
      if: ctx?.json?.macAddress != null
      field: host.mac
      value: '{{{json.macAddress}}}'
      allow_duplicates: false
  - rename:
      field: json.macAddress
      target_field: tenable_sc.vulnerability.mac
      ignore_missing: true
  - rename:
      field: json.netbiosName
      target_field: tenable_sc.vulnerability.netbios.name
      ignore_missing: true
  - set: 
      field: host.os.full
      copy_from: json.operatingSystem
      ignore_failure: true
  - rename:
      field: json.operatingSystem
      target_field: tenable_sc.vulnerability.operating_system
      ignore_missing: true
  - rename:
      field: json.uniqueness
      target_field: tenable_sc.vulnerability.uniqueness
      ignore_missing: true
  - rename:
      field: json.hostUniqueness
      target_field: tenable_sc.vulnerability.host_uniqueness
      ignore_missing: true
  - rename:
      field: json.family.id
      target_field: tenable_sc.vulnerability.family.id
      ignore_missing: true
  - append:
      field: vulnerability.category
      value: '{{{json.family.name}}}'
      if: ctx?.json?.family?.name != ''
  - rename:
      field: json.family.name
      target_field: tenable_sc.vulnerability.family.name
      ignore_missing: true
  - rename:
      field: json.family.type
      target_field: tenable_sc.vulnerability.family.type
      ignore_missing: true
  - rename:
      field: json.repository.id
      target_field: tenable_sc.vulnerability.repository.id
      ignore_missing: true
  - rename:
      field: json.repository.name
      target_field: tenable_sc.vulnerability.repository.name
      ignore_missing: true
  - rename:
      field: json.repository.description
      target_field: tenable_sc.vulnerability.repository.description
      ignore_missing: true
  - rename:
      field: json.repository.sciID
      target_field: tenable_sc.vulnerability.repository.sci_id
      ignore_missing: true
  - rename:
      field: json.repository.dataFormat
      target_field: tenable_sc.vulnerability.repository.data_format
      ignore_missing: true
  - rename:
      field: json.pluginInfo
      target_field: tenable_sc.vulnerability.plugin.info
      ignore_missing: true
  - script:
      description: Drops null/empty values recursively
      lang: painless
      source: |
        boolean drop(Object o) {
          if (o == null || o == "") {
            return true;
          } else if (o instanceof Map) {
            ((Map) o).values().removeIf(v -> drop(v));
            return (((Map) o).size() == 0);
          } else if (o instanceof List) {
            ((List) o).removeIf(v -> drop(v));
            return (((List) o).length == 0);
          }
          return false;
        }
        drop(ctx);
  - remove:
      field: json
      ignore_missing: true
  - remove:
      field: event.original
      if: "ctx?.tags == null || !(ctx.tags.contains('preserve_original_event'))"
      ignore_failure: true
      ignore_missing: true
on_failure:
  - set:
      field: error.message
      value: "{{{ _ingest.on_failure_message }}}"
